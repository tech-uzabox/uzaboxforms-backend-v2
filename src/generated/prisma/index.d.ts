
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupRole
 * 
 */
export type GroupRole = $Result.DefaultSelection<Prisma.$GroupRolePayload>
/**
 * Model Process
 * 
 */
export type Process = $Result.DefaultSelection<Prisma.$ProcessPayload>
/**
 * Model ProcessRole
 * 
 */
export type ProcessRole = $Result.DefaultSelection<Prisma.$ProcessRolePayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model Form
 * 
 */
export type Form = $Result.DefaultSelection<Prisma.$FormPayload>
/**
 * Model FormResponse
 * 
 */
export type FormResponse = $Result.DefaultSelection<Prisma.$FormResponsePayload>
/**
 * Model ProcessForm
 * 
 */
export type ProcessForm = $Result.DefaultSelection<Prisma.$ProcessFormPayload>
/**
 * Model ApplicantProcess
 * 
 */
export type ApplicantProcess = $Result.DefaultSelection<Prisma.$ApplicantProcessPayload>
/**
 * Model ProcessedApplication
 * 
 */
export type ProcessedApplication = $Result.DefaultSelection<Prisma.$ProcessedApplicationPayload>
/**
 * Model APCompletedForm
 * 
 */
export type APCompletedForm = $Result.DefaultSelection<Prisma.$APCompletedFormPayload>
/**
 * Model ProcessComment
 * 
 */
export type ProcessComment = $Result.DefaultSelection<Prisma.$ProcessCommentPayload>
/**
 * Model OrganizationUser
 * 
 */
export type OrganizationUser = $Result.DefaultSelection<Prisma.$OrganizationUserPayload>
/**
 * Model Dashboard
 * 
 */
export type Dashboard = $Result.DefaultSelection<Prisma.$DashboardPayload>
/**
 * Model Widget
 * 
 */
export type Widget = $Result.DefaultSelection<Prisma.$WidgetPayload>
/**
 * Model QrCodeDocument
 * 
 */
export type QrCodeDocument = $Result.DefaultSelection<Prisma.$QrCodeDocumentPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model Management
 * 
 */
export type Management = $Result.DefaultSelection<Prisma.$ManagementPayload>
/**
 * Model AddToDatabase
 * 
 */
export type AddToDatabase = $Result.DefaultSelection<Prisma.$AddToDatabasePayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Suggestion
 * 
 */
export type Suggestion = $Result.DefaultSelection<Prisma.$SuggestionPayload>
/**
 * Model ProcessSave
 * 
 */
export type ProcessSave = $Result.DefaultSelection<Prisma.$ProcessSavePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserStatus: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED',
  PENDING: 'PENDING'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const RoleStatus: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED'
};

export type RoleStatus = (typeof RoleStatus)[keyof typeof RoleStatus]


export const GroupStatus: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED'
};

export type GroupStatus = (typeof GroupStatus)[keyof typeof GroupStatus]


export const ProcessType: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE'
};

export type ProcessType = (typeof ProcessType)[keyof typeof ProcessType]


export const ProcessStatus: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED'
};

export type ProcessStatus = (typeof ProcessStatus)[keyof typeof ProcessStatus]


export const FormType: {
  PUBLIC: 'PUBLIC',
  INTERNAL: 'INTERNAL'
};

export type FormType = (typeof FormType)[keyof typeof FormType]


export const FormStatus: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED'
};

export type FormStatus = (typeof FormStatus)[keyof typeof FormStatus]


export const NextStepType: {
  STATIC: 'STATIC',
  DYNAMIC: 'DYNAMIC',
  FOLLOW_ORGANIZATION_CHART: 'FOLLOW_ORGANIZATION_CHART',
  NOT_APPLICABLE: 'NOT_APPLICABLE'
};

export type NextStepType = (typeof NextStepType)[keyof typeof NextStepType]


export const ManagementType: {
  HEADER: 'HEADER',
  FOOTER: 'FOOTER'
};

export type ManagementType = (typeof ManagementType)[keyof typeof ManagementType]


export const AddToDatabaseStatus: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED'
};

export type AddToDatabaseStatus = (typeof AddToDatabaseStatus)[keyof typeof AddToDatabaseStatus]

}

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type RoleStatus = $Enums.RoleStatus

export const RoleStatus: typeof $Enums.RoleStatus

export type GroupStatus = $Enums.GroupStatus

export const GroupStatus: typeof $Enums.GroupStatus

export type ProcessType = $Enums.ProcessType

export const ProcessType: typeof $Enums.ProcessType

export type ProcessStatus = $Enums.ProcessStatus

export const ProcessStatus: typeof $Enums.ProcessStatus

export type FormType = $Enums.FormType

export const FormType: typeof $Enums.FormType

export type FormStatus = $Enums.FormStatus

export const FormStatus: typeof $Enums.FormStatus

export type NextStepType = $Enums.NextStepType

export const NextStepType: typeof $Enums.NextStepType

export type ManagementType = $Enums.ManagementType

export const ManagementType: typeof $Enums.ManagementType

export type AddToDatabaseStatus = $Enums.AddToDatabaseStatus

export const AddToDatabaseStatus: typeof $Enums.AddToDatabaseStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupRole`: Exposes CRUD operations for the **GroupRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupRoles
    * const groupRoles = await prisma.groupRole.findMany()
    * ```
    */
  get groupRole(): Prisma.GroupRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.process`: Exposes CRUD operations for the **Process** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processes
    * const processes = await prisma.process.findMany()
    * ```
    */
  get process(): Prisma.ProcessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processRole`: Exposes CRUD operations for the **ProcessRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessRoles
    * const processRoles = await prisma.processRole.findMany()
    * ```
    */
  get processRole(): Prisma.ProcessRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **Form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.FormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formResponse`: Exposes CRUD operations for the **FormResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormResponses
    * const formResponses = await prisma.formResponse.findMany()
    * ```
    */
  get formResponse(): Prisma.FormResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processForm`: Exposes CRUD operations for the **ProcessForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessForms
    * const processForms = await prisma.processForm.findMany()
    * ```
    */
  get processForm(): Prisma.ProcessFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicantProcess`: Exposes CRUD operations for the **ApplicantProcess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApplicantProcesses
    * const applicantProcesses = await prisma.applicantProcess.findMany()
    * ```
    */
  get applicantProcess(): Prisma.ApplicantProcessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processedApplication`: Exposes CRUD operations for the **ProcessedApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessedApplications
    * const processedApplications = await prisma.processedApplication.findMany()
    * ```
    */
  get processedApplication(): Prisma.ProcessedApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aPCompletedForm`: Exposes CRUD operations for the **APCompletedForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more APCompletedForms
    * const aPCompletedForms = await prisma.aPCompletedForm.findMany()
    * ```
    */
  get aPCompletedForm(): Prisma.APCompletedFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processComment`: Exposes CRUD operations for the **ProcessComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessComments
    * const processComments = await prisma.processComment.findMany()
    * ```
    */
  get processComment(): Prisma.ProcessCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationUser`: Exposes CRUD operations for the **OrganizationUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationUsers
    * const organizationUsers = await prisma.organizationUser.findMany()
    * ```
    */
  get organizationUser(): Prisma.OrganizationUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboard`: Exposes CRUD operations for the **Dashboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dashboards
    * const dashboards = await prisma.dashboard.findMany()
    * ```
    */
  get dashboard(): Prisma.DashboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.widget`: Exposes CRUD operations for the **Widget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Widgets
    * const widgets = await prisma.widget.findMany()
    * ```
    */
  get widget(): Prisma.WidgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qrCodeDocument`: Exposes CRUD operations for the **QrCodeDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QrCodeDocuments
    * const qrCodeDocuments = await prisma.qrCodeDocument.findMany()
    * ```
    */
  get qrCodeDocument(): Prisma.QrCodeDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.management`: Exposes CRUD operations for the **Management** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managements
    * const managements = await prisma.management.findMany()
    * ```
    */
  get management(): Prisma.ManagementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addToDatabase`: Exposes CRUD operations for the **AddToDatabase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddToDatabases
    * const addToDatabases = await prisma.addToDatabase.findMany()
    * ```
    */
  get addToDatabase(): Prisma.AddToDatabaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suggestion`: Exposes CRUD operations for the **Suggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suggestions
    * const suggestions = await prisma.suggestion.findMany()
    * ```
    */
  get suggestion(): Prisma.SuggestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processSave`: Exposes CRUD operations for the **ProcessSave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcessSaves
    * const processSaves = await prisma.processSave.findMany()
    * ```
    */
  get processSave(): Prisma.ProcessSaveDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    File: 'File',
    AuditLog: 'AuditLog',
    Group: 'Group',
    GroupRole: 'GroupRole',
    Process: 'Process',
    ProcessRole: 'ProcessRole',
    Folder: 'Folder',
    Form: 'Form',
    FormResponse: 'FormResponse',
    ProcessForm: 'ProcessForm',
    ApplicantProcess: 'ApplicantProcess',
    ProcessedApplication: 'ProcessedApplication',
    APCompletedForm: 'APCompletedForm',
    ProcessComment: 'ProcessComment',
    OrganizationUser: 'OrganizationUser',
    Dashboard: 'Dashboard',
    Widget: 'Widget',
    QrCodeDocument: 'QrCodeDocument',
    Otp: 'Otp',
    Management: 'Management',
    AddToDatabase: 'AddToDatabase',
    Chat: 'Chat',
    Message: 'Message',
    Vote: 'Vote',
    Document: 'Document',
    Suggestion: 'Suggestion',
    ProcessSave: 'ProcessSave'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "userRole" | "file" | "auditLog" | "group" | "groupRole" | "process" | "processRole" | "folder" | "form" | "formResponse" | "processForm" | "applicantProcess" | "processedApplication" | "aPCompletedForm" | "processComment" | "organizationUser" | "dashboard" | "widget" | "qrCodeDocument" | "otp" | "management" | "addToDatabase" | "chat" | "message" | "vote" | "document" | "suggestion" | "processSave"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupRole: {
        payload: Prisma.$GroupRolePayload<ExtArgs>
        fields: Prisma.GroupRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>
          }
          findFirst: {
            args: Prisma.GroupRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>
          }
          findMany: {
            args: Prisma.GroupRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>[]
          }
          create: {
            args: Prisma.GroupRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>
          }
          createMany: {
            args: Prisma.GroupRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>[]
          }
          delete: {
            args: Prisma.GroupRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>
          }
          update: {
            args: Prisma.GroupRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>
          }
          deleteMany: {
            args: Prisma.GroupRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>[]
          }
          upsert: {
            args: Prisma.GroupRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupRolePayload>
          }
          aggregate: {
            args: Prisma.GroupRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupRole>
          }
          groupBy: {
            args: Prisma.GroupRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupRoleCountArgs<ExtArgs>
            result: $Utils.Optional<GroupRoleCountAggregateOutputType> | number
          }
        }
      }
      Process: {
        payload: Prisma.$ProcessPayload<ExtArgs>
        fields: Prisma.ProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findFirst: {
            args: Prisma.ProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          findMany: {
            args: Prisma.ProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          create: {
            args: Prisma.ProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          createMany: {
            args: Prisma.ProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          delete: {
            args: Prisma.ProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          update: {
            args: Prisma.ProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          deleteMany: {
            args: Prisma.ProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>[]
          }
          upsert: {
            args: Prisma.ProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessPayload>
          }
          aggregate: {
            args: Prisma.ProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcess>
          }
          groupBy: {
            args: Prisma.ProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessCountAggregateOutputType> | number
          }
        }
      }
      ProcessRole: {
        payload: Prisma.$ProcessRolePayload<ExtArgs>
        fields: Prisma.ProcessRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>
          }
          findFirst: {
            args: Prisma.ProcessRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>
          }
          findMany: {
            args: Prisma.ProcessRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>[]
          }
          create: {
            args: Prisma.ProcessRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>
          }
          createMany: {
            args: Prisma.ProcessRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>[]
          }
          delete: {
            args: Prisma.ProcessRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>
          }
          update: {
            args: Prisma.ProcessRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>
          }
          deleteMany: {
            args: Prisma.ProcessRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>[]
          }
          upsert: {
            args: Prisma.ProcessRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessRolePayload>
          }
          aggregate: {
            args: Prisma.ProcessRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessRole>
          }
          groupBy: {
            args: Prisma.ProcessRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessRoleCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessRoleCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      Form: {
        payload: Prisma.$FormPayload<ExtArgs>
        fields: Prisma.FormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findFirst: {
            args: Prisma.FormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          findMany: {
            args: Prisma.FormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          create: {
            args: Prisma.FormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          createMany: {
            args: Prisma.FormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          delete: {
            args: Prisma.FormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          update: {
            args: Prisma.FormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          deleteMany: {
            args: Prisma.FormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>[]
          }
          upsert: {
            args: Prisma.FormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormPayload>
          }
          aggregate: {
            args: Prisma.FormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForm>
          }
          groupBy: {
            args: Prisma.FormGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormCountArgs<ExtArgs>
            result: $Utils.Optional<FormCountAggregateOutputType> | number
          }
        }
      }
      FormResponse: {
        payload: Prisma.$FormResponsePayload<ExtArgs>
        fields: Prisma.FormResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          findFirst: {
            args: Prisma.FormResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          findMany: {
            args: Prisma.FormResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
          }
          create: {
            args: Prisma.FormResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          createMany: {
            args: Prisma.FormResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
          }
          delete: {
            args: Prisma.FormResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          update: {
            args: Prisma.FormResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          deleteMany: {
            args: Prisma.FormResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
          }
          upsert: {
            args: Prisma.FormResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormResponsePayload>
          }
          aggregate: {
            args: Prisma.FormResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormResponse>
          }
          groupBy: {
            args: Prisma.FormResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormResponseCountArgs<ExtArgs>
            result: $Utils.Optional<FormResponseCountAggregateOutputType> | number
          }
        }
      }
      ProcessForm: {
        payload: Prisma.$ProcessFormPayload<ExtArgs>
        fields: Prisma.ProcessFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>
          }
          findFirst: {
            args: Prisma.ProcessFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>
          }
          findMany: {
            args: Prisma.ProcessFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>[]
          }
          create: {
            args: Prisma.ProcessFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>
          }
          createMany: {
            args: Prisma.ProcessFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>[]
          }
          delete: {
            args: Prisma.ProcessFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>
          }
          update: {
            args: Prisma.ProcessFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>
          }
          deleteMany: {
            args: Prisma.ProcessFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>[]
          }
          upsert: {
            args: Prisma.ProcessFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessFormPayload>
          }
          aggregate: {
            args: Prisma.ProcessFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessForm>
          }
          groupBy: {
            args: Prisma.ProcessFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessFormCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessFormCountAggregateOutputType> | number
          }
        }
      }
      ApplicantProcess: {
        payload: Prisma.$ApplicantProcessPayload<ExtArgs>
        fields: Prisma.ApplicantProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicantProcessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicantProcessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>
          }
          findFirst: {
            args: Prisma.ApplicantProcessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicantProcessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>
          }
          findMany: {
            args: Prisma.ApplicantProcessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>[]
          }
          create: {
            args: Prisma.ApplicantProcessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>
          }
          createMany: {
            args: Prisma.ApplicantProcessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicantProcessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>[]
          }
          delete: {
            args: Prisma.ApplicantProcessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>
          }
          update: {
            args: Prisma.ApplicantProcessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>
          }
          deleteMany: {
            args: Prisma.ApplicantProcessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicantProcessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplicantProcessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>[]
          }
          upsert: {
            args: Prisma.ApplicantProcessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicantProcessPayload>
          }
          aggregate: {
            args: Prisma.ApplicantProcessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicantProcess>
          }
          groupBy: {
            args: Prisma.ApplicantProcessGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicantProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicantProcessCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicantProcessCountAggregateOutputType> | number
          }
        }
      }
      ProcessedApplication: {
        payload: Prisma.$ProcessedApplicationPayload<ExtArgs>
        fields: Prisma.ProcessedApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessedApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessedApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>
          }
          findFirst: {
            args: Prisma.ProcessedApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessedApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>
          }
          findMany: {
            args: Prisma.ProcessedApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>[]
          }
          create: {
            args: Prisma.ProcessedApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>
          }
          createMany: {
            args: Prisma.ProcessedApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessedApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>[]
          }
          delete: {
            args: Prisma.ProcessedApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>
          }
          update: {
            args: Prisma.ProcessedApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ProcessedApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessedApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessedApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>[]
          }
          upsert: {
            args: Prisma.ProcessedApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessedApplicationPayload>
          }
          aggregate: {
            args: Prisma.ProcessedApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessedApplication>
          }
          groupBy: {
            args: Prisma.ProcessedApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessedApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessedApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessedApplicationCountAggregateOutputType> | number
          }
        }
      }
      APCompletedForm: {
        payload: Prisma.$APCompletedFormPayload<ExtArgs>
        fields: Prisma.APCompletedFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.APCompletedFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.APCompletedFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>
          }
          findFirst: {
            args: Prisma.APCompletedFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.APCompletedFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>
          }
          findMany: {
            args: Prisma.APCompletedFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>[]
          }
          create: {
            args: Prisma.APCompletedFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>
          }
          createMany: {
            args: Prisma.APCompletedFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.APCompletedFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>[]
          }
          delete: {
            args: Prisma.APCompletedFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>
          }
          update: {
            args: Prisma.APCompletedFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>
          }
          deleteMany: {
            args: Prisma.APCompletedFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.APCompletedFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.APCompletedFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>[]
          }
          upsert: {
            args: Prisma.APCompletedFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APCompletedFormPayload>
          }
          aggregate: {
            args: Prisma.APCompletedFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAPCompletedForm>
          }
          groupBy: {
            args: Prisma.APCompletedFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<APCompletedFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.APCompletedFormCountArgs<ExtArgs>
            result: $Utils.Optional<APCompletedFormCountAggregateOutputType> | number
          }
        }
      }
      ProcessComment: {
        payload: Prisma.$ProcessCommentPayload<ExtArgs>
        fields: Prisma.ProcessCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>
          }
          findFirst: {
            args: Prisma.ProcessCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>
          }
          findMany: {
            args: Prisma.ProcessCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>[]
          }
          create: {
            args: Prisma.ProcessCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>
          }
          createMany: {
            args: Prisma.ProcessCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>[]
          }
          delete: {
            args: Prisma.ProcessCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>
          }
          update: {
            args: Prisma.ProcessCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>
          }
          deleteMany: {
            args: Prisma.ProcessCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>[]
          }
          upsert: {
            args: Prisma.ProcessCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessCommentPayload>
          }
          aggregate: {
            args: Prisma.ProcessCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessComment>
          }
          groupBy: {
            args: Prisma.ProcessCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessCommentCountAggregateOutputType> | number
          }
        }
      }
      OrganizationUser: {
        payload: Prisma.$OrganizationUserPayload<ExtArgs>
        fields: Prisma.OrganizationUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>
          }
          findFirst: {
            args: Prisma.OrganizationUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>
          }
          findMany: {
            args: Prisma.OrganizationUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>[]
          }
          create: {
            args: Prisma.OrganizationUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>
          }
          createMany: {
            args: Prisma.OrganizationUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>[]
          }
          delete: {
            args: Prisma.OrganizationUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>
          }
          update: {
            args: Prisma.OrganizationUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationUserPayload>
          }
          aggregate: {
            args: Prisma.OrganizationUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationUser>
          }
          groupBy: {
            args: Prisma.OrganizationUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationUserCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationUserCountAggregateOutputType> | number
          }
        }
      }
      Dashboard: {
        payload: Prisma.$DashboardPayload<ExtArgs>
        fields: Prisma.DashboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          findFirst: {
            args: Prisma.DashboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          findMany: {
            args: Prisma.DashboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          create: {
            args: Prisma.DashboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          createMany: {
            args: Prisma.DashboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          delete: {
            args: Prisma.DashboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          update: {
            args: Prisma.DashboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          deleteMany: {
            args: Prisma.DashboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[]
          }
          upsert: {
            args: Prisma.DashboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>
          }
          aggregate: {
            args: Prisma.DashboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboard>
          }
          groupBy: {
            args: Prisma.DashboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardCountAggregateOutputType> | number
          }
        }
      }
      Widget: {
        payload: Prisma.$WidgetPayload<ExtArgs>
        fields: Prisma.WidgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WidgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WidgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          findFirst: {
            args: Prisma.WidgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WidgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          findMany: {
            args: Prisma.WidgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[]
          }
          create: {
            args: Prisma.WidgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          createMany: {
            args: Prisma.WidgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WidgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[]
          }
          delete: {
            args: Prisma.WidgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          update: {
            args: Prisma.WidgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          deleteMany: {
            args: Prisma.WidgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WidgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WidgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[]
          }
          upsert: {
            args: Prisma.WidgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>
          }
          aggregate: {
            args: Prisma.WidgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWidget>
          }
          groupBy: {
            args: Prisma.WidgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<WidgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.WidgetCountArgs<ExtArgs>
            result: $Utils.Optional<WidgetCountAggregateOutputType> | number
          }
        }
      }
      QrCodeDocument: {
        payload: Prisma.$QrCodeDocumentPayload<ExtArgs>
        fields: Prisma.QrCodeDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QrCodeDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QrCodeDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>
          }
          findFirst: {
            args: Prisma.QrCodeDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QrCodeDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>
          }
          findMany: {
            args: Prisma.QrCodeDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>[]
          }
          create: {
            args: Prisma.QrCodeDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>
          }
          createMany: {
            args: Prisma.QrCodeDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QrCodeDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>[]
          }
          delete: {
            args: Prisma.QrCodeDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>
          }
          update: {
            args: Prisma.QrCodeDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>
          }
          deleteMany: {
            args: Prisma.QrCodeDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QrCodeDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QrCodeDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>[]
          }
          upsert: {
            args: Prisma.QrCodeDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QrCodeDocumentPayload>
          }
          aggregate: {
            args: Prisma.QrCodeDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQrCodeDocument>
          }
          groupBy: {
            args: Prisma.QrCodeDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<QrCodeDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.QrCodeDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<QrCodeDocumentCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Management: {
        payload: Prisma.$ManagementPayload<ExtArgs>
        fields: Prisma.ManagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>
          }
          findFirst: {
            args: Prisma.ManagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>
          }
          findMany: {
            args: Prisma.ManagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>[]
          }
          create: {
            args: Prisma.ManagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>
          }
          createMany: {
            args: Prisma.ManagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManagementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>[]
          }
          delete: {
            args: Prisma.ManagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>
          }
          update: {
            args: Prisma.ManagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>
          }
          deleteMany: {
            args: Prisma.ManagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ManagementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>[]
          }
          upsert: {
            args: Prisma.ManagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagementPayload>
          }
          aggregate: {
            args: Prisma.ManagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManagement>
          }
          groupBy: {
            args: Prisma.ManagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagementCountArgs<ExtArgs>
            result: $Utils.Optional<ManagementCountAggregateOutputType> | number
          }
        }
      }
      AddToDatabase: {
        payload: Prisma.$AddToDatabasePayload<ExtArgs>
        fields: Prisma.AddToDatabaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddToDatabaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddToDatabaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>
          }
          findFirst: {
            args: Prisma.AddToDatabaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddToDatabaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>
          }
          findMany: {
            args: Prisma.AddToDatabaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>[]
          }
          create: {
            args: Prisma.AddToDatabaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>
          }
          createMany: {
            args: Prisma.AddToDatabaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddToDatabaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>[]
          }
          delete: {
            args: Prisma.AddToDatabaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>
          }
          update: {
            args: Prisma.AddToDatabaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>
          }
          deleteMany: {
            args: Prisma.AddToDatabaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddToDatabaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddToDatabaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>[]
          }
          upsert: {
            args: Prisma.AddToDatabaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddToDatabasePayload>
          }
          aggregate: {
            args: Prisma.AddToDatabaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddToDatabase>
          }
          groupBy: {
            args: Prisma.AddToDatabaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddToDatabaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddToDatabaseCountArgs<ExtArgs>
            result: $Utils.Optional<AddToDatabaseCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Suggestion: {
        payload: Prisma.$SuggestionPayload<ExtArgs>
        fields: Prisma.SuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          findFirst: {
            args: Prisma.SuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          findMany: {
            args: Prisma.SuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          create: {
            args: Prisma.SuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          createMany: {
            args: Prisma.SuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          delete: {
            args: Prisma.SuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          update: {
            args: Prisma.SuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          deleteMany: {
            args: Prisma.SuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          upsert: {
            args: Prisma.SuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          aggregate: {
            args: Prisma.SuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuggestion>
          }
          groupBy: {
            args: Prisma.SuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<SuggestionCountAggregateOutputType> | number
          }
        }
      }
      ProcessSave: {
        payload: Prisma.$ProcessSavePayload<ExtArgs>
        fields: Prisma.ProcessSaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcessSaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcessSaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>
          }
          findFirst: {
            args: Prisma.ProcessSaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcessSaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>
          }
          findMany: {
            args: Prisma.ProcessSaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>[]
          }
          create: {
            args: Prisma.ProcessSaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>
          }
          createMany: {
            args: Prisma.ProcessSaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcessSaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>[]
          }
          delete: {
            args: Prisma.ProcessSaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>
          }
          update: {
            args: Prisma.ProcessSaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>
          }
          deleteMany: {
            args: Prisma.ProcessSaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcessSaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProcessSaveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>[]
          }
          upsert: {
            args: Prisma.ProcessSaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcessSavePayload>
          }
          aggregate: {
            args: Prisma.ProcessSaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcessSave>
          }
          groupBy: {
            args: Prisma.ProcessSaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcessSaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcessSaveCountArgs<ExtArgs>
            result: $Utils.Optional<ProcessSaveCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    file?: FileOmit
    auditLog?: AuditLogOmit
    group?: GroupOmit
    groupRole?: GroupRoleOmit
    process?: ProcessOmit
    processRole?: ProcessRoleOmit
    folder?: FolderOmit
    form?: FormOmit
    formResponse?: FormResponseOmit
    processForm?: ProcessFormOmit
    applicantProcess?: ApplicantProcessOmit
    processedApplication?: ProcessedApplicationOmit
    aPCompletedForm?: APCompletedFormOmit
    processComment?: ProcessCommentOmit
    organizationUser?: OrganizationUserOmit
    dashboard?: DashboardOmit
    widget?: WidgetOmit
    qrCodeDocument?: QrCodeDocumentOmit
    otp?: OtpOmit
    management?: ManagementOmit
    addToDatabase?: AddToDatabaseOmit
    chat?: ChatOmit
    message?: MessageOmit
    vote?: VoteOmit
    document?: DocumentOmit
    suggestion?: SuggestionOmit
    processSave?: ProcessSaveOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    applicantProcesses: number
    auditLogs: number
    files: number
    createdForms: number
    createdFolders: number
    createdGroups: number
    createdProcesses: number
    processedApplications: number
    qrCodeDocuments: number
    roles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcesses?: boolean | UserCountOutputTypeCountApplicantProcessesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    files?: boolean | UserCountOutputTypeCountFilesArgs
    createdForms?: boolean | UserCountOutputTypeCountCreatedFormsArgs
    createdFolders?: boolean | UserCountOutputTypeCountCreatedFoldersArgs
    createdGroups?: boolean | UserCountOutputTypeCountCreatedGroupsArgs
    createdProcesses?: boolean | UserCountOutputTypeCountCreatedProcessesArgs
    processedApplications?: boolean | UserCountOutputTypeCountProcessedApplicationsArgs
    qrCodeDocuments?: boolean | UserCountOutputTypeCountQrCodeDocumentsArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicantProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantProcessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessedApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQrCodeDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QrCodeDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    groups: number
    processes: number
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | RoleCountOutputTypeCountGroupsArgs
    processes?: boolean | RoleCountOutputTypeCountProcessesArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    roles: number
    processes: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | GroupCountOutputTypeCountRolesArgs
    processes?: boolean | GroupCountOutputTypeCountProcessesArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupRoleWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
  }


  /**
   * Count Type ProcessCountOutputType
   */

  export type ProcessCountOutputType = {
    applicantProcesses: number
    formResponses: number
    forms: number
    processedApplications: number
    roles: number
  }

  export type ProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcesses?: boolean | ProcessCountOutputTypeCountApplicantProcessesArgs
    formResponses?: boolean | ProcessCountOutputTypeCountFormResponsesArgs
    forms?: boolean | ProcessCountOutputTypeCountFormsArgs
    processedApplications?: boolean | ProcessCountOutputTypeCountProcessedApplicationsArgs
    roles?: boolean | ProcessCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessCountOutputType
     */
    select?: ProcessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountApplicantProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantProcessWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountFormResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessFormWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountProcessedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessedApplicationWhereInput
  }

  /**
   * ProcessCountOutputType without action
   */
  export type ProcessCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessRoleWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    forms: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forms?: boolean | FolderCountOutputTypeCountFormsArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
  }


  /**
   * Count Type FormCountOutputType
   */

  export type FormCountOutputType = {
    responses: number
    processForms: number
  }

  export type FormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | FormCountOutputTypeCountResponsesArgs
    processForms?: boolean | FormCountOutputTypeCountProcessFormsArgs
  }

  // Custom InputTypes
  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormCountOutputType
     */
    select?: FormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
  }

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeCountProcessFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessFormWhereInput
  }


  /**
   * Count Type ApplicantProcessCountOutputType
   */

  export type ApplicantProcessCountOutputType = {
    completedForms: number
    processedApplications: number
    responses: number
    comments: number
  }

  export type ApplicantProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completedForms?: boolean | ApplicantProcessCountOutputTypeCountCompletedFormsArgs
    processedApplications?: boolean | ApplicantProcessCountOutputTypeCountProcessedApplicationsArgs
    responses?: boolean | ApplicantProcessCountOutputTypeCountResponsesArgs
    comments?: boolean | ApplicantProcessCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ApplicantProcessCountOutputType without action
   */
  export type ApplicantProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcessCountOutputType
     */
    select?: ApplicantProcessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicantProcessCountOutputType without action
   */
  export type ApplicantProcessCountOutputTypeCountCompletedFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: APCompletedFormWhereInput
  }

  /**
   * ApplicantProcessCountOutputType without action
   */
  export type ApplicantProcessCountOutputTypeCountProcessedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessedApplicationWhereInput
  }

  /**
   * ApplicantProcessCountOutputType without action
   */
  export type ApplicantProcessCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
  }

  /**
   * ApplicantProcessCountOutputType without action
   */
  export type ApplicantProcessCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessCommentWhereInput
  }


  /**
   * Count Type OrganizationUserCountOutputType
   */

  export type OrganizationUserCountOutputType = {
    subordinates: number
  }

  export type OrganizationUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subordinates?: boolean | OrganizationUserCountOutputTypeCountSubordinatesArgs
  }

  // Custom InputTypes
  /**
   * OrganizationUserCountOutputType without action
   */
  export type OrganizationUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUserCountOutputType
     */
    select?: OrganizationUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationUserCountOutputType without action
   */
  export type OrganizationUserCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationUserWhereInput
  }


  /**
   * Count Type DashboardCountOutputType
   */

  export type DashboardCountOutputType = {
    widgets: number
  }

  export type DashboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    widgets?: boolean | DashboardCountOutputTypeCountWidgetsArgs
  }

  // Custom InputTypes
  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardCountOutputType
     */
    select?: DashboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeCountWidgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WidgetWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    votes: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | MessageCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    suggestions: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suggestions?: boolean | DocumentCountOutputTypeCountSuggestionsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountSuggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    photo: string | null
    googleId: string | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    photo: string | null
    googleId: string | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    photo: number
    googleId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    photo?: true
    googleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    photo?: true
    googleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    photo?: true
    googleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string | null
    lastName: string | null
    photo: string | null
    googleId: string | null
    status: $Enums.UserStatus
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    photo?: boolean
    googleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantProcesses?: boolean | User$applicantProcessesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    createdForms?: boolean | User$createdFormsArgs<ExtArgs>
    createdFolders?: boolean | User$createdFoldersArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    organization?: boolean | User$organizationArgs<ExtArgs>
    createdProcesses?: boolean | User$createdProcessesArgs<ExtArgs>
    processedApplications?: boolean | User$processedApplicationsArgs<ExtArgs>
    qrCodeDocuments?: boolean | User$qrCodeDocumentsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    photo?: boolean
    googleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    photo?: boolean
    googleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    photo?: boolean
    googleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "photo" | "googleId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcesses?: boolean | User$applicantProcessesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    createdForms?: boolean | User$createdFormsArgs<ExtArgs>
    createdFolders?: boolean | User$createdFoldersArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    organization?: boolean | User$organizationArgs<ExtArgs>
    createdProcesses?: boolean | User$createdProcessesArgs<ExtArgs>
    processedApplications?: boolean | User$processedApplicationsArgs<ExtArgs>
    qrCodeDocuments?: boolean | User$qrCodeDocumentsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      applicantProcesses: Prisma.$ApplicantProcessPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      createdForms: Prisma.$FormPayload<ExtArgs>[]
      createdFolders: Prisma.$FolderPayload<ExtArgs>[]
      createdGroups: Prisma.$GroupPayload<ExtArgs>[]
      organization: Prisma.$OrganizationUserPayload<ExtArgs> | null
      createdProcesses: Prisma.$ProcessPayload<ExtArgs>[]
      processedApplications: Prisma.$ProcessedApplicationPayload<ExtArgs>[]
      qrCodeDocuments: Prisma.$QrCodeDocumentPayload<ExtArgs>[]
      roles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string | null
      lastName: string | null
      photo: string | null
      googleId: string | null
      status: $Enums.UserStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicantProcesses<T extends User$applicantProcessesArgs<ExtArgs> = {}>(args?: Subset<T, User$applicantProcessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends User$filesArgs<ExtArgs> = {}>(args?: Subset<T, User$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdForms<T extends User$createdFormsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdFolders<T extends User$createdFoldersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdFoldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdGroups<T extends User$createdGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdProcesses<T extends User$createdProcessesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProcessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processedApplications<T extends User$processedApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$processedApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qrCodeDocuments<T extends User$qrCodeDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$qrCodeDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly photo: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.applicantProcesses
   */
  export type User$applicantProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    where?: ApplicantProcessWhereInput
    orderBy?: ApplicantProcessOrderByWithRelationInput | ApplicantProcessOrderByWithRelationInput[]
    cursor?: ApplicantProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicantProcessScalarFieldEnum | ApplicantProcessScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.files
   */
  export type User$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * User.createdForms
   */
  export type User$createdFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    where?: FormWhereInput
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    cursor?: FormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * User.createdFolders
   */
  export type User$createdFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * User.createdGroups
   */
  export type User$createdGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    where?: OrganizationUserWhereInput
  }

  /**
   * User.createdProcesses
   */
  export type User$createdProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * User.processedApplications
   */
  export type User$processedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    where?: ProcessedApplicationWhereInput
    orderBy?: ProcessedApplicationOrderByWithRelationInput | ProcessedApplicationOrderByWithRelationInput[]
    cursor?: ProcessedApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessedApplicationScalarFieldEnum | ProcessedApplicationScalarFieldEnum[]
  }

  /**
   * User.qrCodeDocuments
   */
  export type User$qrCodeDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    where?: QrCodeDocumentWhereInput
    orderBy?: QrCodeDocumentOrderByWithRelationInput | QrCodeDocumentOrderByWithRelationInput[]
    cursor?: QrCodeDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QrCodeDocumentScalarFieldEnum | QrCodeDocumentScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.RoleStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.RoleStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: $Enums.RoleStatus
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groups?: boolean | Role$groupsArgs<ExtArgs>
    processes?: boolean | Role$processesArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | Role$groupsArgs<ExtArgs>
    processes?: boolean | Role$processesArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      groups: Prisma.$GroupRolePayload<ExtArgs>[]
      processes: Prisma.$ProcessRolePayload<ExtArgs>[]
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: $Enums.RoleStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groups<T extends Role$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Role$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processes<T extends Role$processesArgs<ExtArgs> = {}>(args?: Subset<T, Role$processesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly status: FieldRef<"Role", 'RoleStatus'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.groups
   */
  export type Role$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    where?: GroupRoleWhereInput
    orderBy?: GroupRoleOrderByWithRelationInput | GroupRoleOrderByWithRelationInput[]
    cursor?: GroupRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupRoleScalarFieldEnum | GroupRoleScalarFieldEnum[]
  }

  /**
   * Role.processes
   */
  export type Role$processesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    where?: ProcessRoleWhereInput
    orderBy?: ProcessRoleOrderByWithRelationInput | ProcessRoleOrderByWithRelationInput[]
    cursor?: ProcessRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessRoleScalarFieldEnum | ProcessRoleScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: string | null
    status: $Enums.RoleStatus | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: string | null
    status: $Enums.RoleStatus | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    status: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
    status?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
    status?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    status?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: string
    status: $Enums.RoleStatus
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    status?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    status?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    status?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
    status?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId" | "status", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: string
      status: $Enums.RoleStatus
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly status: FieldRef<"UserRole", 'RoleStatus'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    size: number | null
    isPrivate: boolean | null
    title: string | null
    userId: string | null
    fileType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    size: number | null
    isPrivate: boolean | null
    title: string | null
    userId: string | null
    fileType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    fileUrl: number
    thumbnailUrl: number
    size: number
    isPrivate: number
    title: number
    userId: number
    fileType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    fileUrl?: true
    thumbnailUrl?: true
    size?: true
    isPrivate?: true
    title?: true
    userId?: true
    fileType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    fileUrl?: true
    thumbnailUrl?: true
    size?: true
    isPrivate?: true
    title?: true
    userId?: true
    fileType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    fileUrl?: true
    thumbnailUrl?: true
    size?: true
    isPrivate?: true
    title?: true
    userId?: true
    fileType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    fileUrl: string
    thumbnailUrl: string | null
    size: number
    isPrivate: boolean
    title: string
    userId: string
    fileType: string
    createdAt: Date
    updatedAt: Date
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    size?: boolean
    isPrivate?: boolean
    title?: boolean
    userId?: boolean
    fileType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    size?: boolean
    isPrivate?: boolean
    title?: boolean
    userId?: boolean
    fileType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    size?: boolean
    isPrivate?: boolean
    title?: boolean
    userId?: boolean
    fileType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    size?: boolean
    isPrivate?: boolean
    title?: boolean
    userId?: boolean
    fileType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileUrl" | "thumbnailUrl" | "size" | "isPrivate" | "title" | "userId" | "fileType" | "createdAt" | "updatedAt", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileUrl: string
      thumbnailUrl: string | null
      size: number
      isPrivate: boolean
      title: string
      userId: string
      fileType: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly fileUrl: FieldRef<"File", 'String'>
    readonly thumbnailUrl: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly isPrivate: FieldRef<"File", 'Boolean'>
    readonly title: FieldRef<"File", 'String'>
    readonly userId: FieldRef<"File", 'String'>
    readonly fileType: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    status: string | null
    errorMessage: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    status: string | null
    errorMessage: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    timestamp: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    status: number
    errorMessage: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    status?: true
    errorMessage?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    status?: true
    errorMessage?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    status?: true
    errorMessage?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    timestamp: Date
    userId: string | null
    action: string
    resource: string | null
    resourceId: string | null
    details: JsonValue | null
    status: string
    errorMessage: string | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    status?: boolean
    errorMessage?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    status?: boolean
    errorMessage?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    status?: boolean
    errorMessage?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    status?: boolean
    errorMessage?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "userId" | "action" | "resource" | "resourceId" | "details" | "status" | "errorMessage", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      userId: string | null
      action: string
      resource: string | null
      resourceId: string | null
      details: Prisma.JsonValue | null
      status: string
      errorMessage: string | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly status: FieldRef<"AuditLog", 'String'>
    readonly errorMessage: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.GroupStatus | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.GroupStatus | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    status: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    status: $Enums.GroupStatus
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | Group$rolesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    processes?: boolean | Group$processesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Group$rolesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    processes?: boolean | Group$processesArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      roles: Prisma.$GroupRolePayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      processes: Prisma.$ProcessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: $Enums.GroupStatus
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Group$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Group$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    processes<T extends Group$processesArgs<ExtArgs> = {}>(args?: Subset<T, Group$processesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly status: FieldRef<"Group", 'GroupStatus'>
    readonly creatorId: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.roles
   */
  export type Group$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    where?: GroupRoleWhereInput
    orderBy?: GroupRoleOrderByWithRelationInput | GroupRoleOrderByWithRelationInput[]
    cursor?: GroupRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupRoleScalarFieldEnum | GroupRoleScalarFieldEnum[]
  }

  /**
   * Group.processes
   */
  export type Group$processesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    cursor?: ProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupRole
   */

  export type AggregateGroupRole = {
    _count: GroupRoleCountAggregateOutputType | null
    _min: GroupRoleMinAggregateOutputType | null
    _max: GroupRoleMaxAggregateOutputType | null
  }

  export type GroupRoleMinAggregateOutputType = {
    groupId: string | null
    roleId: string | null
    status: $Enums.RoleStatus | null
  }

  export type GroupRoleMaxAggregateOutputType = {
    groupId: string | null
    roleId: string | null
    status: $Enums.RoleStatus | null
  }

  export type GroupRoleCountAggregateOutputType = {
    groupId: number
    roleId: number
    status: number
    _all: number
  }


  export type GroupRoleMinAggregateInputType = {
    groupId?: true
    roleId?: true
    status?: true
  }

  export type GroupRoleMaxAggregateInputType = {
    groupId?: true
    roleId?: true
    status?: true
  }

  export type GroupRoleCountAggregateInputType = {
    groupId?: true
    roleId?: true
    status?: true
    _all?: true
  }

  export type GroupRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupRole to aggregate.
     */
    where?: GroupRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupRoles to fetch.
     */
    orderBy?: GroupRoleOrderByWithRelationInput | GroupRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupRoles
    **/
    _count?: true | GroupRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupRoleMaxAggregateInputType
  }

  export type GetGroupRoleAggregateType<T extends GroupRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupRole[P]>
      : GetScalarType<T[P], AggregateGroupRole[P]>
  }




  export type GroupRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupRoleWhereInput
    orderBy?: GroupRoleOrderByWithAggregationInput | GroupRoleOrderByWithAggregationInput[]
    by: GroupRoleScalarFieldEnum[] | GroupRoleScalarFieldEnum
    having?: GroupRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupRoleCountAggregateInputType | true
    _min?: GroupRoleMinAggregateInputType
    _max?: GroupRoleMaxAggregateInputType
  }

  export type GroupRoleGroupByOutputType = {
    groupId: string
    roleId: string
    status: $Enums.RoleStatus
    _count: GroupRoleCountAggregateOutputType | null
    _min: GroupRoleMinAggregateOutputType | null
    _max: GroupRoleMaxAggregateOutputType | null
  }

  type GetGroupRoleGroupByPayload<T extends GroupRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupRoleGroupByOutputType[P]>
            : GetScalarType<T[P], GroupRoleGroupByOutputType[P]>
        }
      >
    >


  export type GroupRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    roleId?: boolean
    status?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupRole"]>

  export type GroupRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    roleId?: boolean
    status?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupRole"]>

  export type GroupRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    groupId?: boolean
    roleId?: boolean
    status?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupRole"]>

  export type GroupRoleSelectScalar = {
    groupId?: boolean
    roleId?: boolean
    status?: boolean
  }

  export type GroupRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"groupId" | "roleId" | "status", ExtArgs["result"]["groupRole"]>
  export type GroupRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type GroupRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type GroupRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $GroupRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupRole"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      groupId: string
      roleId: string
      status: $Enums.RoleStatus
    }, ExtArgs["result"]["groupRole"]>
    composites: {}
  }

  type GroupRoleGetPayload<S extends boolean | null | undefined | GroupRoleDefaultArgs> = $Result.GetResult<Prisma.$GroupRolePayload, S>

  type GroupRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: GroupRoleCountAggregateInputType | true
    }

  export interface GroupRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupRole'], meta: { name: 'GroupRole' } }
    /**
     * Find zero or one GroupRole that matches the filter.
     * @param {GroupRoleFindUniqueArgs} args - Arguments to find a GroupRole
     * @example
     * // Get one GroupRole
     * const groupRole = await prisma.groupRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupRoleFindUniqueArgs>(args: SelectSubset<T, GroupRoleFindUniqueArgs<ExtArgs>>): Prisma__GroupRoleClient<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupRoleFindUniqueOrThrowArgs} args - Arguments to find a GroupRole
     * @example
     * // Get one GroupRole
     * const groupRole = await prisma.groupRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupRoleClient<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupRoleFindFirstArgs} args - Arguments to find a GroupRole
     * @example
     * // Get one GroupRole
     * const groupRole = await prisma.groupRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupRoleFindFirstArgs>(args?: SelectSubset<T, GroupRoleFindFirstArgs<ExtArgs>>): Prisma__GroupRoleClient<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupRoleFindFirstOrThrowArgs} args - Arguments to find a GroupRole
     * @example
     * // Get one GroupRole
     * const groupRole = await prisma.groupRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupRoleClient<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupRoles
     * const groupRoles = await prisma.groupRole.findMany()
     * 
     * // Get first 10 GroupRoles
     * const groupRoles = await prisma.groupRole.findMany({ take: 10 })
     * 
     * // Only select the `groupId`
     * const groupRoleWithGroupIdOnly = await prisma.groupRole.findMany({ select: { groupId: true } })
     * 
     */
    findMany<T extends GroupRoleFindManyArgs>(args?: SelectSubset<T, GroupRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupRole.
     * @param {GroupRoleCreateArgs} args - Arguments to create a GroupRole.
     * @example
     * // Create one GroupRole
     * const GroupRole = await prisma.groupRole.create({
     *   data: {
     *     // ... data to create a GroupRole
     *   }
     * })
     * 
     */
    create<T extends GroupRoleCreateArgs>(args: SelectSubset<T, GroupRoleCreateArgs<ExtArgs>>): Prisma__GroupRoleClient<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupRoles.
     * @param {GroupRoleCreateManyArgs} args - Arguments to create many GroupRoles.
     * @example
     * // Create many GroupRoles
     * const groupRole = await prisma.groupRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupRoleCreateManyArgs>(args?: SelectSubset<T, GroupRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupRoles and returns the data saved in the database.
     * @param {GroupRoleCreateManyAndReturnArgs} args - Arguments to create many GroupRoles.
     * @example
     * // Create many GroupRoles
     * const groupRole = await prisma.groupRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupRoles and only return the `groupId`
     * const groupRoleWithGroupIdOnly = await prisma.groupRole.createManyAndReturn({
     *   select: { groupId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupRole.
     * @param {GroupRoleDeleteArgs} args - Arguments to delete one GroupRole.
     * @example
     * // Delete one GroupRole
     * const GroupRole = await prisma.groupRole.delete({
     *   where: {
     *     // ... filter to delete one GroupRole
     *   }
     * })
     * 
     */
    delete<T extends GroupRoleDeleteArgs>(args: SelectSubset<T, GroupRoleDeleteArgs<ExtArgs>>): Prisma__GroupRoleClient<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupRole.
     * @param {GroupRoleUpdateArgs} args - Arguments to update one GroupRole.
     * @example
     * // Update one GroupRole
     * const groupRole = await prisma.groupRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupRoleUpdateArgs>(args: SelectSubset<T, GroupRoleUpdateArgs<ExtArgs>>): Prisma__GroupRoleClient<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupRoles.
     * @param {GroupRoleDeleteManyArgs} args - Arguments to filter GroupRoles to delete.
     * @example
     * // Delete a few GroupRoles
     * const { count } = await prisma.groupRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupRoleDeleteManyArgs>(args?: SelectSubset<T, GroupRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupRoles
     * const groupRole = await prisma.groupRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupRoleUpdateManyArgs>(args: SelectSubset<T, GroupRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupRoles and returns the data updated in the database.
     * @param {GroupRoleUpdateManyAndReturnArgs} args - Arguments to update many GroupRoles.
     * @example
     * // Update many GroupRoles
     * const groupRole = await prisma.groupRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupRoles and only return the `groupId`
     * const groupRoleWithGroupIdOnly = await prisma.groupRole.updateManyAndReturn({
     *   select: { groupId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupRole.
     * @param {GroupRoleUpsertArgs} args - Arguments to update or create a GroupRole.
     * @example
     * // Update or create a GroupRole
     * const groupRole = await prisma.groupRole.upsert({
     *   create: {
     *     // ... data to create a GroupRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupRole we want to update
     *   }
     * })
     */
    upsert<T extends GroupRoleUpsertArgs>(args: SelectSubset<T, GroupRoleUpsertArgs<ExtArgs>>): Prisma__GroupRoleClient<$Result.GetResult<Prisma.$GroupRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupRoleCountArgs} args - Arguments to filter GroupRoles to count.
     * @example
     * // Count the number of GroupRoles
     * const count = await prisma.groupRole.count({
     *   where: {
     *     // ... the filter for the GroupRoles we want to count
     *   }
     * })
    **/
    count<T extends GroupRoleCountArgs>(
      args?: Subset<T, GroupRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupRoleAggregateArgs>(args: Subset<T, GroupRoleAggregateArgs>): Prisma.PrismaPromise<GetGroupRoleAggregateType<T>>

    /**
     * Group by GroupRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupRoleGroupByArgs['orderBy'] }
        : { orderBy?: GroupRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupRole model
   */
  readonly fields: GroupRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupRole model
   */
  interface GroupRoleFieldRefs {
    readonly groupId: FieldRef<"GroupRole", 'String'>
    readonly roleId: FieldRef<"GroupRole", 'String'>
    readonly status: FieldRef<"GroupRole", 'RoleStatus'>
  }
    

  // Custom InputTypes
  /**
   * GroupRole findUnique
   */
  export type GroupRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * Filter, which GroupRole to fetch.
     */
    where: GroupRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole findUniqueOrThrow
   */
  export type GroupRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * Filter, which GroupRole to fetch.
     */
    where: GroupRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole findFirst
   */
  export type GroupRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * Filter, which GroupRole to fetch.
     */
    where?: GroupRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupRoles to fetch.
     */
    orderBy?: GroupRoleOrderByWithRelationInput | GroupRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupRoles.
     */
    cursor?: GroupRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupRoles.
     */
    distinct?: GroupRoleScalarFieldEnum | GroupRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole findFirstOrThrow
   */
  export type GroupRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * Filter, which GroupRole to fetch.
     */
    where?: GroupRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupRoles to fetch.
     */
    orderBy?: GroupRoleOrderByWithRelationInput | GroupRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupRoles.
     */
    cursor?: GroupRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupRoles.
     */
    distinct?: GroupRoleScalarFieldEnum | GroupRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole findMany
   */
  export type GroupRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * Filter, which GroupRoles to fetch.
     */
    where?: GroupRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupRoles to fetch.
     */
    orderBy?: GroupRoleOrderByWithRelationInput | GroupRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupRoles.
     */
    cursor?: GroupRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupRoles.
     */
    skip?: number
    distinct?: GroupRoleScalarFieldEnum | GroupRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole create
   */
  export type GroupRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupRole.
     */
    data: XOR<GroupRoleCreateInput, GroupRoleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole createMany
   */
  export type GroupRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupRoles.
     */
    data: GroupRoleCreateManyInput | GroupRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupRole createManyAndReturn
   */
  export type GroupRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * The data used to create many GroupRoles.
     */
    data: GroupRoleCreateManyInput | GroupRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupRole update
   */
  export type GroupRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupRole.
     */
    data: XOR<GroupRoleUpdateInput, GroupRoleUncheckedUpdateInput>
    /**
     * Choose, which GroupRole to update.
     */
    where: GroupRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole updateMany
   */
  export type GroupRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupRoles.
     */
    data: XOR<GroupRoleUpdateManyMutationInput, GroupRoleUncheckedUpdateManyInput>
    /**
     * Filter which GroupRoles to update
     */
    where?: GroupRoleWhereInput
    /**
     * Limit how many GroupRoles to update.
     */
    limit?: number
  }

  /**
   * GroupRole updateManyAndReturn
   */
  export type GroupRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * The data used to update GroupRoles.
     */
    data: XOR<GroupRoleUpdateManyMutationInput, GroupRoleUncheckedUpdateManyInput>
    /**
     * Filter which GroupRoles to update
     */
    where?: GroupRoleWhereInput
    /**
     * Limit how many GroupRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupRole upsert
   */
  export type GroupRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupRole to update in case it exists.
     */
    where: GroupRoleWhereUniqueInput
    /**
     * In case the GroupRole found by the `where` argument doesn't exist, create a new GroupRole with this data.
     */
    create: XOR<GroupRoleCreateInput, GroupRoleUncheckedCreateInput>
    /**
     * In case the GroupRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupRoleUpdateInput, GroupRoleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole delete
   */
  export type GroupRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
    /**
     * Filter which GroupRole to delete.
     */
    where: GroupRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * GroupRole deleteMany
   */
  export type GroupRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupRoles to delete
     */
    where?: GroupRoleWhereInput
    /**
     * Limit how many GroupRoles to delete.
     */
    limit?: number
  }

  /**
   * GroupRole without action
   */
  export type GroupRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupRole
     */
    select?: GroupRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupRole
     */
    omit?: GroupRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupRoleInclude<ExtArgs> | null
  }


  /**
   * Model Process
   */

  export type AggregateProcess = {
    _count: ProcessCountAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  export type ProcessMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProcessType | null
    groupId: string | null
    creatorId: string | null
    status: $Enums.ProcessStatus | null
    archived: boolean | null
    staffViewForms: boolean | null
    applicantViewProcessLevel: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProcessType | null
    groupId: string | null
    creatorId: string | null
    status: $Enums.ProcessStatus | null
    archived: boolean | null
    staffViewForms: boolean | null
    applicantViewProcessLevel: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessCountAggregateOutputType = {
    id: number
    name: number
    type: number
    groupId: number
    creatorId: number
    status: number
    archived: number
    staffViewForms: number
    applicantViewProcessLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcessMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    groupId?: true
    creatorId?: true
    status?: true
    archived?: true
    staffViewForms?: true
    applicantViewProcessLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    groupId?: true
    creatorId?: true
    status?: true
    archived?: true
    staffViewForms?: true
    applicantViewProcessLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    groupId?: true
    creatorId?: true
    status?: true
    archived?: true
    staffViewForms?: true
    applicantViewProcessLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Process to aggregate.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Processes
    **/
    _count?: true | ProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessMaxAggregateInputType
  }

  export type GetProcessAggregateType<T extends ProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcess[P]>
      : GetScalarType<T[P], AggregateProcess[P]>
  }




  export type ProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessWhereInput
    orderBy?: ProcessOrderByWithAggregationInput | ProcessOrderByWithAggregationInput[]
    by: ProcessScalarFieldEnum[] | ProcessScalarFieldEnum
    having?: ProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessCountAggregateInputType | true
    _min?: ProcessMinAggregateInputType
    _max?: ProcessMaxAggregateInputType
  }

  export type ProcessGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ProcessType
    groupId: string
    creatorId: string
    status: $Enums.ProcessStatus
    archived: boolean
    staffViewForms: boolean
    applicantViewProcessLevel: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProcessCountAggregateOutputType | null
    _min: ProcessMinAggregateOutputType | null
    _max: ProcessMaxAggregateOutputType | null
  }

  type GetProcessGroupByPayload<T extends ProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessGroupByOutputType[P]>
        }
      >
    >


  export type ProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    groupId?: boolean
    creatorId?: boolean
    status?: boolean
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applicantProcesses?: boolean | Process$applicantProcessesArgs<ExtArgs>
    formResponses?: boolean | Process$formResponsesArgs<ExtArgs>
    forms?: boolean | Process$formsArgs<ExtArgs>
    processedApplications?: boolean | Process$processedApplicationsArgs<ExtArgs>
    roles?: boolean | Process$rolesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    _count?: boolean | ProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    groupId?: boolean
    creatorId?: boolean
    status?: boolean
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    groupId?: boolean
    creatorId?: boolean
    status?: boolean
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["process"]>

  export type ProcessSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    groupId?: boolean
    creatorId?: boolean
    status?: boolean
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "groupId" | "creatorId" | "status" | "archived" | "staffViewForms" | "applicantViewProcessLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["process"]>
  export type ProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcesses?: boolean | Process$applicantProcessesArgs<ExtArgs>
    formResponses?: boolean | Process$formResponsesArgs<ExtArgs>
    forms?: boolean | Process$formsArgs<ExtArgs>
    processedApplications?: boolean | Process$processedApplicationsArgs<ExtArgs>
    roles?: boolean | Process$rolesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    _count?: boolean | ProcessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type ProcessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $ProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Process"
    objects: {
      applicantProcesses: Prisma.$ApplicantProcessPayload<ExtArgs>[]
      formResponses: Prisma.$FormResponsePayload<ExtArgs>[]
      forms: Prisma.$ProcessFormPayload<ExtArgs>[]
      processedApplications: Prisma.$ProcessedApplicationPayload<ExtArgs>[]
      roles: Prisma.$ProcessRolePayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ProcessType
      groupId: string
      creatorId: string
      status: $Enums.ProcessStatus
      archived: boolean
      staffViewForms: boolean
      applicantViewProcessLevel: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["process"]>
    composites: {}
  }

  type ProcessGetPayload<S extends boolean | null | undefined | ProcessDefaultArgs> = $Result.GetResult<Prisma.$ProcessPayload, S>

  type ProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProcessCountAggregateInputType | true
    }

  export interface ProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Process'], meta: { name: 'Process' } }
    /**
     * Find zero or one Process that matches the filter.
     * @param {ProcessFindUniqueArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessFindUniqueArgs>(args: SelectSubset<T, ProcessFindUniqueArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Process that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessFindUniqueOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Process that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessFindFirstArgs>(args?: SelectSubset<T, ProcessFindFirstArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Process that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindFirstOrThrowArgs} args - Arguments to find a Process
     * @example
     * // Get one Process
     * const process = await prisma.process.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Processes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processes
     * const processes = await prisma.process.findMany()
     * 
     * // Get first 10 Processes
     * const processes = await prisma.process.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processWithIdOnly = await prisma.process.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessFindManyArgs>(args?: SelectSubset<T, ProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Process.
     * @param {ProcessCreateArgs} args - Arguments to create a Process.
     * @example
     * // Create one Process
     * const Process = await prisma.process.create({
     *   data: {
     *     // ... data to create a Process
     *   }
     * })
     * 
     */
    create<T extends ProcessCreateArgs>(args: SelectSubset<T, ProcessCreateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Processes.
     * @param {ProcessCreateManyArgs} args - Arguments to create many Processes.
     * @example
     * // Create many Processes
     * const process = await prisma.process.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessCreateManyArgs>(args?: SelectSubset<T, ProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Processes and returns the data saved in the database.
     * @param {ProcessCreateManyAndReturnArgs} args - Arguments to create many Processes.
     * @example
     * // Create many Processes
     * const process = await prisma.process.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Processes and only return the `id`
     * const processWithIdOnly = await prisma.process.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Process.
     * @param {ProcessDeleteArgs} args - Arguments to delete one Process.
     * @example
     * // Delete one Process
     * const Process = await prisma.process.delete({
     *   where: {
     *     // ... filter to delete one Process
     *   }
     * })
     * 
     */
    delete<T extends ProcessDeleteArgs>(args: SelectSubset<T, ProcessDeleteArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Process.
     * @param {ProcessUpdateArgs} args - Arguments to update one Process.
     * @example
     * // Update one Process
     * const process = await prisma.process.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessUpdateArgs>(args: SelectSubset<T, ProcessUpdateArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Processes.
     * @param {ProcessDeleteManyArgs} args - Arguments to filter Processes to delete.
     * @example
     * // Delete a few Processes
     * const { count } = await prisma.process.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessDeleteManyArgs>(args?: SelectSubset<T, ProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processes
     * const process = await prisma.process.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessUpdateManyArgs>(args: SelectSubset<T, ProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processes and returns the data updated in the database.
     * @param {ProcessUpdateManyAndReturnArgs} args - Arguments to update many Processes.
     * @example
     * // Update many Processes
     * const process = await prisma.process.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Processes and only return the `id`
     * const processWithIdOnly = await prisma.process.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Process.
     * @param {ProcessUpsertArgs} args - Arguments to update or create a Process.
     * @example
     * // Update or create a Process
     * const process = await prisma.process.upsert({
     *   create: {
     *     // ... data to create a Process
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Process we want to update
     *   }
     * })
     */
    upsert<T extends ProcessUpsertArgs>(args: SelectSubset<T, ProcessUpsertArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCountArgs} args - Arguments to filter Processes to count.
     * @example
     * // Count the number of Processes
     * const count = await prisma.process.count({
     *   where: {
     *     // ... the filter for the Processes we want to count
     *   }
     * })
    **/
    count<T extends ProcessCountArgs>(
      args?: Subset<T, ProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessAggregateArgs>(args: Subset<T, ProcessAggregateArgs>): Prisma.PrismaPromise<GetProcessAggregateType<T>>

    /**
     * Group by Process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessGroupByArgs['orderBy'] }
        : { orderBy?: ProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Process model
   */
  readonly fields: ProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Process.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicantProcesses<T extends Process$applicantProcessesArgs<ExtArgs> = {}>(args?: Subset<T, Process$applicantProcessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    formResponses<T extends Process$formResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Process$formResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forms<T extends Process$formsArgs<ExtArgs> = {}>(args?: Subset<T, Process$formsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processedApplications<T extends Process$processedApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, Process$processedApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends Process$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Process$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Process model
   */
  interface ProcessFieldRefs {
    readonly id: FieldRef<"Process", 'String'>
    readonly name: FieldRef<"Process", 'String'>
    readonly type: FieldRef<"Process", 'ProcessType'>
    readonly groupId: FieldRef<"Process", 'String'>
    readonly creatorId: FieldRef<"Process", 'String'>
    readonly status: FieldRef<"Process", 'ProcessStatus'>
    readonly archived: FieldRef<"Process", 'Boolean'>
    readonly staffViewForms: FieldRef<"Process", 'Boolean'>
    readonly applicantViewProcessLevel: FieldRef<"Process", 'Boolean'>
    readonly createdAt: FieldRef<"Process", 'DateTime'>
    readonly updatedAt: FieldRef<"Process", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Process findUnique
   */
  export type ProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process findUniqueOrThrow
   */
  export type ProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where: ProcessWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process findFirst
   */
  export type ProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process findFirstOrThrow
   */
  export type ProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Process to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Processes.
     */
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process findMany
   */
  export type ProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter, which Processes to fetch.
     */
    where?: ProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Processes to fetch.
     */
    orderBy?: ProcessOrderByWithRelationInput | ProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Processes.
     */
    cursor?: ProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Processes.
     */
    skip?: number
    distinct?: ProcessScalarFieldEnum | ProcessScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process create
   */
  export type ProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a Process.
     */
    data: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process createMany
   */
  export type ProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Process createManyAndReturn
   */
  export type ProcessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * The data used to create many Processes.
     */
    data: ProcessCreateManyInput | ProcessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Process update
   */
  export type ProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a Process.
     */
    data: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
    /**
     * Choose, which Process to update.
     */
    where: ProcessWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process updateMany
   */
  export type ProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Processes.
     */
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyInput>
    /**
     * Filter which Processes to update
     */
    where?: ProcessWhereInput
    /**
     * Limit how many Processes to update.
     */
    limit?: number
  }

  /**
   * Process updateManyAndReturn
   */
  export type ProcessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * The data used to update Processes.
     */
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyInput>
    /**
     * Filter which Processes to update
     */
    where?: ProcessWhereInput
    /**
     * Limit how many Processes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Process upsert
   */
  export type ProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the Process to update in case it exists.
     */
    where: ProcessWhereUniqueInput
    /**
     * In case the Process found by the `where` argument doesn't exist, create a new Process with this data.
     */
    create: XOR<ProcessCreateInput, ProcessUncheckedCreateInput>
    /**
     * In case the Process was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessUpdateInput, ProcessUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process delete
   */
  export type ProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
    /**
     * Filter which Process to delete.
     */
    where: ProcessWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Process deleteMany
   */
  export type ProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Processes to delete
     */
    where?: ProcessWhereInput
    /**
     * Limit how many Processes to delete.
     */
    limit?: number
  }

  /**
   * Process.applicantProcesses
   */
  export type Process$applicantProcessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    where?: ApplicantProcessWhereInput
    orderBy?: ApplicantProcessOrderByWithRelationInput | ApplicantProcessOrderByWithRelationInput[]
    cursor?: ApplicantProcessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicantProcessScalarFieldEnum | ApplicantProcessScalarFieldEnum[]
  }

  /**
   * Process.formResponses
   */
  export type Process$formResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    cursor?: FormResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }

  /**
   * Process.forms
   */
  export type Process$formsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    where?: ProcessFormWhereInput
    orderBy?: ProcessFormOrderByWithRelationInput | ProcessFormOrderByWithRelationInput[]
    cursor?: ProcessFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessFormScalarFieldEnum | ProcessFormScalarFieldEnum[]
  }

  /**
   * Process.processedApplications
   */
  export type Process$processedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    where?: ProcessedApplicationWhereInput
    orderBy?: ProcessedApplicationOrderByWithRelationInput | ProcessedApplicationOrderByWithRelationInput[]
    cursor?: ProcessedApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessedApplicationScalarFieldEnum | ProcessedApplicationScalarFieldEnum[]
  }

  /**
   * Process.roles
   */
  export type Process$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    where?: ProcessRoleWhereInput
    orderBy?: ProcessRoleOrderByWithRelationInput | ProcessRoleOrderByWithRelationInput[]
    cursor?: ProcessRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessRoleScalarFieldEnum | ProcessRoleScalarFieldEnum[]
  }

  /**
   * Process without action
   */
  export type ProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Process
     */
    select?: ProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Process
     */
    omit?: ProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessInclude<ExtArgs> | null
  }


  /**
   * Model ProcessRole
   */

  export type AggregateProcessRole = {
    _count: ProcessRoleCountAggregateOutputType | null
    _min: ProcessRoleMinAggregateOutputType | null
    _max: ProcessRoleMaxAggregateOutputType | null
  }

  export type ProcessRoleMinAggregateOutputType = {
    processId: string | null
    roleId: string | null
    status: $Enums.RoleStatus | null
  }

  export type ProcessRoleMaxAggregateOutputType = {
    processId: string | null
    roleId: string | null
    status: $Enums.RoleStatus | null
  }

  export type ProcessRoleCountAggregateOutputType = {
    processId: number
    roleId: number
    status: number
    _all: number
  }


  export type ProcessRoleMinAggregateInputType = {
    processId?: true
    roleId?: true
    status?: true
  }

  export type ProcessRoleMaxAggregateInputType = {
    processId?: true
    roleId?: true
    status?: true
  }

  export type ProcessRoleCountAggregateInputType = {
    processId?: true
    roleId?: true
    status?: true
    _all?: true
  }

  export type ProcessRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessRole to aggregate.
     */
    where?: ProcessRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessRoles to fetch.
     */
    orderBy?: ProcessRoleOrderByWithRelationInput | ProcessRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessRoles
    **/
    _count?: true | ProcessRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessRoleMaxAggregateInputType
  }

  export type GetProcessRoleAggregateType<T extends ProcessRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessRole[P]>
      : GetScalarType<T[P], AggregateProcessRole[P]>
  }




  export type ProcessRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessRoleWhereInput
    orderBy?: ProcessRoleOrderByWithAggregationInput | ProcessRoleOrderByWithAggregationInput[]
    by: ProcessRoleScalarFieldEnum[] | ProcessRoleScalarFieldEnum
    having?: ProcessRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessRoleCountAggregateInputType | true
    _min?: ProcessRoleMinAggregateInputType
    _max?: ProcessRoleMaxAggregateInputType
  }

  export type ProcessRoleGroupByOutputType = {
    processId: string
    roleId: string
    status: $Enums.RoleStatus
    _count: ProcessRoleCountAggregateOutputType | null
    _min: ProcessRoleMinAggregateOutputType | null
    _max: ProcessRoleMaxAggregateOutputType | null
  }

  type GetProcessRoleGroupByPayload<T extends ProcessRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessRoleGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessRoleGroupByOutputType[P]>
        }
      >
    >


  export type ProcessRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    processId?: boolean
    roleId?: boolean
    status?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processRole"]>

  export type ProcessRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    processId?: boolean
    roleId?: boolean
    status?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processRole"]>

  export type ProcessRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    processId?: boolean
    roleId?: boolean
    status?: boolean
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processRole"]>

  export type ProcessRoleSelectScalar = {
    processId?: boolean
    roleId?: boolean
    status?: boolean
  }

  export type ProcessRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"processId" | "roleId" | "status", ExtArgs["result"]["processRole"]>
  export type ProcessRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type ProcessRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type ProcessRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $ProcessRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessRole"
    objects: {
      process: Prisma.$ProcessPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      processId: string
      roleId: string
      status: $Enums.RoleStatus
    }, ExtArgs["result"]["processRole"]>
    composites: {}
  }

  type ProcessRoleGetPayload<S extends boolean | null | undefined | ProcessRoleDefaultArgs> = $Result.GetResult<Prisma.$ProcessRolePayload, S>

  type ProcessRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProcessRoleCountAggregateInputType | true
    }

  export interface ProcessRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessRole'], meta: { name: 'ProcessRole' } }
    /**
     * Find zero or one ProcessRole that matches the filter.
     * @param {ProcessRoleFindUniqueArgs} args - Arguments to find a ProcessRole
     * @example
     * // Get one ProcessRole
     * const processRole = await prisma.processRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessRoleFindUniqueArgs>(args: SelectSubset<T, ProcessRoleFindUniqueArgs<ExtArgs>>): Prisma__ProcessRoleClient<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessRoleFindUniqueOrThrowArgs} args - Arguments to find a ProcessRole
     * @example
     * // Get one ProcessRole
     * const processRole = await prisma.processRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessRoleClient<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessRoleFindFirstArgs} args - Arguments to find a ProcessRole
     * @example
     * // Get one ProcessRole
     * const processRole = await prisma.processRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessRoleFindFirstArgs>(args?: SelectSubset<T, ProcessRoleFindFirstArgs<ExtArgs>>): Prisma__ProcessRoleClient<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessRoleFindFirstOrThrowArgs} args - Arguments to find a ProcessRole
     * @example
     * // Get one ProcessRole
     * const processRole = await prisma.processRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessRoleClient<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessRoles
     * const processRoles = await prisma.processRole.findMany()
     * 
     * // Get first 10 ProcessRoles
     * const processRoles = await prisma.processRole.findMany({ take: 10 })
     * 
     * // Only select the `processId`
     * const processRoleWithProcessIdOnly = await prisma.processRole.findMany({ select: { processId: true } })
     * 
     */
    findMany<T extends ProcessRoleFindManyArgs>(args?: SelectSubset<T, ProcessRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessRole.
     * @param {ProcessRoleCreateArgs} args - Arguments to create a ProcessRole.
     * @example
     * // Create one ProcessRole
     * const ProcessRole = await prisma.processRole.create({
     *   data: {
     *     // ... data to create a ProcessRole
     *   }
     * })
     * 
     */
    create<T extends ProcessRoleCreateArgs>(args: SelectSubset<T, ProcessRoleCreateArgs<ExtArgs>>): Prisma__ProcessRoleClient<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessRoles.
     * @param {ProcessRoleCreateManyArgs} args - Arguments to create many ProcessRoles.
     * @example
     * // Create many ProcessRoles
     * const processRole = await prisma.processRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessRoleCreateManyArgs>(args?: SelectSubset<T, ProcessRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessRoles and returns the data saved in the database.
     * @param {ProcessRoleCreateManyAndReturnArgs} args - Arguments to create many ProcessRoles.
     * @example
     * // Create many ProcessRoles
     * const processRole = await prisma.processRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessRoles and only return the `processId`
     * const processRoleWithProcessIdOnly = await prisma.processRole.createManyAndReturn({
     *   select: { processId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcessRole.
     * @param {ProcessRoleDeleteArgs} args - Arguments to delete one ProcessRole.
     * @example
     * // Delete one ProcessRole
     * const ProcessRole = await prisma.processRole.delete({
     *   where: {
     *     // ... filter to delete one ProcessRole
     *   }
     * })
     * 
     */
    delete<T extends ProcessRoleDeleteArgs>(args: SelectSubset<T, ProcessRoleDeleteArgs<ExtArgs>>): Prisma__ProcessRoleClient<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessRole.
     * @param {ProcessRoleUpdateArgs} args - Arguments to update one ProcessRole.
     * @example
     * // Update one ProcessRole
     * const processRole = await prisma.processRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessRoleUpdateArgs>(args: SelectSubset<T, ProcessRoleUpdateArgs<ExtArgs>>): Prisma__ProcessRoleClient<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessRoles.
     * @param {ProcessRoleDeleteManyArgs} args - Arguments to filter ProcessRoles to delete.
     * @example
     * // Delete a few ProcessRoles
     * const { count } = await prisma.processRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessRoleDeleteManyArgs>(args?: SelectSubset<T, ProcessRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessRoles
     * const processRole = await prisma.processRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessRoleUpdateManyArgs>(args: SelectSubset<T, ProcessRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessRoles and returns the data updated in the database.
     * @param {ProcessRoleUpdateManyAndReturnArgs} args - Arguments to update many ProcessRoles.
     * @example
     * // Update many ProcessRoles
     * const processRole = await prisma.processRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcessRoles and only return the `processId`
     * const processRoleWithProcessIdOnly = await prisma.processRole.updateManyAndReturn({
     *   select: { processId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcessRole.
     * @param {ProcessRoleUpsertArgs} args - Arguments to update or create a ProcessRole.
     * @example
     * // Update or create a ProcessRole
     * const processRole = await prisma.processRole.upsert({
     *   create: {
     *     // ... data to create a ProcessRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessRole we want to update
     *   }
     * })
     */
    upsert<T extends ProcessRoleUpsertArgs>(args: SelectSubset<T, ProcessRoleUpsertArgs<ExtArgs>>): Prisma__ProcessRoleClient<$Result.GetResult<Prisma.$ProcessRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcessRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessRoleCountArgs} args - Arguments to filter ProcessRoles to count.
     * @example
     * // Count the number of ProcessRoles
     * const count = await prisma.processRole.count({
     *   where: {
     *     // ... the filter for the ProcessRoles we want to count
     *   }
     * })
    **/
    count<T extends ProcessRoleCountArgs>(
      args?: Subset<T, ProcessRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessRoleAggregateArgs>(args: Subset<T, ProcessRoleAggregateArgs>): Prisma.PrismaPromise<GetProcessRoleAggregateType<T>>

    /**
     * Group by ProcessRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessRoleGroupByArgs['orderBy'] }
        : { orderBy?: ProcessRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessRole model
   */
  readonly fields: ProcessRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessRole model
   */
  interface ProcessRoleFieldRefs {
    readonly processId: FieldRef<"ProcessRole", 'String'>
    readonly roleId: FieldRef<"ProcessRole", 'String'>
    readonly status: FieldRef<"ProcessRole", 'RoleStatus'>
  }
    

  // Custom InputTypes
  /**
   * ProcessRole findUnique
   */
  export type ProcessRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProcessRole to fetch.
     */
    where: ProcessRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole findUniqueOrThrow
   */
  export type ProcessRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProcessRole to fetch.
     */
    where: ProcessRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole findFirst
   */
  export type ProcessRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProcessRole to fetch.
     */
    where?: ProcessRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessRoles to fetch.
     */
    orderBy?: ProcessRoleOrderByWithRelationInput | ProcessRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessRoles.
     */
    cursor?: ProcessRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessRoles.
     */
    distinct?: ProcessRoleScalarFieldEnum | ProcessRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole findFirstOrThrow
   */
  export type ProcessRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProcessRole to fetch.
     */
    where?: ProcessRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessRoles to fetch.
     */
    orderBy?: ProcessRoleOrderByWithRelationInput | ProcessRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessRoles.
     */
    cursor?: ProcessRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessRoles.
     */
    distinct?: ProcessRoleScalarFieldEnum | ProcessRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole findMany
   */
  export type ProcessRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProcessRoles to fetch.
     */
    where?: ProcessRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessRoles to fetch.
     */
    orderBy?: ProcessRoleOrderByWithRelationInput | ProcessRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessRoles.
     */
    cursor?: ProcessRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessRoles.
     */
    skip?: number
    distinct?: ProcessRoleScalarFieldEnum | ProcessRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole create
   */
  export type ProcessRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessRole.
     */
    data: XOR<ProcessRoleCreateInput, ProcessRoleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole createMany
   */
  export type ProcessRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessRoles.
     */
    data: ProcessRoleCreateManyInput | ProcessRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessRole createManyAndReturn
   */
  export type ProcessRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * The data used to create many ProcessRoles.
     */
    data: ProcessRoleCreateManyInput | ProcessRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessRole update
   */
  export type ProcessRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessRole.
     */
    data: XOR<ProcessRoleUpdateInput, ProcessRoleUncheckedUpdateInput>
    /**
     * Choose, which ProcessRole to update.
     */
    where: ProcessRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole updateMany
   */
  export type ProcessRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessRoles.
     */
    data: XOR<ProcessRoleUpdateManyMutationInput, ProcessRoleUncheckedUpdateManyInput>
    /**
     * Filter which ProcessRoles to update
     */
    where?: ProcessRoleWhereInput
    /**
     * Limit how many ProcessRoles to update.
     */
    limit?: number
  }

  /**
   * ProcessRole updateManyAndReturn
   */
  export type ProcessRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * The data used to update ProcessRoles.
     */
    data: XOR<ProcessRoleUpdateManyMutationInput, ProcessRoleUncheckedUpdateManyInput>
    /**
     * Filter which ProcessRoles to update
     */
    where?: ProcessRoleWhereInput
    /**
     * Limit how many ProcessRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessRole upsert
   */
  export type ProcessRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessRole to update in case it exists.
     */
    where: ProcessRoleWhereUniqueInput
    /**
     * In case the ProcessRole found by the `where` argument doesn't exist, create a new ProcessRole with this data.
     */
    create: XOR<ProcessRoleCreateInput, ProcessRoleUncheckedCreateInput>
    /**
     * In case the ProcessRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessRoleUpdateInput, ProcessRoleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole delete
   */
  export type ProcessRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
    /**
     * Filter which ProcessRole to delete.
     */
    where: ProcessRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessRole deleteMany
   */
  export type ProcessRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessRoles to delete
     */
    where?: ProcessRoleWhereInput
    /**
     * Limit how many ProcessRoles to delete.
     */
    limit?: number
  }

  /**
   * ProcessRole without action
   */
  export type ProcessRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessRole
     */
    select?: ProcessRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessRole
     */
    omit?: ProcessRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessRoleInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    name: number
    description: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FolderMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    name: string
    description: string | null
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    forms?: boolean | Folder$formsArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["folder"]>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    forms?: boolean | Folder$formsArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      forms: Prisma.$FormPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    forms<T extends Folder$formsArgs<ExtArgs> = {}>(args?: Subset<T, Folder$formsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly description: FieldRef<"Folder", 'String'>
    readonly creatorId: FieldRef<"Folder", 'String'>
    readonly createdAt: FieldRef<"Folder", 'DateTime'>
    readonly updatedAt: FieldRef<"Folder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to delete.
     */
    limit?: number
  }

  /**
   * Folder.forms
   */
  export type Folder$formsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    where?: FormWhereInput
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    cursor?: FormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model Form
   */

  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.FormType | null
    status: $Enums.FormStatus | null
    archived: boolean | null
    creatorId: string | null
    folderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.FormType | null
    status: $Enums.FormStatus | null
    archived: boolean | null
    creatorId: string | null
    folderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    archived: number
    creatorId: number
    folderId: number
    createdAt: number
    updatedAt: number
    design: number
    _all: number
  }


  export type FormMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    archived?: true
    creatorId?: true
    folderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    archived?: true
    creatorId?: true
    folderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    archived?: true
    creatorId?: true
    folderId?: true
    createdAt?: true
    updatedAt?: true
    design?: true
    _all?: true
  }

  export type FormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form to aggregate.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormWhereInput
    orderBy?: FormOrderByWithAggregationInput | FormOrderByWithAggregationInput[]
    by: FormScalarFieldEnum[] | FormScalarFieldEnum
    having?: FormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }

  export type FormGroupByOutputType = {
    id: string
    name: string
    type: $Enums.FormType
    status: $Enums.FormStatus
    archived: boolean
    creatorId: string
    folderId: string | null
    createdAt: Date
    updatedAt: Date
    design: JsonValue | null
    _count: FormCountAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type FormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    archived?: boolean
    creatorId?: boolean
    folderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    design?: boolean
    responses?: boolean | Form$responsesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Form$folderArgs<ExtArgs>
    processForms?: boolean | Form$processFormsArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    archived?: boolean
    creatorId?: boolean
    folderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    design?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Form$folderArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    archived?: boolean
    creatorId?: boolean
    folderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    design?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Form$folderArgs<ExtArgs>
  }, ExtArgs["result"]["form"]>

  export type FormSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    archived?: boolean
    creatorId?: boolean
    folderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    design?: boolean
  }

  export type FormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "archived" | "creatorId" | "folderId" | "createdAt" | "updatedAt" | "design", ExtArgs["result"]["form"]>
  export type FormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | Form$responsesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Form$folderArgs<ExtArgs>
    processForms?: boolean | Form$processFormsArgs<ExtArgs>
    _count?: boolean | FormCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Form$folderArgs<ExtArgs>
  }
  export type FormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Form$folderArgs<ExtArgs>
  }

  export type $FormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Form"
    objects: {
      responses: Prisma.$FormResponsePayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      folder: Prisma.$FolderPayload<ExtArgs> | null
      processForms: Prisma.$ProcessFormPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.FormType
      status: $Enums.FormStatus
      archived: boolean
      creatorId: string
      folderId: string | null
      createdAt: Date
      updatedAt: Date
      design: Prisma.JsonValue | null
    }, ExtArgs["result"]["form"]>
    composites: {}
  }

  type FormGetPayload<S extends boolean | null | undefined | FormDefaultArgs> = $Result.GetResult<Prisma.$FormPayload, S>

  type FormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: FormCountAggregateInputType | true
    }

  export interface FormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Form'], meta: { name: 'Form' } }
    /**
     * Find zero or one Form that matches the filter.
     * @param {FormFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFindUniqueArgs>(args: SelectSubset<T, FormFindUniqueArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Form that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFindFirstArgs>(args?: SelectSubset<T, FormFindFirstArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFindManyArgs>(args?: SelectSubset<T, FormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Form.
     * @param {FormCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
     */
    create<T extends FormCreateArgs>(args: SelectSubset<T, FormCreateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Forms.
     * @param {FormCreateManyArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormCreateManyArgs>(args?: SelectSubset<T, FormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Forms and returns the data saved in the database.
     * @param {FormCreateManyAndReturnArgs} args - Arguments to create many Forms.
     * @example
     * // Create many Forms
     * const form = await prisma.form.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Forms and only return the `id`
     * const formWithIdOnly = await prisma.form.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormCreateManyAndReturnArgs>(args?: SelectSubset<T, FormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Form.
     * @param {FormDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
     */
    delete<T extends FormDeleteArgs>(args: SelectSubset<T, FormDeleteArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Form.
     * @param {FormUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormUpdateArgs>(args: SelectSubset<T, FormUpdateArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Forms.
     * @param {FormDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormDeleteManyArgs>(args?: SelectSubset<T, FormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormUpdateManyArgs>(args: SelectSubset<T, FormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms and returns the data updated in the database.
     * @param {FormUpdateManyAndReturnArgs} args - Arguments to update many Forms.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Forms and only return the `id`
     * const formWithIdOnly = await prisma.form.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormUpdateManyAndReturnArgs>(args: SelectSubset<T, FormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Form.
     * @param {FormUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
     */
    upsert<T extends FormUpsertArgs>(args: SelectSubset<T, FormUpsertArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends FormCountArgs>(
      args?: Subset<T, FormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): Prisma.PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Form model
   */
  readonly fields: FormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responses<T extends Form$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Form$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    folder<T extends Form$folderArgs<ExtArgs> = {}>(args?: Subset<T, Form$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processForms<T extends Form$processFormsArgs<ExtArgs> = {}>(args?: Subset<T, Form$processFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Form model
   */
  interface FormFieldRefs {
    readonly id: FieldRef<"Form", 'String'>
    readonly name: FieldRef<"Form", 'String'>
    readonly type: FieldRef<"Form", 'FormType'>
    readonly status: FieldRef<"Form", 'FormStatus'>
    readonly archived: FieldRef<"Form", 'Boolean'>
    readonly creatorId: FieldRef<"Form", 'String'>
    readonly folderId: FieldRef<"Form", 'String'>
    readonly createdAt: FieldRef<"Form", 'DateTime'>
    readonly updatedAt: FieldRef<"Form", 'DateTime'>
    readonly design: FieldRef<"Form", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Form findUnique
   */
  export type FormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form findUniqueOrThrow
   */
  export type FormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where: FormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form findFirst
   */
  export type FormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form findFirstOrThrow
   */
  export type FormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Form to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forms.
     */
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form findMany
   */
  export type FormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter, which Forms to fetch.
     */
    where?: FormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forms to fetch.
     */
    orderBy?: FormOrderByWithRelationInput | FormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forms.
     */
    cursor?: FormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forms.
     */
    skip?: number
    distinct?: FormScalarFieldEnum | FormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form create
   */
  export type FormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to create a Form.
     */
    data: XOR<FormCreateInput, FormUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form createMany
   */
  export type FormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Form createManyAndReturn
   */
  export type FormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * The data used to create many Forms.
     */
    data: FormCreateManyInput | FormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Form update
   */
  export type FormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The data needed to update a Form.
     */
    data: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    /**
     * Choose, which Form to update.
     */
    where: FormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form updateMany
   */
  export type FormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to update.
     */
    limit?: number
  }

  /**
   * Form updateManyAndReturn
   */
  export type FormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * The data used to update Forms.
     */
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyInput>
    /**
     * Filter which Forms to update
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Form upsert
   */
  export type FormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * The filter to search for the Form to update in case it exists.
     */
    where: FormWhereUniqueInput
    /**
     * In case the Form found by the `where` argument doesn't exist, create a new Form with this data.
     */
    create: XOR<FormCreateInput, FormUncheckedCreateInput>
    /**
     * In case the Form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormUpdateInput, FormUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form delete
   */
  export type FormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
    /**
     * Filter which Form to delete.
     */
    where: FormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Form deleteMany
   */
  export type FormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forms to delete
     */
    where?: FormWhereInput
    /**
     * Limit how many Forms to delete.
     */
    limit?: number
  }

  /**
   * Form.responses
   */
  export type Form$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    cursor?: FormResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }

  /**
   * Form.folder
   */
  export type Form$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Form.processForms
   */
  export type Form$processFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    where?: ProcessFormWhereInput
    orderBy?: ProcessFormOrderByWithRelationInput | ProcessFormOrderByWithRelationInput[]
    cursor?: ProcessFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessFormScalarFieldEnum | ProcessFormScalarFieldEnum[]
  }

  /**
   * Form without action
   */
  export type FormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form
     */
    select?: FormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form
     */
    omit?: FormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormInclude<ExtArgs> | null
  }


  /**
   * Model FormResponse
   */

  export type AggregateFormResponse = {
    _count: FormResponseCountAggregateOutputType | null
    _min: FormResponseMinAggregateOutputType | null
    _max: FormResponseMaxAggregateOutputType | null
  }

  export type FormResponseMinAggregateOutputType = {
    id: string | null
    formId: string | null
    applicantProcessId: string | null
    createdAt: Date | null
    processId: string | null
  }

  export type FormResponseMaxAggregateOutputType = {
    id: string | null
    formId: string | null
    applicantProcessId: string | null
    createdAt: Date | null
    processId: string | null
  }

  export type FormResponseCountAggregateOutputType = {
    id: number
    formId: number
    applicantProcessId: number
    responses: number
    createdAt: number
    processId: number
    _all: number
  }


  export type FormResponseMinAggregateInputType = {
    id?: true
    formId?: true
    applicantProcessId?: true
    createdAt?: true
    processId?: true
  }

  export type FormResponseMaxAggregateInputType = {
    id?: true
    formId?: true
    applicantProcessId?: true
    createdAt?: true
    processId?: true
  }

  export type FormResponseCountAggregateInputType = {
    id?: true
    formId?: true
    applicantProcessId?: true
    responses?: true
    createdAt?: true
    processId?: true
    _all?: true
  }

  export type FormResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormResponse to aggregate.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormResponses
    **/
    _count?: true | FormResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormResponseMaxAggregateInputType
  }

  export type GetFormResponseAggregateType<T extends FormResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateFormResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormResponse[P]>
      : GetScalarType<T[P], AggregateFormResponse[P]>
  }




  export type FormResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithAggregationInput | FormResponseOrderByWithAggregationInput[]
    by: FormResponseScalarFieldEnum[] | FormResponseScalarFieldEnum
    having?: FormResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormResponseCountAggregateInputType | true
    _min?: FormResponseMinAggregateInputType
    _max?: FormResponseMaxAggregateInputType
  }

  export type FormResponseGroupByOutputType = {
    id: string
    formId: string
    applicantProcessId: string
    responses: JsonValue
    createdAt: Date
    processId: string
    _count: FormResponseCountAggregateOutputType | null
    _min: FormResponseMinAggregateOutputType | null
    _max: FormResponseMaxAggregateOutputType | null
  }

  type GetFormResponseGroupByPayload<T extends FormResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormResponseGroupByOutputType[P]>
            : GetScalarType<T[P], FormResponseGroupByOutputType[P]>
        }
      >
    >


  export type FormResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    applicantProcessId?: boolean
    responses?: boolean
    createdAt?: boolean
    processId?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formResponse"]>

  export type FormResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    applicantProcessId?: boolean
    responses?: boolean
    createdAt?: boolean
    processId?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formResponse"]>

  export type FormResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formId?: boolean
    applicantProcessId?: boolean
    responses?: boolean
    createdAt?: boolean
    processId?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formResponse"]>

  export type FormResponseSelectScalar = {
    id?: boolean
    formId?: boolean
    applicantProcessId?: boolean
    responses?: boolean
    createdAt?: boolean
    processId?: boolean
  }

  export type FormResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "formId" | "applicantProcessId" | "responses" | "createdAt" | "processId", ExtArgs["result"]["formResponse"]>
  export type FormResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }
  export type FormResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }
  export type FormResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }

  export type $FormResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormResponse"
    objects: {
      applicantProcess: Prisma.$ApplicantProcessPayload<ExtArgs>
      form: Prisma.$FormPayload<ExtArgs>
      process: Prisma.$ProcessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formId: string
      applicantProcessId: string
      responses: Prisma.JsonValue
      createdAt: Date
      processId: string
    }, ExtArgs["result"]["formResponse"]>
    composites: {}
  }

  type FormResponseGetPayload<S extends boolean | null | undefined | FormResponseDefaultArgs> = $Result.GetResult<Prisma.$FormResponsePayload, S>

  type FormResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: FormResponseCountAggregateInputType | true
    }

  export interface FormResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormResponse'], meta: { name: 'FormResponse' } }
    /**
     * Find zero or one FormResponse that matches the filter.
     * @param {FormResponseFindUniqueArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormResponseFindUniqueArgs>(args: SelectSubset<T, FormResponseFindUniqueArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormResponseFindUniqueOrThrowArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, FormResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindFirstArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormResponseFindFirstArgs>(args?: SelectSubset<T, FormResponseFindFirstArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindFirstOrThrowArgs} args - Arguments to find a FormResponse
     * @example
     * // Get one FormResponse
     * const formResponse = await prisma.formResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, FormResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormResponses
     * const formResponses = await prisma.formResponse.findMany()
     * 
     * // Get first 10 FormResponses
     * const formResponses = await prisma.formResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formResponseWithIdOnly = await prisma.formResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormResponseFindManyArgs>(args?: SelectSubset<T, FormResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormResponse.
     * @param {FormResponseCreateArgs} args - Arguments to create a FormResponse.
     * @example
     * // Create one FormResponse
     * const FormResponse = await prisma.formResponse.create({
     *   data: {
     *     // ... data to create a FormResponse
     *   }
     * })
     * 
     */
    create<T extends FormResponseCreateArgs>(args: SelectSubset<T, FormResponseCreateArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormResponses.
     * @param {FormResponseCreateManyArgs} args - Arguments to create many FormResponses.
     * @example
     * // Create many FormResponses
     * const formResponse = await prisma.formResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormResponseCreateManyArgs>(args?: SelectSubset<T, FormResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormResponses and returns the data saved in the database.
     * @param {FormResponseCreateManyAndReturnArgs} args - Arguments to create many FormResponses.
     * @example
     * // Create many FormResponses
     * const formResponse = await prisma.formResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormResponses and only return the `id`
     * const formResponseWithIdOnly = await prisma.formResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, FormResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormResponse.
     * @param {FormResponseDeleteArgs} args - Arguments to delete one FormResponse.
     * @example
     * // Delete one FormResponse
     * const FormResponse = await prisma.formResponse.delete({
     *   where: {
     *     // ... filter to delete one FormResponse
     *   }
     * })
     * 
     */
    delete<T extends FormResponseDeleteArgs>(args: SelectSubset<T, FormResponseDeleteArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormResponse.
     * @param {FormResponseUpdateArgs} args - Arguments to update one FormResponse.
     * @example
     * // Update one FormResponse
     * const formResponse = await prisma.formResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormResponseUpdateArgs>(args: SelectSubset<T, FormResponseUpdateArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormResponses.
     * @param {FormResponseDeleteManyArgs} args - Arguments to filter FormResponses to delete.
     * @example
     * // Delete a few FormResponses
     * const { count } = await prisma.formResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormResponseDeleteManyArgs>(args?: SelectSubset<T, FormResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormResponses
     * const formResponse = await prisma.formResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormResponseUpdateManyArgs>(args: SelectSubset<T, FormResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormResponses and returns the data updated in the database.
     * @param {FormResponseUpdateManyAndReturnArgs} args - Arguments to update many FormResponses.
     * @example
     * // Update many FormResponses
     * const formResponse = await prisma.formResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormResponses and only return the `id`
     * const formResponseWithIdOnly = await prisma.formResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, FormResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormResponse.
     * @param {FormResponseUpsertArgs} args - Arguments to update or create a FormResponse.
     * @example
     * // Update or create a FormResponse
     * const formResponse = await prisma.formResponse.upsert({
     *   create: {
     *     // ... data to create a FormResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormResponse we want to update
     *   }
     * })
     */
    upsert<T extends FormResponseUpsertArgs>(args: SelectSubset<T, FormResponseUpsertArgs<ExtArgs>>): Prisma__FormResponseClient<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseCountArgs} args - Arguments to filter FormResponses to count.
     * @example
     * // Count the number of FormResponses
     * const count = await prisma.formResponse.count({
     *   where: {
     *     // ... the filter for the FormResponses we want to count
     *   }
     * })
    **/
    count<T extends FormResponseCountArgs>(
      args?: Subset<T, FormResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormResponseAggregateArgs>(args: Subset<T, FormResponseAggregateArgs>): Prisma.PrismaPromise<GetFormResponseAggregateType<T>>

    /**
     * Group by FormResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormResponseGroupByArgs['orderBy'] }
        : { orderBy?: FormResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormResponse model
   */
  readonly fields: FormResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicantProcess<T extends ApplicantProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantProcessDefaultArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormResponse model
   */
  interface FormResponseFieldRefs {
    readonly id: FieldRef<"FormResponse", 'String'>
    readonly formId: FieldRef<"FormResponse", 'String'>
    readonly applicantProcessId: FieldRef<"FormResponse", 'String'>
    readonly responses: FieldRef<"FormResponse", 'Json'>
    readonly createdAt: FieldRef<"FormResponse", 'DateTime'>
    readonly processId: FieldRef<"FormResponse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FormResponse findUnique
   */
  export type FormResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where: FormResponseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse findUniqueOrThrow
   */
  export type FormResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where: FormResponseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse findFirst
   */
  export type FormResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormResponses.
     */
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse findFirstOrThrow
   */
  export type FormResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponse to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormResponses.
     */
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse findMany
   */
  export type FormResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter, which FormResponses to fetch.
     */
    where?: FormResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormResponses to fetch.
     */
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormResponses.
     */
    cursor?: FormResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormResponses.
     */
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse create
   */
  export type FormResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a FormResponse.
     */
    data: XOR<FormResponseCreateInput, FormResponseUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse createMany
   */
  export type FormResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormResponses.
     */
    data: FormResponseCreateManyInput | FormResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormResponse createManyAndReturn
   */
  export type FormResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * The data used to create many FormResponses.
     */
    data: FormResponseCreateManyInput | FormResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormResponse update
   */
  export type FormResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a FormResponse.
     */
    data: XOR<FormResponseUpdateInput, FormResponseUncheckedUpdateInput>
    /**
     * Choose, which FormResponse to update.
     */
    where: FormResponseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse updateMany
   */
  export type FormResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormResponses.
     */
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyInput>
    /**
     * Filter which FormResponses to update
     */
    where?: FormResponseWhereInput
    /**
     * Limit how many FormResponses to update.
     */
    limit?: number
  }

  /**
   * FormResponse updateManyAndReturn
   */
  export type FormResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * The data used to update FormResponses.
     */
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyInput>
    /**
     * Filter which FormResponses to update
     */
    where?: FormResponseWhereInput
    /**
     * Limit how many FormResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormResponse upsert
   */
  export type FormResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the FormResponse to update in case it exists.
     */
    where: FormResponseWhereUniqueInput
    /**
     * In case the FormResponse found by the `where` argument doesn't exist, create a new FormResponse with this data.
     */
    create: XOR<FormResponseCreateInput, FormResponseUncheckedCreateInput>
    /**
     * In case the FormResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormResponseUpdateInput, FormResponseUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse delete
   */
  export type FormResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    /**
     * Filter which FormResponse to delete.
     */
    where: FormResponseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * FormResponse deleteMany
   */
  export type FormResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormResponses to delete
     */
    where?: FormResponseWhereInput
    /**
     * Limit how many FormResponses to delete.
     */
    limit?: number
  }

  /**
   * FormResponse without action
   */
  export type FormResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
  }


  /**
   * Model ProcessForm
   */

  export type AggregateProcessForm = {
    _count: ProcessFormCountAggregateOutputType | null
    _avg: ProcessFormAvgAggregateOutputType | null
    _sum: ProcessFormSumAggregateOutputType | null
    _min: ProcessFormMinAggregateOutputType | null
    _max: ProcessFormMaxAggregateOutputType | null
  }

  export type ProcessFormAvgAggregateOutputType = {
    order: number | null
  }

  export type ProcessFormSumAggregateOutputType = {
    order: number | null
  }

  export type ProcessFormMinAggregateOutputType = {
    id: string | null
    processId: string | null
    formId: string | null
    order: number | null
    nextStepType: $Enums.NextStepType | null
    nextStaffId: string | null
    nextStepSpecifiedTo: string | null
    notificationType: $Enums.NextStepType | null
    notificationToId: string | null
    notificationComment: string | null
    notifyApplicant: boolean | null
    applicantNotificationContent: string | null
    editApplicationStatus: boolean | null
    applicantViewFormAfterCompletion: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessFormMaxAggregateOutputType = {
    id: string | null
    processId: string | null
    formId: string | null
    order: number | null
    nextStepType: $Enums.NextStepType | null
    nextStaffId: string | null
    nextStepSpecifiedTo: string | null
    notificationType: $Enums.NextStepType | null
    notificationToId: string | null
    notificationComment: string | null
    notifyApplicant: boolean | null
    applicantNotificationContent: string | null
    editApplicationStatus: boolean | null
    applicantViewFormAfterCompletion: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessFormCountAggregateOutputType = {
    id: number
    processId: number
    formId: number
    order: number
    nextStepType: number
    nextStepRoles: number
    nextStaffId: number
    nextStepSpecifiedTo: number
    notificationType: number
    notificationRoles: number
    notificationToId: number
    notificationComment: number
    notifyApplicant: number
    applicantNotificationContent: number
    editApplicationStatus: number
    applicantViewFormAfterCompletion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcessFormAvgAggregateInputType = {
    order?: true
  }

  export type ProcessFormSumAggregateInputType = {
    order?: true
  }

  export type ProcessFormMinAggregateInputType = {
    id?: true
    processId?: true
    formId?: true
    order?: true
    nextStepType?: true
    nextStaffId?: true
    nextStepSpecifiedTo?: true
    notificationType?: true
    notificationToId?: true
    notificationComment?: true
    notifyApplicant?: true
    applicantNotificationContent?: true
    editApplicationStatus?: true
    applicantViewFormAfterCompletion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessFormMaxAggregateInputType = {
    id?: true
    processId?: true
    formId?: true
    order?: true
    nextStepType?: true
    nextStaffId?: true
    nextStepSpecifiedTo?: true
    notificationType?: true
    notificationToId?: true
    notificationComment?: true
    notifyApplicant?: true
    applicantNotificationContent?: true
    editApplicationStatus?: true
    applicantViewFormAfterCompletion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessFormCountAggregateInputType = {
    id?: true
    processId?: true
    formId?: true
    order?: true
    nextStepType?: true
    nextStepRoles?: true
    nextStaffId?: true
    nextStepSpecifiedTo?: true
    notificationType?: true
    notificationRoles?: true
    notificationToId?: true
    notificationComment?: true
    notifyApplicant?: true
    applicantNotificationContent?: true
    editApplicationStatus?: true
    applicantViewFormAfterCompletion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcessFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessForm to aggregate.
     */
    where?: ProcessFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessForms to fetch.
     */
    orderBy?: ProcessFormOrderByWithRelationInput | ProcessFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessForms
    **/
    _count?: true | ProcessFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcessFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcessFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessFormMaxAggregateInputType
  }

  export type GetProcessFormAggregateType<T extends ProcessFormAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessForm[P]>
      : GetScalarType<T[P], AggregateProcessForm[P]>
  }




  export type ProcessFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessFormWhereInput
    orderBy?: ProcessFormOrderByWithAggregationInput | ProcessFormOrderByWithAggregationInput[]
    by: ProcessFormScalarFieldEnum[] | ProcessFormScalarFieldEnum
    having?: ProcessFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessFormCountAggregateInputType | true
    _avg?: ProcessFormAvgAggregateInputType
    _sum?: ProcessFormSumAggregateInputType
    _min?: ProcessFormMinAggregateInputType
    _max?: ProcessFormMaxAggregateInputType
  }

  export type ProcessFormGroupByOutputType = {
    id: string
    processId: string
    formId: string
    order: number
    nextStepType: $Enums.NextStepType
    nextStepRoles: string[]
    nextStaffId: string | null
    nextStepSpecifiedTo: string | null
    notificationType: $Enums.NextStepType
    notificationRoles: string[]
    notificationToId: string | null
    notificationComment: string | null
    notifyApplicant: boolean
    applicantNotificationContent: string | null
    editApplicationStatus: boolean
    applicantViewFormAfterCompletion: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProcessFormCountAggregateOutputType | null
    _avg: ProcessFormAvgAggregateOutputType | null
    _sum: ProcessFormSumAggregateOutputType | null
    _min: ProcessFormMinAggregateOutputType | null
    _max: ProcessFormMaxAggregateOutputType | null
  }

  type GetProcessFormGroupByPayload<T extends ProcessFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessFormGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessFormGroupByOutputType[P]>
        }
      >
    >


  export type ProcessFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    formId?: boolean
    order?: boolean
    nextStepType?: boolean
    nextStepRoles?: boolean
    nextStaffId?: boolean
    nextStepSpecifiedTo?: boolean
    notificationType?: boolean
    notificationRoles?: boolean
    notificationToId?: boolean
    notificationComment?: boolean
    notifyApplicant?: boolean
    applicantNotificationContent?: boolean
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processForm"]>

  export type ProcessFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    formId?: boolean
    order?: boolean
    nextStepType?: boolean
    nextStepRoles?: boolean
    nextStaffId?: boolean
    nextStepSpecifiedTo?: boolean
    notificationType?: boolean
    notificationRoles?: boolean
    notificationToId?: boolean
    notificationComment?: boolean
    notifyApplicant?: boolean
    applicantNotificationContent?: boolean
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processForm"]>

  export type ProcessFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    processId?: boolean
    formId?: boolean
    order?: boolean
    nextStepType?: boolean
    nextStepRoles?: boolean
    nextStaffId?: boolean
    nextStepSpecifiedTo?: boolean
    notificationType?: boolean
    notificationRoles?: boolean
    notificationToId?: boolean
    notificationComment?: boolean
    notifyApplicant?: boolean
    applicantNotificationContent?: boolean
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processForm"]>

  export type ProcessFormSelectScalar = {
    id?: boolean
    processId?: boolean
    formId?: boolean
    order?: boolean
    nextStepType?: boolean
    nextStepRoles?: boolean
    nextStaffId?: boolean
    nextStepSpecifiedTo?: boolean
    notificationType?: boolean
    notificationRoles?: boolean
    notificationToId?: boolean
    notificationComment?: boolean
    notifyApplicant?: boolean
    applicantNotificationContent?: boolean
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcessFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "processId" | "formId" | "order" | "nextStepType" | "nextStepRoles" | "nextStaffId" | "nextStepSpecifiedTo" | "notificationType" | "notificationRoles" | "notificationToId" | "notificationComment" | "notifyApplicant" | "applicantNotificationContent" | "editApplicationStatus" | "applicantViewFormAfterCompletion" | "createdAt" | "updatedAt", ExtArgs["result"]["processForm"]>
  export type ProcessFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }
  export type ProcessFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }
  export type ProcessFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form?: boolean | FormDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }

  export type $ProcessFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessForm"
    objects: {
      form: Prisma.$FormPayload<ExtArgs>
      process: Prisma.$ProcessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      processId: string
      formId: string
      order: number
      nextStepType: $Enums.NextStepType
      nextStepRoles: string[]
      nextStaffId: string | null
      nextStepSpecifiedTo: string | null
      notificationType: $Enums.NextStepType
      notificationRoles: string[]
      notificationToId: string | null
      notificationComment: string | null
      notifyApplicant: boolean
      applicantNotificationContent: string | null
      editApplicationStatus: boolean
      applicantViewFormAfterCompletion: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["processForm"]>
    composites: {}
  }

  type ProcessFormGetPayload<S extends boolean | null | undefined | ProcessFormDefaultArgs> = $Result.GetResult<Prisma.$ProcessFormPayload, S>

  type ProcessFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProcessFormCountAggregateInputType | true
    }

  export interface ProcessFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessForm'], meta: { name: 'ProcessForm' } }
    /**
     * Find zero or one ProcessForm that matches the filter.
     * @param {ProcessFormFindUniqueArgs} args - Arguments to find a ProcessForm
     * @example
     * // Get one ProcessForm
     * const processForm = await prisma.processForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessFormFindUniqueArgs>(args: SelectSubset<T, ProcessFormFindUniqueArgs<ExtArgs>>): Prisma__ProcessFormClient<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessFormFindUniqueOrThrowArgs} args - Arguments to find a ProcessForm
     * @example
     * // Get one ProcessForm
     * const processForm = await prisma.processForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessFormFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessFormClient<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFormFindFirstArgs} args - Arguments to find a ProcessForm
     * @example
     * // Get one ProcessForm
     * const processForm = await prisma.processForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessFormFindFirstArgs>(args?: SelectSubset<T, ProcessFormFindFirstArgs<ExtArgs>>): Prisma__ProcessFormClient<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFormFindFirstOrThrowArgs} args - Arguments to find a ProcessForm
     * @example
     * // Get one ProcessForm
     * const processForm = await prisma.processForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessFormFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessFormClient<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessForms
     * const processForms = await prisma.processForm.findMany()
     * 
     * // Get first 10 ProcessForms
     * const processForms = await prisma.processForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processFormWithIdOnly = await prisma.processForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessFormFindManyArgs>(args?: SelectSubset<T, ProcessFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessForm.
     * @param {ProcessFormCreateArgs} args - Arguments to create a ProcessForm.
     * @example
     * // Create one ProcessForm
     * const ProcessForm = await prisma.processForm.create({
     *   data: {
     *     // ... data to create a ProcessForm
     *   }
     * })
     * 
     */
    create<T extends ProcessFormCreateArgs>(args: SelectSubset<T, ProcessFormCreateArgs<ExtArgs>>): Prisma__ProcessFormClient<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessForms.
     * @param {ProcessFormCreateManyArgs} args - Arguments to create many ProcessForms.
     * @example
     * // Create many ProcessForms
     * const processForm = await prisma.processForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessFormCreateManyArgs>(args?: SelectSubset<T, ProcessFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessForms and returns the data saved in the database.
     * @param {ProcessFormCreateManyAndReturnArgs} args - Arguments to create many ProcessForms.
     * @example
     * // Create many ProcessForms
     * const processForm = await prisma.processForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessForms and only return the `id`
     * const processFormWithIdOnly = await prisma.processForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessFormCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcessForm.
     * @param {ProcessFormDeleteArgs} args - Arguments to delete one ProcessForm.
     * @example
     * // Delete one ProcessForm
     * const ProcessForm = await prisma.processForm.delete({
     *   where: {
     *     // ... filter to delete one ProcessForm
     *   }
     * })
     * 
     */
    delete<T extends ProcessFormDeleteArgs>(args: SelectSubset<T, ProcessFormDeleteArgs<ExtArgs>>): Prisma__ProcessFormClient<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessForm.
     * @param {ProcessFormUpdateArgs} args - Arguments to update one ProcessForm.
     * @example
     * // Update one ProcessForm
     * const processForm = await prisma.processForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessFormUpdateArgs>(args: SelectSubset<T, ProcessFormUpdateArgs<ExtArgs>>): Prisma__ProcessFormClient<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessForms.
     * @param {ProcessFormDeleteManyArgs} args - Arguments to filter ProcessForms to delete.
     * @example
     * // Delete a few ProcessForms
     * const { count } = await prisma.processForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessFormDeleteManyArgs>(args?: SelectSubset<T, ProcessFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessForms
     * const processForm = await prisma.processForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessFormUpdateManyArgs>(args: SelectSubset<T, ProcessFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessForms and returns the data updated in the database.
     * @param {ProcessFormUpdateManyAndReturnArgs} args - Arguments to update many ProcessForms.
     * @example
     * // Update many ProcessForms
     * const processForm = await prisma.processForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcessForms and only return the `id`
     * const processFormWithIdOnly = await prisma.processForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessFormUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcessForm.
     * @param {ProcessFormUpsertArgs} args - Arguments to update or create a ProcessForm.
     * @example
     * // Update or create a ProcessForm
     * const processForm = await prisma.processForm.upsert({
     *   create: {
     *     // ... data to create a ProcessForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessForm we want to update
     *   }
     * })
     */
    upsert<T extends ProcessFormUpsertArgs>(args: SelectSubset<T, ProcessFormUpsertArgs<ExtArgs>>): Prisma__ProcessFormClient<$Result.GetResult<Prisma.$ProcessFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcessForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFormCountArgs} args - Arguments to filter ProcessForms to count.
     * @example
     * // Count the number of ProcessForms
     * const count = await prisma.processForm.count({
     *   where: {
     *     // ... the filter for the ProcessForms we want to count
     *   }
     * })
    **/
    count<T extends ProcessFormCountArgs>(
      args?: Subset<T, ProcessFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessFormAggregateArgs>(args: Subset<T, ProcessFormAggregateArgs>): Prisma.PrismaPromise<GetProcessFormAggregateType<T>>

    /**
     * Group by ProcessForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessFormGroupByArgs['orderBy'] }
        : { orderBy?: ProcessFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessForm model
   */
  readonly fields: ProcessFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    form<T extends FormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormDefaultArgs<ExtArgs>>): Prisma__FormClient<$Result.GetResult<Prisma.$FormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessForm model
   */
  interface ProcessFormFieldRefs {
    readonly id: FieldRef<"ProcessForm", 'String'>
    readonly processId: FieldRef<"ProcessForm", 'String'>
    readonly formId: FieldRef<"ProcessForm", 'String'>
    readonly order: FieldRef<"ProcessForm", 'Int'>
    readonly nextStepType: FieldRef<"ProcessForm", 'NextStepType'>
    readonly nextStepRoles: FieldRef<"ProcessForm", 'String[]'>
    readonly nextStaffId: FieldRef<"ProcessForm", 'String'>
    readonly nextStepSpecifiedTo: FieldRef<"ProcessForm", 'String'>
    readonly notificationType: FieldRef<"ProcessForm", 'NextStepType'>
    readonly notificationRoles: FieldRef<"ProcessForm", 'String[]'>
    readonly notificationToId: FieldRef<"ProcessForm", 'String'>
    readonly notificationComment: FieldRef<"ProcessForm", 'String'>
    readonly notifyApplicant: FieldRef<"ProcessForm", 'Boolean'>
    readonly applicantNotificationContent: FieldRef<"ProcessForm", 'String'>
    readonly editApplicationStatus: FieldRef<"ProcessForm", 'Boolean'>
    readonly applicantViewFormAfterCompletion: FieldRef<"ProcessForm", 'Boolean'>
    readonly createdAt: FieldRef<"ProcessForm", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcessForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProcessForm findUnique
   */
  export type ProcessFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * Filter, which ProcessForm to fetch.
     */
    where: ProcessFormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm findUniqueOrThrow
   */
  export type ProcessFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * Filter, which ProcessForm to fetch.
     */
    where: ProcessFormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm findFirst
   */
  export type ProcessFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * Filter, which ProcessForm to fetch.
     */
    where?: ProcessFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessForms to fetch.
     */
    orderBy?: ProcessFormOrderByWithRelationInput | ProcessFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessForms.
     */
    cursor?: ProcessFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessForms.
     */
    distinct?: ProcessFormScalarFieldEnum | ProcessFormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm findFirstOrThrow
   */
  export type ProcessFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * Filter, which ProcessForm to fetch.
     */
    where?: ProcessFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessForms to fetch.
     */
    orderBy?: ProcessFormOrderByWithRelationInput | ProcessFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessForms.
     */
    cursor?: ProcessFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessForms.
     */
    distinct?: ProcessFormScalarFieldEnum | ProcessFormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm findMany
   */
  export type ProcessFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * Filter, which ProcessForms to fetch.
     */
    where?: ProcessFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessForms to fetch.
     */
    orderBy?: ProcessFormOrderByWithRelationInput | ProcessFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessForms.
     */
    cursor?: ProcessFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessForms.
     */
    skip?: number
    distinct?: ProcessFormScalarFieldEnum | ProcessFormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm create
   */
  export type ProcessFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessForm.
     */
    data: XOR<ProcessFormCreateInput, ProcessFormUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm createMany
   */
  export type ProcessFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessForms.
     */
    data: ProcessFormCreateManyInput | ProcessFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessForm createManyAndReturn
   */
  export type ProcessFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * The data used to create many ProcessForms.
     */
    data: ProcessFormCreateManyInput | ProcessFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessForm update
   */
  export type ProcessFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessForm.
     */
    data: XOR<ProcessFormUpdateInput, ProcessFormUncheckedUpdateInput>
    /**
     * Choose, which ProcessForm to update.
     */
    where: ProcessFormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm updateMany
   */
  export type ProcessFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessForms.
     */
    data: XOR<ProcessFormUpdateManyMutationInput, ProcessFormUncheckedUpdateManyInput>
    /**
     * Filter which ProcessForms to update
     */
    where?: ProcessFormWhereInput
    /**
     * Limit how many ProcessForms to update.
     */
    limit?: number
  }

  /**
   * ProcessForm updateManyAndReturn
   */
  export type ProcessFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * The data used to update ProcessForms.
     */
    data: XOR<ProcessFormUpdateManyMutationInput, ProcessFormUncheckedUpdateManyInput>
    /**
     * Filter which ProcessForms to update
     */
    where?: ProcessFormWhereInput
    /**
     * Limit how many ProcessForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessForm upsert
   */
  export type ProcessFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessForm to update in case it exists.
     */
    where: ProcessFormWhereUniqueInput
    /**
     * In case the ProcessForm found by the `where` argument doesn't exist, create a new ProcessForm with this data.
     */
    create: XOR<ProcessFormCreateInput, ProcessFormUncheckedCreateInput>
    /**
     * In case the ProcessForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessFormUpdateInput, ProcessFormUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm delete
   */
  export type ProcessFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
    /**
     * Filter which ProcessForm to delete.
     */
    where: ProcessFormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessForm deleteMany
   */
  export type ProcessFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessForms to delete
     */
    where?: ProcessFormWhereInput
    /**
     * Limit how many ProcessForms to delete.
     */
    limit?: number
  }

  /**
   * ProcessForm without action
   */
  export type ProcessFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessForm
     */
    select?: ProcessFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessForm
     */
    omit?: ProcessFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessFormInclude<ExtArgs> | null
  }


  /**
   * Model ApplicantProcess
   */

  export type AggregateApplicantProcess = {
    _count: ApplicantProcessCountAggregateOutputType | null
    _min: ApplicantProcessMinAggregateOutputType | null
    _max: ApplicantProcessMaxAggregateOutputType | null
  }

  export type ApplicantProcessMinAggregateOutputType = {
    id: string | null
    applicantId: string | null
    processId: string | null
    status: $Enums.ProcessStatus | null
    createdAt: Date | null
  }

  export type ApplicantProcessMaxAggregateOutputType = {
    id: string | null
    applicantId: string | null
    processId: string | null
    status: $Enums.ProcessStatus | null
    createdAt: Date | null
  }

  export type ApplicantProcessCountAggregateOutputType = {
    id: number
    applicantId: number
    processId: number
    status: number
    createdAt: number
    _all: number
  }


  export type ApplicantProcessMinAggregateInputType = {
    id?: true
    applicantId?: true
    processId?: true
    status?: true
    createdAt?: true
  }

  export type ApplicantProcessMaxAggregateInputType = {
    id?: true
    applicantId?: true
    processId?: true
    status?: true
    createdAt?: true
  }

  export type ApplicantProcessCountAggregateInputType = {
    id?: true
    applicantId?: true
    processId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ApplicantProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicantProcess to aggregate.
     */
    where?: ApplicantProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicantProcesses to fetch.
     */
    orderBy?: ApplicantProcessOrderByWithRelationInput | ApplicantProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicantProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicantProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicantProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApplicantProcesses
    **/
    _count?: true | ApplicantProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicantProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicantProcessMaxAggregateInputType
  }

  export type GetApplicantProcessAggregateType<T extends ApplicantProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicantProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicantProcess[P]>
      : GetScalarType<T[P], AggregateApplicantProcess[P]>
  }




  export type ApplicantProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicantProcessWhereInput
    orderBy?: ApplicantProcessOrderByWithAggregationInput | ApplicantProcessOrderByWithAggregationInput[]
    by: ApplicantProcessScalarFieldEnum[] | ApplicantProcessScalarFieldEnum
    having?: ApplicantProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicantProcessCountAggregateInputType | true
    _min?: ApplicantProcessMinAggregateInputType
    _max?: ApplicantProcessMaxAggregateInputType
  }

  export type ApplicantProcessGroupByOutputType = {
    id: string
    applicantId: string
    processId: string
    status: $Enums.ProcessStatus
    createdAt: Date
    _count: ApplicantProcessCountAggregateOutputType | null
    _min: ApplicantProcessMinAggregateOutputType | null
    _max: ApplicantProcessMaxAggregateOutputType | null
  }

  type GetApplicantProcessGroupByPayload<T extends ApplicantProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicantProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicantProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicantProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicantProcessGroupByOutputType[P]>
        }
      >
    >


  export type ApplicantProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantId?: boolean
    processId?: boolean
    status?: boolean
    createdAt?: boolean
    completedForms?: boolean | ApplicantProcess$completedFormsArgs<ExtArgs>
    applicant?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    processedApplications?: boolean | ApplicantProcess$processedApplicationsArgs<ExtArgs>
    responses?: boolean | ApplicantProcess$responsesArgs<ExtArgs>
    comments?: boolean | ApplicantProcess$commentsArgs<ExtArgs>
    _count?: boolean | ApplicantProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicantProcess"]>

  export type ApplicantProcessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantId?: boolean
    processId?: boolean
    status?: boolean
    createdAt?: boolean
    applicant?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicantProcess"]>

  export type ApplicantProcessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantId?: boolean
    processId?: boolean
    status?: boolean
    createdAt?: boolean
    applicant?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicantProcess"]>

  export type ApplicantProcessSelectScalar = {
    id?: boolean
    applicantId?: boolean
    processId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ApplicantProcessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicantId" | "processId" | "status" | "createdAt", ExtArgs["result"]["applicantProcess"]>
  export type ApplicantProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completedForms?: boolean | ApplicantProcess$completedFormsArgs<ExtArgs>
    applicant?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    processedApplications?: boolean | ApplicantProcess$processedApplicationsArgs<ExtArgs>
    responses?: boolean | ApplicantProcess$responsesArgs<ExtArgs>
    comments?: boolean | ApplicantProcess$commentsArgs<ExtArgs>
    _count?: boolean | ApplicantProcessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplicantProcessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }
  export type ApplicantProcessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicant?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
  }

  export type $ApplicantProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApplicantProcess"
    objects: {
      completedForms: Prisma.$APCompletedFormPayload<ExtArgs>[]
      applicant: Prisma.$UserPayload<ExtArgs>
      process: Prisma.$ProcessPayload<ExtArgs>
      processedApplications: Prisma.$ProcessedApplicationPayload<ExtArgs>[]
      responses: Prisma.$FormResponsePayload<ExtArgs>[]
      comments: Prisma.$ProcessCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicantId: string
      processId: string
      status: $Enums.ProcessStatus
      createdAt: Date
    }, ExtArgs["result"]["applicantProcess"]>
    composites: {}
  }

  type ApplicantProcessGetPayload<S extends boolean | null | undefined | ApplicantProcessDefaultArgs> = $Result.GetResult<Prisma.$ApplicantProcessPayload, S>

  type ApplicantProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicantProcessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ApplicantProcessCountAggregateInputType | true
    }

  export interface ApplicantProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApplicantProcess'], meta: { name: 'ApplicantProcess' } }
    /**
     * Find zero or one ApplicantProcess that matches the filter.
     * @param {ApplicantProcessFindUniqueArgs} args - Arguments to find a ApplicantProcess
     * @example
     * // Get one ApplicantProcess
     * const applicantProcess = await prisma.applicantProcess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicantProcessFindUniqueArgs>(args: SelectSubset<T, ApplicantProcessFindUniqueArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApplicantProcess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicantProcessFindUniqueOrThrowArgs} args - Arguments to find a ApplicantProcess
     * @example
     * // Get one ApplicantProcess
     * const applicantProcess = await prisma.applicantProcess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicantProcessFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicantProcessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicantProcess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantProcessFindFirstArgs} args - Arguments to find a ApplicantProcess
     * @example
     * // Get one ApplicantProcess
     * const applicantProcess = await prisma.applicantProcess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicantProcessFindFirstArgs>(args?: SelectSubset<T, ApplicantProcessFindFirstArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApplicantProcess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantProcessFindFirstOrThrowArgs} args - Arguments to find a ApplicantProcess
     * @example
     * // Get one ApplicantProcess
     * const applicantProcess = await prisma.applicantProcess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicantProcessFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicantProcessFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApplicantProcesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantProcessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApplicantProcesses
     * const applicantProcesses = await prisma.applicantProcess.findMany()
     * 
     * // Get first 10 ApplicantProcesses
     * const applicantProcesses = await prisma.applicantProcess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicantProcessWithIdOnly = await prisma.applicantProcess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplicantProcessFindManyArgs>(args?: SelectSubset<T, ApplicantProcessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApplicantProcess.
     * @param {ApplicantProcessCreateArgs} args - Arguments to create a ApplicantProcess.
     * @example
     * // Create one ApplicantProcess
     * const ApplicantProcess = await prisma.applicantProcess.create({
     *   data: {
     *     // ... data to create a ApplicantProcess
     *   }
     * })
     * 
     */
    create<T extends ApplicantProcessCreateArgs>(args: SelectSubset<T, ApplicantProcessCreateArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApplicantProcesses.
     * @param {ApplicantProcessCreateManyArgs} args - Arguments to create many ApplicantProcesses.
     * @example
     * // Create many ApplicantProcesses
     * const applicantProcess = await prisma.applicantProcess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicantProcessCreateManyArgs>(args?: SelectSubset<T, ApplicantProcessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApplicantProcesses and returns the data saved in the database.
     * @param {ApplicantProcessCreateManyAndReturnArgs} args - Arguments to create many ApplicantProcesses.
     * @example
     * // Create many ApplicantProcesses
     * const applicantProcess = await prisma.applicantProcess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApplicantProcesses and only return the `id`
     * const applicantProcessWithIdOnly = await prisma.applicantProcess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicantProcessCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicantProcessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApplicantProcess.
     * @param {ApplicantProcessDeleteArgs} args - Arguments to delete one ApplicantProcess.
     * @example
     * // Delete one ApplicantProcess
     * const ApplicantProcess = await prisma.applicantProcess.delete({
     *   where: {
     *     // ... filter to delete one ApplicantProcess
     *   }
     * })
     * 
     */
    delete<T extends ApplicantProcessDeleteArgs>(args: SelectSubset<T, ApplicantProcessDeleteArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApplicantProcess.
     * @param {ApplicantProcessUpdateArgs} args - Arguments to update one ApplicantProcess.
     * @example
     * // Update one ApplicantProcess
     * const applicantProcess = await prisma.applicantProcess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicantProcessUpdateArgs>(args: SelectSubset<T, ApplicantProcessUpdateArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApplicantProcesses.
     * @param {ApplicantProcessDeleteManyArgs} args - Arguments to filter ApplicantProcesses to delete.
     * @example
     * // Delete a few ApplicantProcesses
     * const { count } = await prisma.applicantProcess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicantProcessDeleteManyArgs>(args?: SelectSubset<T, ApplicantProcessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicantProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApplicantProcesses
     * const applicantProcess = await prisma.applicantProcess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicantProcessUpdateManyArgs>(args: SelectSubset<T, ApplicantProcessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApplicantProcesses and returns the data updated in the database.
     * @param {ApplicantProcessUpdateManyAndReturnArgs} args - Arguments to update many ApplicantProcesses.
     * @example
     * // Update many ApplicantProcesses
     * const applicantProcess = await prisma.applicantProcess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApplicantProcesses and only return the `id`
     * const applicantProcessWithIdOnly = await prisma.applicantProcess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplicantProcessUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplicantProcessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApplicantProcess.
     * @param {ApplicantProcessUpsertArgs} args - Arguments to update or create a ApplicantProcess.
     * @example
     * // Update or create a ApplicantProcess
     * const applicantProcess = await prisma.applicantProcess.upsert({
     *   create: {
     *     // ... data to create a ApplicantProcess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApplicantProcess we want to update
     *   }
     * })
     */
    upsert<T extends ApplicantProcessUpsertArgs>(args: SelectSubset<T, ApplicantProcessUpsertArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApplicantProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantProcessCountArgs} args - Arguments to filter ApplicantProcesses to count.
     * @example
     * // Count the number of ApplicantProcesses
     * const count = await prisma.applicantProcess.count({
     *   where: {
     *     // ... the filter for the ApplicantProcesses we want to count
     *   }
     * })
    **/
    count<T extends ApplicantProcessCountArgs>(
      args?: Subset<T, ApplicantProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicantProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApplicantProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicantProcessAggregateArgs>(args: Subset<T, ApplicantProcessAggregateArgs>): Prisma.PrismaPromise<GetApplicantProcessAggregateType<T>>

    /**
     * Group by ApplicantProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicantProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicantProcessGroupByArgs['orderBy'] }
        : { orderBy?: ApplicantProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicantProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicantProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApplicantProcess model
   */
  readonly fields: ApplicantProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApplicantProcess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicantProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    completedForms<T extends ApplicantProcess$completedFormsArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantProcess$completedFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applicant<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    processedApplications<T extends ApplicantProcess$processedApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantProcess$processedApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responses<T extends ApplicantProcess$responsesArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantProcess$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends ApplicantProcess$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantProcess$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApplicantProcess model
   */
  interface ApplicantProcessFieldRefs {
    readonly id: FieldRef<"ApplicantProcess", 'String'>
    readonly applicantId: FieldRef<"ApplicantProcess", 'String'>
    readonly processId: FieldRef<"ApplicantProcess", 'String'>
    readonly status: FieldRef<"ApplicantProcess", 'ProcessStatus'>
    readonly createdAt: FieldRef<"ApplicantProcess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApplicantProcess findUnique
   */
  export type ApplicantProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * Filter, which ApplicantProcess to fetch.
     */
    where: ApplicantProcessWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess findUniqueOrThrow
   */
  export type ApplicantProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * Filter, which ApplicantProcess to fetch.
     */
    where: ApplicantProcessWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess findFirst
   */
  export type ApplicantProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * Filter, which ApplicantProcess to fetch.
     */
    where?: ApplicantProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicantProcesses to fetch.
     */
    orderBy?: ApplicantProcessOrderByWithRelationInput | ApplicantProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicantProcesses.
     */
    cursor?: ApplicantProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicantProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicantProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicantProcesses.
     */
    distinct?: ApplicantProcessScalarFieldEnum | ApplicantProcessScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess findFirstOrThrow
   */
  export type ApplicantProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * Filter, which ApplicantProcess to fetch.
     */
    where?: ApplicantProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicantProcesses to fetch.
     */
    orderBy?: ApplicantProcessOrderByWithRelationInput | ApplicantProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApplicantProcesses.
     */
    cursor?: ApplicantProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicantProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicantProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApplicantProcesses.
     */
    distinct?: ApplicantProcessScalarFieldEnum | ApplicantProcessScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess findMany
   */
  export type ApplicantProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * Filter, which ApplicantProcesses to fetch.
     */
    where?: ApplicantProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApplicantProcesses to fetch.
     */
    orderBy?: ApplicantProcessOrderByWithRelationInput | ApplicantProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApplicantProcesses.
     */
    cursor?: ApplicantProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApplicantProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApplicantProcesses.
     */
    skip?: number
    distinct?: ApplicantProcessScalarFieldEnum | ApplicantProcessScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess create
   */
  export type ApplicantProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a ApplicantProcess.
     */
    data: XOR<ApplicantProcessCreateInput, ApplicantProcessUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess createMany
   */
  export type ApplicantProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApplicantProcesses.
     */
    data: ApplicantProcessCreateManyInput | ApplicantProcessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApplicantProcess createManyAndReturn
   */
  export type ApplicantProcessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * The data used to create many ApplicantProcesses.
     */
    data: ApplicantProcessCreateManyInput | ApplicantProcessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicantProcess update
   */
  export type ApplicantProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a ApplicantProcess.
     */
    data: XOR<ApplicantProcessUpdateInput, ApplicantProcessUncheckedUpdateInput>
    /**
     * Choose, which ApplicantProcess to update.
     */
    where: ApplicantProcessWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess updateMany
   */
  export type ApplicantProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApplicantProcesses.
     */
    data: XOR<ApplicantProcessUpdateManyMutationInput, ApplicantProcessUncheckedUpdateManyInput>
    /**
     * Filter which ApplicantProcesses to update
     */
    where?: ApplicantProcessWhereInput
    /**
     * Limit how many ApplicantProcesses to update.
     */
    limit?: number
  }

  /**
   * ApplicantProcess updateManyAndReturn
   */
  export type ApplicantProcessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * The data used to update ApplicantProcesses.
     */
    data: XOR<ApplicantProcessUpdateManyMutationInput, ApplicantProcessUncheckedUpdateManyInput>
    /**
     * Filter which ApplicantProcesses to update
     */
    where?: ApplicantProcessWhereInput
    /**
     * Limit how many ApplicantProcesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApplicantProcess upsert
   */
  export type ApplicantProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the ApplicantProcess to update in case it exists.
     */
    where: ApplicantProcessWhereUniqueInput
    /**
     * In case the ApplicantProcess found by the `where` argument doesn't exist, create a new ApplicantProcess with this data.
     */
    create: XOR<ApplicantProcessCreateInput, ApplicantProcessUncheckedCreateInput>
    /**
     * In case the ApplicantProcess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicantProcessUpdateInput, ApplicantProcessUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess delete
   */
  export type ApplicantProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
    /**
     * Filter which ApplicantProcess to delete.
     */
    where: ApplicantProcessWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ApplicantProcess deleteMany
   */
  export type ApplicantProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApplicantProcesses to delete
     */
    where?: ApplicantProcessWhereInput
    /**
     * Limit how many ApplicantProcesses to delete.
     */
    limit?: number
  }

  /**
   * ApplicantProcess.completedForms
   */
  export type ApplicantProcess$completedFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    where?: APCompletedFormWhereInput
    orderBy?: APCompletedFormOrderByWithRelationInput | APCompletedFormOrderByWithRelationInput[]
    cursor?: APCompletedFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: APCompletedFormScalarFieldEnum | APCompletedFormScalarFieldEnum[]
  }

  /**
   * ApplicantProcess.processedApplications
   */
  export type ApplicantProcess$processedApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    where?: ProcessedApplicationWhereInput
    orderBy?: ProcessedApplicationOrderByWithRelationInput | ProcessedApplicationOrderByWithRelationInput[]
    cursor?: ProcessedApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessedApplicationScalarFieldEnum | ProcessedApplicationScalarFieldEnum[]
  }

  /**
   * ApplicantProcess.responses
   */
  export type ApplicantProcess$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormResponse
     */
    select?: FormResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormResponse
     */
    omit?: FormResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormResponseInclude<ExtArgs> | null
    where?: FormResponseWhereInput
    orderBy?: FormResponseOrderByWithRelationInput | FormResponseOrderByWithRelationInput[]
    cursor?: FormResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormResponseScalarFieldEnum | FormResponseScalarFieldEnum[]
  }

  /**
   * ApplicantProcess.comments
   */
  export type ApplicantProcess$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    where?: ProcessCommentWhereInput
    orderBy?: ProcessCommentOrderByWithRelationInput | ProcessCommentOrderByWithRelationInput[]
    cursor?: ProcessCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcessCommentScalarFieldEnum | ProcessCommentScalarFieldEnum[]
  }

  /**
   * ApplicantProcess without action
   */
  export type ApplicantProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicantProcess
     */
    select?: ApplicantProcessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApplicantProcess
     */
    omit?: ApplicantProcessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicantProcessInclude<ExtArgs> | null
  }


  /**
   * Model ProcessedApplication
   */

  export type AggregateProcessedApplication = {
    _count: ProcessedApplicationCountAggregateOutputType | null
    _min: ProcessedApplicationMinAggregateOutputType | null
    _max: ProcessedApplicationMaxAggregateOutputType | null
  }

  export type ProcessedApplicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    processId: string | null
    applicantProcessId: string | null
    formId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessedApplicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    processId: string | null
    applicantProcessId: string | null
    formId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcessedApplicationCountAggregateOutputType = {
    id: number
    userId: number
    processId: number
    applicantProcessId: number
    formId: number
    formRoleIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcessedApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    processId?: true
    applicantProcessId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessedApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    processId?: true
    applicantProcessId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcessedApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    processId?: true
    applicantProcessId?: true
    formId?: true
    formRoleIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcessedApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessedApplication to aggregate.
     */
    where?: ProcessedApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessedApplications to fetch.
     */
    orderBy?: ProcessedApplicationOrderByWithRelationInput | ProcessedApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessedApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessedApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessedApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessedApplications
    **/
    _count?: true | ProcessedApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessedApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessedApplicationMaxAggregateInputType
  }

  export type GetProcessedApplicationAggregateType<T extends ProcessedApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessedApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessedApplication[P]>
      : GetScalarType<T[P], AggregateProcessedApplication[P]>
  }




  export type ProcessedApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessedApplicationWhereInput
    orderBy?: ProcessedApplicationOrderByWithAggregationInput | ProcessedApplicationOrderByWithAggregationInput[]
    by: ProcessedApplicationScalarFieldEnum[] | ProcessedApplicationScalarFieldEnum
    having?: ProcessedApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessedApplicationCountAggregateInputType | true
    _min?: ProcessedApplicationMinAggregateInputType
    _max?: ProcessedApplicationMaxAggregateInputType
  }

  export type ProcessedApplicationGroupByOutputType = {
    id: string
    userId: string
    processId: string
    applicantProcessId: string
    formId: string
    formRoleIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: ProcessedApplicationCountAggregateOutputType | null
    _min: ProcessedApplicationMinAggregateOutputType | null
    _max: ProcessedApplicationMaxAggregateOutputType | null
  }

  type GetProcessedApplicationGroupByPayload<T extends ProcessedApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessedApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessedApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessedApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessedApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ProcessedApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    processId?: boolean
    applicantProcessId?: boolean
    formId?: boolean
    formRoleIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processedApplication"]>

  export type ProcessedApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    processId?: boolean
    applicantProcessId?: boolean
    formId?: boolean
    formRoleIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processedApplication"]>

  export type ProcessedApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    processId?: boolean
    applicantProcessId?: boolean
    formId?: boolean
    formRoleIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processedApplication"]>

  export type ProcessedApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    processId?: boolean
    applicantProcessId?: boolean
    formId?: boolean
    formRoleIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcessedApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "processId" | "applicantProcessId" | "formId" | "formRoleIds" | "createdAt" | "updatedAt", ExtArgs["result"]["processedApplication"]>
  export type ProcessedApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }
  export type ProcessedApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }
  export type ProcessedApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    process?: boolean | ProcessDefaultArgs<ExtArgs>
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }

  export type $ProcessedApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessedApplication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      process: Prisma.$ProcessPayload<ExtArgs>
      applicantProcess: Prisma.$ApplicantProcessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      processId: string
      applicantProcessId: string
      formId: string
      formRoleIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["processedApplication"]>
    composites: {}
  }

  type ProcessedApplicationGetPayload<S extends boolean | null | undefined | ProcessedApplicationDefaultArgs> = $Result.GetResult<Prisma.$ProcessedApplicationPayload, S>

  type ProcessedApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessedApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProcessedApplicationCountAggregateInputType | true
    }

  export interface ProcessedApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessedApplication'], meta: { name: 'ProcessedApplication' } }
    /**
     * Find zero or one ProcessedApplication that matches the filter.
     * @param {ProcessedApplicationFindUniqueArgs} args - Arguments to find a ProcessedApplication
     * @example
     * // Get one ProcessedApplication
     * const processedApplication = await prisma.processedApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessedApplicationFindUniqueArgs>(args: SelectSubset<T, ProcessedApplicationFindUniqueArgs<ExtArgs>>): Prisma__ProcessedApplicationClient<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessedApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessedApplicationFindUniqueOrThrowArgs} args - Arguments to find a ProcessedApplication
     * @example
     * // Get one ProcessedApplication
     * const processedApplication = await prisma.processedApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessedApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessedApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessedApplicationClient<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessedApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessedApplicationFindFirstArgs} args - Arguments to find a ProcessedApplication
     * @example
     * // Get one ProcessedApplication
     * const processedApplication = await prisma.processedApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessedApplicationFindFirstArgs>(args?: SelectSubset<T, ProcessedApplicationFindFirstArgs<ExtArgs>>): Prisma__ProcessedApplicationClient<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessedApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessedApplicationFindFirstOrThrowArgs} args - Arguments to find a ProcessedApplication
     * @example
     * // Get one ProcessedApplication
     * const processedApplication = await prisma.processedApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessedApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessedApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessedApplicationClient<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessedApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessedApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessedApplications
     * const processedApplications = await prisma.processedApplication.findMany()
     * 
     * // Get first 10 ProcessedApplications
     * const processedApplications = await prisma.processedApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processedApplicationWithIdOnly = await prisma.processedApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessedApplicationFindManyArgs>(args?: SelectSubset<T, ProcessedApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessedApplication.
     * @param {ProcessedApplicationCreateArgs} args - Arguments to create a ProcessedApplication.
     * @example
     * // Create one ProcessedApplication
     * const ProcessedApplication = await prisma.processedApplication.create({
     *   data: {
     *     // ... data to create a ProcessedApplication
     *   }
     * })
     * 
     */
    create<T extends ProcessedApplicationCreateArgs>(args: SelectSubset<T, ProcessedApplicationCreateArgs<ExtArgs>>): Prisma__ProcessedApplicationClient<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessedApplications.
     * @param {ProcessedApplicationCreateManyArgs} args - Arguments to create many ProcessedApplications.
     * @example
     * // Create many ProcessedApplications
     * const processedApplication = await prisma.processedApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessedApplicationCreateManyArgs>(args?: SelectSubset<T, ProcessedApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessedApplications and returns the data saved in the database.
     * @param {ProcessedApplicationCreateManyAndReturnArgs} args - Arguments to create many ProcessedApplications.
     * @example
     * // Create many ProcessedApplications
     * const processedApplication = await prisma.processedApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessedApplications and only return the `id`
     * const processedApplicationWithIdOnly = await prisma.processedApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessedApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessedApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcessedApplication.
     * @param {ProcessedApplicationDeleteArgs} args - Arguments to delete one ProcessedApplication.
     * @example
     * // Delete one ProcessedApplication
     * const ProcessedApplication = await prisma.processedApplication.delete({
     *   where: {
     *     // ... filter to delete one ProcessedApplication
     *   }
     * })
     * 
     */
    delete<T extends ProcessedApplicationDeleteArgs>(args: SelectSubset<T, ProcessedApplicationDeleteArgs<ExtArgs>>): Prisma__ProcessedApplicationClient<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessedApplication.
     * @param {ProcessedApplicationUpdateArgs} args - Arguments to update one ProcessedApplication.
     * @example
     * // Update one ProcessedApplication
     * const processedApplication = await prisma.processedApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessedApplicationUpdateArgs>(args: SelectSubset<T, ProcessedApplicationUpdateArgs<ExtArgs>>): Prisma__ProcessedApplicationClient<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessedApplications.
     * @param {ProcessedApplicationDeleteManyArgs} args - Arguments to filter ProcessedApplications to delete.
     * @example
     * // Delete a few ProcessedApplications
     * const { count } = await prisma.processedApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessedApplicationDeleteManyArgs>(args?: SelectSubset<T, ProcessedApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessedApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessedApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessedApplications
     * const processedApplication = await prisma.processedApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessedApplicationUpdateManyArgs>(args: SelectSubset<T, ProcessedApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessedApplications and returns the data updated in the database.
     * @param {ProcessedApplicationUpdateManyAndReturnArgs} args - Arguments to update many ProcessedApplications.
     * @example
     * // Update many ProcessedApplications
     * const processedApplication = await prisma.processedApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcessedApplications and only return the `id`
     * const processedApplicationWithIdOnly = await prisma.processedApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessedApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessedApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcessedApplication.
     * @param {ProcessedApplicationUpsertArgs} args - Arguments to update or create a ProcessedApplication.
     * @example
     * // Update or create a ProcessedApplication
     * const processedApplication = await prisma.processedApplication.upsert({
     *   create: {
     *     // ... data to create a ProcessedApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessedApplication we want to update
     *   }
     * })
     */
    upsert<T extends ProcessedApplicationUpsertArgs>(args: SelectSubset<T, ProcessedApplicationUpsertArgs<ExtArgs>>): Prisma__ProcessedApplicationClient<$Result.GetResult<Prisma.$ProcessedApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcessedApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessedApplicationCountArgs} args - Arguments to filter ProcessedApplications to count.
     * @example
     * // Count the number of ProcessedApplications
     * const count = await prisma.processedApplication.count({
     *   where: {
     *     // ... the filter for the ProcessedApplications we want to count
     *   }
     * })
    **/
    count<T extends ProcessedApplicationCountArgs>(
      args?: Subset<T, ProcessedApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessedApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessedApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessedApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessedApplicationAggregateArgs>(args: Subset<T, ProcessedApplicationAggregateArgs>): Prisma.PrismaPromise<GetProcessedApplicationAggregateType<T>>

    /**
     * Group by ProcessedApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessedApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessedApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessedApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ProcessedApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessedApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessedApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessedApplication model
   */
  readonly fields: ProcessedApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessedApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessedApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    process<T extends ProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcessDefaultArgs<ExtArgs>>): Prisma__ProcessClient<$Result.GetResult<Prisma.$ProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applicantProcess<T extends ApplicantProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantProcessDefaultArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessedApplication model
   */
  interface ProcessedApplicationFieldRefs {
    readonly id: FieldRef<"ProcessedApplication", 'String'>
    readonly userId: FieldRef<"ProcessedApplication", 'String'>
    readonly processId: FieldRef<"ProcessedApplication", 'String'>
    readonly applicantProcessId: FieldRef<"ProcessedApplication", 'String'>
    readonly formId: FieldRef<"ProcessedApplication", 'String'>
    readonly formRoleIds: FieldRef<"ProcessedApplication", 'String[]'>
    readonly createdAt: FieldRef<"ProcessedApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcessedApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProcessedApplication findUnique
   */
  export type ProcessedApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessedApplication to fetch.
     */
    where: ProcessedApplicationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication findUniqueOrThrow
   */
  export type ProcessedApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessedApplication to fetch.
     */
    where: ProcessedApplicationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication findFirst
   */
  export type ProcessedApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessedApplication to fetch.
     */
    where?: ProcessedApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessedApplications to fetch.
     */
    orderBy?: ProcessedApplicationOrderByWithRelationInput | ProcessedApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessedApplications.
     */
    cursor?: ProcessedApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessedApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessedApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessedApplications.
     */
    distinct?: ProcessedApplicationScalarFieldEnum | ProcessedApplicationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication findFirstOrThrow
   */
  export type ProcessedApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessedApplication to fetch.
     */
    where?: ProcessedApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessedApplications to fetch.
     */
    orderBy?: ProcessedApplicationOrderByWithRelationInput | ProcessedApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessedApplications.
     */
    cursor?: ProcessedApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessedApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessedApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessedApplications.
     */
    distinct?: ProcessedApplicationScalarFieldEnum | ProcessedApplicationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication findMany
   */
  export type ProcessedApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ProcessedApplications to fetch.
     */
    where?: ProcessedApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessedApplications to fetch.
     */
    orderBy?: ProcessedApplicationOrderByWithRelationInput | ProcessedApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessedApplications.
     */
    cursor?: ProcessedApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessedApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessedApplications.
     */
    skip?: number
    distinct?: ProcessedApplicationScalarFieldEnum | ProcessedApplicationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication create
   */
  export type ProcessedApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessedApplication.
     */
    data: XOR<ProcessedApplicationCreateInput, ProcessedApplicationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication createMany
   */
  export type ProcessedApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessedApplications.
     */
    data: ProcessedApplicationCreateManyInput | ProcessedApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessedApplication createManyAndReturn
   */
  export type ProcessedApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many ProcessedApplications.
     */
    data: ProcessedApplicationCreateManyInput | ProcessedApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessedApplication update
   */
  export type ProcessedApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessedApplication.
     */
    data: XOR<ProcessedApplicationUpdateInput, ProcessedApplicationUncheckedUpdateInput>
    /**
     * Choose, which ProcessedApplication to update.
     */
    where: ProcessedApplicationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication updateMany
   */
  export type ProcessedApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessedApplications.
     */
    data: XOR<ProcessedApplicationUpdateManyMutationInput, ProcessedApplicationUncheckedUpdateManyInput>
    /**
     * Filter which ProcessedApplications to update
     */
    where?: ProcessedApplicationWhereInput
    /**
     * Limit how many ProcessedApplications to update.
     */
    limit?: number
  }

  /**
   * ProcessedApplication updateManyAndReturn
   */
  export type ProcessedApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * The data used to update ProcessedApplications.
     */
    data: XOR<ProcessedApplicationUpdateManyMutationInput, ProcessedApplicationUncheckedUpdateManyInput>
    /**
     * Filter which ProcessedApplications to update
     */
    where?: ProcessedApplicationWhereInput
    /**
     * Limit how many ProcessedApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessedApplication upsert
   */
  export type ProcessedApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessedApplication to update in case it exists.
     */
    where: ProcessedApplicationWhereUniqueInput
    /**
     * In case the ProcessedApplication found by the `where` argument doesn't exist, create a new ProcessedApplication with this data.
     */
    create: XOR<ProcessedApplicationCreateInput, ProcessedApplicationUncheckedCreateInput>
    /**
     * In case the ProcessedApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessedApplicationUpdateInput, ProcessedApplicationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication delete
   */
  export type ProcessedApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
    /**
     * Filter which ProcessedApplication to delete.
     */
    where: ProcessedApplicationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessedApplication deleteMany
   */
  export type ProcessedApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessedApplications to delete
     */
    where?: ProcessedApplicationWhereInput
    /**
     * Limit how many ProcessedApplications to delete.
     */
    limit?: number
  }

  /**
   * ProcessedApplication without action
   */
  export type ProcessedApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessedApplication
     */
    select?: ProcessedApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessedApplication
     */
    omit?: ProcessedApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessedApplicationInclude<ExtArgs> | null
  }


  /**
   * Model APCompletedForm
   */

  export type AggregateAPCompletedForm = {
    _count: APCompletedFormCountAggregateOutputType | null
    _min: APCompletedFormMinAggregateOutputType | null
    _max: APCompletedFormMaxAggregateOutputType | null
  }

  export type APCompletedFormMinAggregateOutputType = {
    id: string | null
    applicantProcessId: string | null
    formId: string | null
    reviewerId: string | null
    nextStaffId: string | null
    nextStepType: $Enums.NextStepType | null
    nextStepSpecifiedTo: string | null
    notificationType: $Enums.NextStepType | null
    notificationToId: string | null
    notificationComment: string | null
    notifyApplicant: boolean | null
    applicantNotificationContent: string | null
    editApplicationStatus: boolean | null
    applicantViewFormAfterCompletion: boolean | null
    createdAt: Date | null
  }

  export type APCompletedFormMaxAggregateOutputType = {
    id: string | null
    applicantProcessId: string | null
    formId: string | null
    reviewerId: string | null
    nextStaffId: string | null
    nextStepType: $Enums.NextStepType | null
    nextStepSpecifiedTo: string | null
    notificationType: $Enums.NextStepType | null
    notificationToId: string | null
    notificationComment: string | null
    notifyApplicant: boolean | null
    applicantNotificationContent: string | null
    editApplicationStatus: boolean | null
    applicantViewFormAfterCompletion: boolean | null
    createdAt: Date | null
  }

  export type APCompletedFormCountAggregateOutputType = {
    id: number
    applicantProcessId: number
    formId: number
    reviewerId: number
    nextStaffId: number
    nextStepType: number
    nextStepRoles: number
    nextStepSpecifiedTo: number
    notificationType: number
    notificationToId: number
    notificationToRoles: number
    notificationComment: number
    notifyApplicant: number
    applicantNotificationContent: number
    editApplicationStatus: number
    applicantViewFormAfterCompletion: number
    createdAt: number
    _all: number
  }


  export type APCompletedFormMinAggregateInputType = {
    id?: true
    applicantProcessId?: true
    formId?: true
    reviewerId?: true
    nextStaffId?: true
    nextStepType?: true
    nextStepSpecifiedTo?: true
    notificationType?: true
    notificationToId?: true
    notificationComment?: true
    notifyApplicant?: true
    applicantNotificationContent?: true
    editApplicationStatus?: true
    applicantViewFormAfterCompletion?: true
    createdAt?: true
  }

  export type APCompletedFormMaxAggregateInputType = {
    id?: true
    applicantProcessId?: true
    formId?: true
    reviewerId?: true
    nextStaffId?: true
    nextStepType?: true
    nextStepSpecifiedTo?: true
    notificationType?: true
    notificationToId?: true
    notificationComment?: true
    notifyApplicant?: true
    applicantNotificationContent?: true
    editApplicationStatus?: true
    applicantViewFormAfterCompletion?: true
    createdAt?: true
  }

  export type APCompletedFormCountAggregateInputType = {
    id?: true
    applicantProcessId?: true
    formId?: true
    reviewerId?: true
    nextStaffId?: true
    nextStepType?: true
    nextStepRoles?: true
    nextStepSpecifiedTo?: true
    notificationType?: true
    notificationToId?: true
    notificationToRoles?: true
    notificationComment?: true
    notifyApplicant?: true
    applicantNotificationContent?: true
    editApplicationStatus?: true
    applicantViewFormAfterCompletion?: true
    createdAt?: true
    _all?: true
  }

  export type APCompletedFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which APCompletedForm to aggregate.
     */
    where?: APCompletedFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APCompletedForms to fetch.
     */
    orderBy?: APCompletedFormOrderByWithRelationInput | APCompletedFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: APCompletedFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APCompletedForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APCompletedForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned APCompletedForms
    **/
    _count?: true | APCompletedFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: APCompletedFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: APCompletedFormMaxAggregateInputType
  }

  export type GetAPCompletedFormAggregateType<T extends APCompletedFormAggregateArgs> = {
        [P in keyof T & keyof AggregateAPCompletedForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAPCompletedForm[P]>
      : GetScalarType<T[P], AggregateAPCompletedForm[P]>
  }




  export type APCompletedFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: APCompletedFormWhereInput
    orderBy?: APCompletedFormOrderByWithAggregationInput | APCompletedFormOrderByWithAggregationInput[]
    by: APCompletedFormScalarFieldEnum[] | APCompletedFormScalarFieldEnum
    having?: APCompletedFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: APCompletedFormCountAggregateInputType | true
    _min?: APCompletedFormMinAggregateInputType
    _max?: APCompletedFormMaxAggregateInputType
  }

  export type APCompletedFormGroupByOutputType = {
    id: string
    applicantProcessId: string
    formId: string
    reviewerId: string | null
    nextStaffId: string | null
    nextStepType: $Enums.NextStepType
    nextStepRoles: string[]
    nextStepSpecifiedTo: string | null
    notificationType: $Enums.NextStepType
    notificationToId: string | null
    notificationToRoles: string[]
    notificationComment: string | null
    notifyApplicant: boolean
    applicantNotificationContent: string | null
    editApplicationStatus: boolean
    applicantViewFormAfterCompletion: boolean
    createdAt: Date
    _count: APCompletedFormCountAggregateOutputType | null
    _min: APCompletedFormMinAggregateOutputType | null
    _max: APCompletedFormMaxAggregateOutputType | null
  }

  type GetAPCompletedFormGroupByPayload<T extends APCompletedFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<APCompletedFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof APCompletedFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], APCompletedFormGroupByOutputType[P]>
            : GetScalarType<T[P], APCompletedFormGroupByOutputType[P]>
        }
      >
    >


  export type APCompletedFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantProcessId?: boolean
    formId?: boolean
    reviewerId?: boolean
    nextStaffId?: boolean
    nextStepType?: boolean
    nextStepRoles?: boolean
    nextStepSpecifiedTo?: boolean
    notificationType?: boolean
    notificationToId?: boolean
    notificationToRoles?: boolean
    notificationComment?: boolean
    notifyApplicant?: boolean
    applicantNotificationContent?: boolean
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aPCompletedForm"]>

  export type APCompletedFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantProcessId?: boolean
    formId?: boolean
    reviewerId?: boolean
    nextStaffId?: boolean
    nextStepType?: boolean
    nextStepRoles?: boolean
    nextStepSpecifiedTo?: boolean
    notificationType?: boolean
    notificationToId?: boolean
    notificationToRoles?: boolean
    notificationComment?: boolean
    notifyApplicant?: boolean
    applicantNotificationContent?: boolean
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aPCompletedForm"]>

  export type APCompletedFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantProcessId?: boolean
    formId?: boolean
    reviewerId?: boolean
    nextStaffId?: boolean
    nextStepType?: boolean
    nextStepRoles?: boolean
    nextStepSpecifiedTo?: boolean
    notificationType?: boolean
    notificationToId?: boolean
    notificationToRoles?: boolean
    notificationComment?: boolean
    notifyApplicant?: boolean
    applicantNotificationContent?: boolean
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aPCompletedForm"]>

  export type APCompletedFormSelectScalar = {
    id?: boolean
    applicantProcessId?: boolean
    formId?: boolean
    reviewerId?: boolean
    nextStaffId?: boolean
    nextStepType?: boolean
    nextStepRoles?: boolean
    nextStepSpecifiedTo?: boolean
    notificationType?: boolean
    notificationToId?: boolean
    notificationToRoles?: boolean
    notificationComment?: boolean
    notifyApplicant?: boolean
    applicantNotificationContent?: boolean
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: boolean
  }

  export type APCompletedFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicantProcessId" | "formId" | "reviewerId" | "nextStaffId" | "nextStepType" | "nextStepRoles" | "nextStepSpecifiedTo" | "notificationType" | "notificationToId" | "notificationToRoles" | "notificationComment" | "notifyApplicant" | "applicantNotificationContent" | "editApplicationStatus" | "applicantViewFormAfterCompletion" | "createdAt", ExtArgs["result"]["aPCompletedForm"]>
  export type APCompletedFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }
  export type APCompletedFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }
  export type APCompletedFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }

  export type $APCompletedFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "APCompletedForm"
    objects: {
      applicantProcess: Prisma.$ApplicantProcessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicantProcessId: string
      formId: string
      reviewerId: string | null
      nextStaffId: string | null
      nextStepType: $Enums.NextStepType
      nextStepRoles: string[]
      nextStepSpecifiedTo: string | null
      notificationType: $Enums.NextStepType
      notificationToId: string | null
      notificationToRoles: string[]
      notificationComment: string | null
      notifyApplicant: boolean
      applicantNotificationContent: string | null
      editApplicationStatus: boolean
      applicantViewFormAfterCompletion: boolean
      createdAt: Date
    }, ExtArgs["result"]["aPCompletedForm"]>
    composites: {}
  }

  type APCompletedFormGetPayload<S extends boolean | null | undefined | APCompletedFormDefaultArgs> = $Result.GetResult<Prisma.$APCompletedFormPayload, S>

  type APCompletedFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<APCompletedFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: APCompletedFormCountAggregateInputType | true
    }

  export interface APCompletedFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['APCompletedForm'], meta: { name: 'APCompletedForm' } }
    /**
     * Find zero or one APCompletedForm that matches the filter.
     * @param {APCompletedFormFindUniqueArgs} args - Arguments to find a APCompletedForm
     * @example
     * // Get one APCompletedForm
     * const aPCompletedForm = await prisma.aPCompletedForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends APCompletedFormFindUniqueArgs>(args: SelectSubset<T, APCompletedFormFindUniqueArgs<ExtArgs>>): Prisma__APCompletedFormClient<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one APCompletedForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {APCompletedFormFindUniqueOrThrowArgs} args - Arguments to find a APCompletedForm
     * @example
     * // Get one APCompletedForm
     * const aPCompletedForm = await prisma.aPCompletedForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends APCompletedFormFindUniqueOrThrowArgs>(args: SelectSubset<T, APCompletedFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__APCompletedFormClient<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first APCompletedForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APCompletedFormFindFirstArgs} args - Arguments to find a APCompletedForm
     * @example
     * // Get one APCompletedForm
     * const aPCompletedForm = await prisma.aPCompletedForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends APCompletedFormFindFirstArgs>(args?: SelectSubset<T, APCompletedFormFindFirstArgs<ExtArgs>>): Prisma__APCompletedFormClient<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first APCompletedForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APCompletedFormFindFirstOrThrowArgs} args - Arguments to find a APCompletedForm
     * @example
     * // Get one APCompletedForm
     * const aPCompletedForm = await prisma.aPCompletedForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends APCompletedFormFindFirstOrThrowArgs>(args?: SelectSubset<T, APCompletedFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__APCompletedFormClient<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more APCompletedForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APCompletedFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all APCompletedForms
     * const aPCompletedForms = await prisma.aPCompletedForm.findMany()
     * 
     * // Get first 10 APCompletedForms
     * const aPCompletedForms = await prisma.aPCompletedForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aPCompletedFormWithIdOnly = await prisma.aPCompletedForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends APCompletedFormFindManyArgs>(args?: SelectSubset<T, APCompletedFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a APCompletedForm.
     * @param {APCompletedFormCreateArgs} args - Arguments to create a APCompletedForm.
     * @example
     * // Create one APCompletedForm
     * const APCompletedForm = await prisma.aPCompletedForm.create({
     *   data: {
     *     // ... data to create a APCompletedForm
     *   }
     * })
     * 
     */
    create<T extends APCompletedFormCreateArgs>(args: SelectSubset<T, APCompletedFormCreateArgs<ExtArgs>>): Prisma__APCompletedFormClient<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many APCompletedForms.
     * @param {APCompletedFormCreateManyArgs} args - Arguments to create many APCompletedForms.
     * @example
     * // Create many APCompletedForms
     * const aPCompletedForm = await prisma.aPCompletedForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends APCompletedFormCreateManyArgs>(args?: SelectSubset<T, APCompletedFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many APCompletedForms and returns the data saved in the database.
     * @param {APCompletedFormCreateManyAndReturnArgs} args - Arguments to create many APCompletedForms.
     * @example
     * // Create many APCompletedForms
     * const aPCompletedForm = await prisma.aPCompletedForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many APCompletedForms and only return the `id`
     * const aPCompletedFormWithIdOnly = await prisma.aPCompletedForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends APCompletedFormCreateManyAndReturnArgs>(args?: SelectSubset<T, APCompletedFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a APCompletedForm.
     * @param {APCompletedFormDeleteArgs} args - Arguments to delete one APCompletedForm.
     * @example
     * // Delete one APCompletedForm
     * const APCompletedForm = await prisma.aPCompletedForm.delete({
     *   where: {
     *     // ... filter to delete one APCompletedForm
     *   }
     * })
     * 
     */
    delete<T extends APCompletedFormDeleteArgs>(args: SelectSubset<T, APCompletedFormDeleteArgs<ExtArgs>>): Prisma__APCompletedFormClient<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one APCompletedForm.
     * @param {APCompletedFormUpdateArgs} args - Arguments to update one APCompletedForm.
     * @example
     * // Update one APCompletedForm
     * const aPCompletedForm = await prisma.aPCompletedForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends APCompletedFormUpdateArgs>(args: SelectSubset<T, APCompletedFormUpdateArgs<ExtArgs>>): Prisma__APCompletedFormClient<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more APCompletedForms.
     * @param {APCompletedFormDeleteManyArgs} args - Arguments to filter APCompletedForms to delete.
     * @example
     * // Delete a few APCompletedForms
     * const { count } = await prisma.aPCompletedForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends APCompletedFormDeleteManyArgs>(args?: SelectSubset<T, APCompletedFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more APCompletedForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APCompletedFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many APCompletedForms
     * const aPCompletedForm = await prisma.aPCompletedForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends APCompletedFormUpdateManyArgs>(args: SelectSubset<T, APCompletedFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more APCompletedForms and returns the data updated in the database.
     * @param {APCompletedFormUpdateManyAndReturnArgs} args - Arguments to update many APCompletedForms.
     * @example
     * // Update many APCompletedForms
     * const aPCompletedForm = await prisma.aPCompletedForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more APCompletedForms and only return the `id`
     * const aPCompletedFormWithIdOnly = await prisma.aPCompletedForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends APCompletedFormUpdateManyAndReturnArgs>(args: SelectSubset<T, APCompletedFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one APCompletedForm.
     * @param {APCompletedFormUpsertArgs} args - Arguments to update or create a APCompletedForm.
     * @example
     * // Update or create a APCompletedForm
     * const aPCompletedForm = await prisma.aPCompletedForm.upsert({
     *   create: {
     *     // ... data to create a APCompletedForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the APCompletedForm we want to update
     *   }
     * })
     */
    upsert<T extends APCompletedFormUpsertArgs>(args: SelectSubset<T, APCompletedFormUpsertArgs<ExtArgs>>): Prisma__APCompletedFormClient<$Result.GetResult<Prisma.$APCompletedFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of APCompletedForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APCompletedFormCountArgs} args - Arguments to filter APCompletedForms to count.
     * @example
     * // Count the number of APCompletedForms
     * const count = await prisma.aPCompletedForm.count({
     *   where: {
     *     // ... the filter for the APCompletedForms we want to count
     *   }
     * })
    **/
    count<T extends APCompletedFormCountArgs>(
      args?: Subset<T, APCompletedFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], APCompletedFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a APCompletedForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APCompletedFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends APCompletedFormAggregateArgs>(args: Subset<T, APCompletedFormAggregateArgs>): Prisma.PrismaPromise<GetAPCompletedFormAggregateType<T>>

    /**
     * Group by APCompletedForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {APCompletedFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends APCompletedFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: APCompletedFormGroupByArgs['orderBy'] }
        : { orderBy?: APCompletedFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, APCompletedFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAPCompletedFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the APCompletedForm model
   */
  readonly fields: APCompletedFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for APCompletedForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__APCompletedFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicantProcess<T extends ApplicantProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantProcessDefaultArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the APCompletedForm model
   */
  interface APCompletedFormFieldRefs {
    readonly id: FieldRef<"APCompletedForm", 'String'>
    readonly applicantProcessId: FieldRef<"APCompletedForm", 'String'>
    readonly formId: FieldRef<"APCompletedForm", 'String'>
    readonly reviewerId: FieldRef<"APCompletedForm", 'String'>
    readonly nextStaffId: FieldRef<"APCompletedForm", 'String'>
    readonly nextStepType: FieldRef<"APCompletedForm", 'NextStepType'>
    readonly nextStepRoles: FieldRef<"APCompletedForm", 'String[]'>
    readonly nextStepSpecifiedTo: FieldRef<"APCompletedForm", 'String'>
    readonly notificationType: FieldRef<"APCompletedForm", 'NextStepType'>
    readonly notificationToId: FieldRef<"APCompletedForm", 'String'>
    readonly notificationToRoles: FieldRef<"APCompletedForm", 'String[]'>
    readonly notificationComment: FieldRef<"APCompletedForm", 'String'>
    readonly notifyApplicant: FieldRef<"APCompletedForm", 'Boolean'>
    readonly applicantNotificationContent: FieldRef<"APCompletedForm", 'String'>
    readonly editApplicationStatus: FieldRef<"APCompletedForm", 'Boolean'>
    readonly applicantViewFormAfterCompletion: FieldRef<"APCompletedForm", 'Boolean'>
    readonly createdAt: FieldRef<"APCompletedForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * APCompletedForm findUnique
   */
  export type APCompletedFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * Filter, which APCompletedForm to fetch.
     */
    where: APCompletedFormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm findUniqueOrThrow
   */
  export type APCompletedFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * Filter, which APCompletedForm to fetch.
     */
    where: APCompletedFormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm findFirst
   */
  export type APCompletedFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * Filter, which APCompletedForm to fetch.
     */
    where?: APCompletedFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APCompletedForms to fetch.
     */
    orderBy?: APCompletedFormOrderByWithRelationInput | APCompletedFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for APCompletedForms.
     */
    cursor?: APCompletedFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APCompletedForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APCompletedForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of APCompletedForms.
     */
    distinct?: APCompletedFormScalarFieldEnum | APCompletedFormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm findFirstOrThrow
   */
  export type APCompletedFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * Filter, which APCompletedForm to fetch.
     */
    where?: APCompletedFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APCompletedForms to fetch.
     */
    orderBy?: APCompletedFormOrderByWithRelationInput | APCompletedFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for APCompletedForms.
     */
    cursor?: APCompletedFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APCompletedForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APCompletedForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of APCompletedForms.
     */
    distinct?: APCompletedFormScalarFieldEnum | APCompletedFormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm findMany
   */
  export type APCompletedFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * Filter, which APCompletedForms to fetch.
     */
    where?: APCompletedFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of APCompletedForms to fetch.
     */
    orderBy?: APCompletedFormOrderByWithRelationInput | APCompletedFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing APCompletedForms.
     */
    cursor?: APCompletedFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` APCompletedForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` APCompletedForms.
     */
    skip?: number
    distinct?: APCompletedFormScalarFieldEnum | APCompletedFormScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm create
   */
  export type APCompletedFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * The data needed to create a APCompletedForm.
     */
    data: XOR<APCompletedFormCreateInput, APCompletedFormUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm createMany
   */
  export type APCompletedFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many APCompletedForms.
     */
    data: APCompletedFormCreateManyInput | APCompletedFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * APCompletedForm createManyAndReturn
   */
  export type APCompletedFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * The data used to create many APCompletedForms.
     */
    data: APCompletedFormCreateManyInput | APCompletedFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * APCompletedForm update
   */
  export type APCompletedFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * The data needed to update a APCompletedForm.
     */
    data: XOR<APCompletedFormUpdateInput, APCompletedFormUncheckedUpdateInput>
    /**
     * Choose, which APCompletedForm to update.
     */
    where: APCompletedFormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm updateMany
   */
  export type APCompletedFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update APCompletedForms.
     */
    data: XOR<APCompletedFormUpdateManyMutationInput, APCompletedFormUncheckedUpdateManyInput>
    /**
     * Filter which APCompletedForms to update
     */
    where?: APCompletedFormWhereInput
    /**
     * Limit how many APCompletedForms to update.
     */
    limit?: number
  }

  /**
   * APCompletedForm updateManyAndReturn
   */
  export type APCompletedFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * The data used to update APCompletedForms.
     */
    data: XOR<APCompletedFormUpdateManyMutationInput, APCompletedFormUncheckedUpdateManyInput>
    /**
     * Filter which APCompletedForms to update
     */
    where?: APCompletedFormWhereInput
    /**
     * Limit how many APCompletedForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * APCompletedForm upsert
   */
  export type APCompletedFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * The filter to search for the APCompletedForm to update in case it exists.
     */
    where: APCompletedFormWhereUniqueInput
    /**
     * In case the APCompletedForm found by the `where` argument doesn't exist, create a new APCompletedForm with this data.
     */
    create: XOR<APCompletedFormCreateInput, APCompletedFormUncheckedCreateInput>
    /**
     * In case the APCompletedForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<APCompletedFormUpdateInput, APCompletedFormUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm delete
   */
  export type APCompletedFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
    /**
     * Filter which APCompletedForm to delete.
     */
    where: APCompletedFormWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * APCompletedForm deleteMany
   */
  export type APCompletedFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which APCompletedForms to delete
     */
    where?: APCompletedFormWhereInput
    /**
     * Limit how many APCompletedForms to delete.
     */
    limit?: number
  }

  /**
   * APCompletedForm without action
   */
  export type APCompletedFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the APCompletedForm
     */
    select?: APCompletedFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the APCompletedForm
     */
    omit?: APCompletedFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: APCompletedFormInclude<ExtArgs> | null
  }


  /**
   * Model ProcessComment
   */

  export type AggregateProcessComment = {
    _count: ProcessCommentCountAggregateOutputType | null
    _min: ProcessCommentMinAggregateOutputType | null
    _max: ProcessCommentMaxAggregateOutputType | null
  }

  export type ProcessCommentMinAggregateOutputType = {
    id: string | null
    applicantProcessId: string | null
    userId: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type ProcessCommentMaxAggregateOutputType = {
    id: string | null
    applicantProcessId: string | null
    userId: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type ProcessCommentCountAggregateOutputType = {
    id: number
    applicantProcessId: number
    userId: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ProcessCommentMinAggregateInputType = {
    id?: true
    applicantProcessId?: true
    userId?: true
    comment?: true
    createdAt?: true
  }

  export type ProcessCommentMaxAggregateInputType = {
    id?: true
    applicantProcessId?: true
    userId?: true
    comment?: true
    createdAt?: true
  }

  export type ProcessCommentCountAggregateInputType = {
    id?: true
    applicantProcessId?: true
    userId?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ProcessCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessComment to aggregate.
     */
    where?: ProcessCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessComments to fetch.
     */
    orderBy?: ProcessCommentOrderByWithRelationInput | ProcessCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessComments
    **/
    _count?: true | ProcessCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessCommentMaxAggregateInputType
  }

  export type GetProcessCommentAggregateType<T extends ProcessCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessComment[P]>
      : GetScalarType<T[P], AggregateProcessComment[P]>
  }




  export type ProcessCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessCommentWhereInput
    orderBy?: ProcessCommentOrderByWithAggregationInput | ProcessCommentOrderByWithAggregationInput[]
    by: ProcessCommentScalarFieldEnum[] | ProcessCommentScalarFieldEnum
    having?: ProcessCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessCommentCountAggregateInputType | true
    _min?: ProcessCommentMinAggregateInputType
    _max?: ProcessCommentMaxAggregateInputType
  }

  export type ProcessCommentGroupByOutputType = {
    id: string
    applicantProcessId: string
    userId: string
    comment: string
    createdAt: Date
    _count: ProcessCommentCountAggregateOutputType | null
    _min: ProcessCommentMinAggregateOutputType | null
    _max: ProcessCommentMaxAggregateOutputType | null
  }

  type GetProcessCommentGroupByPayload<T extends ProcessCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessCommentGroupByOutputType[P]>
        }
      >
    >


  export type ProcessCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantProcessId?: boolean
    userId?: boolean
    comment?: boolean
    createdAt?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processComment"]>

  export type ProcessCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantProcessId?: boolean
    userId?: boolean
    comment?: boolean
    createdAt?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processComment"]>

  export type ProcessCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicantProcessId?: boolean
    userId?: boolean
    comment?: boolean
    createdAt?: boolean
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["processComment"]>

  export type ProcessCommentSelectScalar = {
    id?: boolean
    applicantProcessId?: boolean
    userId?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type ProcessCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicantProcessId" | "userId" | "comment" | "createdAt", ExtArgs["result"]["processComment"]>
  export type ProcessCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }
  export type ProcessCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }
  export type ProcessCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicantProcess?: boolean | ApplicantProcessDefaultArgs<ExtArgs>
  }

  export type $ProcessCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessComment"
    objects: {
      applicantProcess: Prisma.$ApplicantProcessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicantProcessId: string
      userId: string
      comment: string
      createdAt: Date
    }, ExtArgs["result"]["processComment"]>
    composites: {}
  }

  type ProcessCommentGetPayload<S extends boolean | null | undefined | ProcessCommentDefaultArgs> = $Result.GetResult<Prisma.$ProcessCommentPayload, S>

  type ProcessCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProcessCommentCountAggregateInputType | true
    }

  export interface ProcessCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessComment'], meta: { name: 'ProcessComment' } }
    /**
     * Find zero or one ProcessComment that matches the filter.
     * @param {ProcessCommentFindUniqueArgs} args - Arguments to find a ProcessComment
     * @example
     * // Get one ProcessComment
     * const processComment = await prisma.processComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessCommentFindUniqueArgs>(args: SelectSubset<T, ProcessCommentFindUniqueArgs<ExtArgs>>): Prisma__ProcessCommentClient<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessCommentFindUniqueOrThrowArgs} args - Arguments to find a ProcessComment
     * @example
     * // Get one ProcessComment
     * const processComment = await prisma.processComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessCommentClient<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCommentFindFirstArgs} args - Arguments to find a ProcessComment
     * @example
     * // Get one ProcessComment
     * const processComment = await prisma.processComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessCommentFindFirstArgs>(args?: SelectSubset<T, ProcessCommentFindFirstArgs<ExtArgs>>): Prisma__ProcessCommentClient<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCommentFindFirstOrThrowArgs} args - Arguments to find a ProcessComment
     * @example
     * // Get one ProcessComment
     * const processComment = await prisma.processComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessCommentClient<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessComments
     * const processComments = await prisma.processComment.findMany()
     * 
     * // Get first 10 ProcessComments
     * const processComments = await prisma.processComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processCommentWithIdOnly = await prisma.processComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessCommentFindManyArgs>(args?: SelectSubset<T, ProcessCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessComment.
     * @param {ProcessCommentCreateArgs} args - Arguments to create a ProcessComment.
     * @example
     * // Create one ProcessComment
     * const ProcessComment = await prisma.processComment.create({
     *   data: {
     *     // ... data to create a ProcessComment
     *   }
     * })
     * 
     */
    create<T extends ProcessCommentCreateArgs>(args: SelectSubset<T, ProcessCommentCreateArgs<ExtArgs>>): Prisma__ProcessCommentClient<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessComments.
     * @param {ProcessCommentCreateManyArgs} args - Arguments to create many ProcessComments.
     * @example
     * // Create many ProcessComments
     * const processComment = await prisma.processComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessCommentCreateManyArgs>(args?: SelectSubset<T, ProcessCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessComments and returns the data saved in the database.
     * @param {ProcessCommentCreateManyAndReturnArgs} args - Arguments to create many ProcessComments.
     * @example
     * // Create many ProcessComments
     * const processComment = await prisma.processComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessComments and only return the `id`
     * const processCommentWithIdOnly = await prisma.processComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcessComment.
     * @param {ProcessCommentDeleteArgs} args - Arguments to delete one ProcessComment.
     * @example
     * // Delete one ProcessComment
     * const ProcessComment = await prisma.processComment.delete({
     *   where: {
     *     // ... filter to delete one ProcessComment
     *   }
     * })
     * 
     */
    delete<T extends ProcessCommentDeleteArgs>(args: SelectSubset<T, ProcessCommentDeleteArgs<ExtArgs>>): Prisma__ProcessCommentClient<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessComment.
     * @param {ProcessCommentUpdateArgs} args - Arguments to update one ProcessComment.
     * @example
     * // Update one ProcessComment
     * const processComment = await prisma.processComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessCommentUpdateArgs>(args: SelectSubset<T, ProcessCommentUpdateArgs<ExtArgs>>): Prisma__ProcessCommentClient<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessComments.
     * @param {ProcessCommentDeleteManyArgs} args - Arguments to filter ProcessComments to delete.
     * @example
     * // Delete a few ProcessComments
     * const { count } = await prisma.processComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessCommentDeleteManyArgs>(args?: SelectSubset<T, ProcessCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessComments
     * const processComment = await prisma.processComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessCommentUpdateManyArgs>(args: SelectSubset<T, ProcessCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessComments and returns the data updated in the database.
     * @param {ProcessCommentUpdateManyAndReturnArgs} args - Arguments to update many ProcessComments.
     * @example
     * // Update many ProcessComments
     * const processComment = await prisma.processComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcessComments and only return the `id`
     * const processCommentWithIdOnly = await prisma.processComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcessComment.
     * @param {ProcessCommentUpsertArgs} args - Arguments to update or create a ProcessComment.
     * @example
     * // Update or create a ProcessComment
     * const processComment = await prisma.processComment.upsert({
     *   create: {
     *     // ... data to create a ProcessComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessComment we want to update
     *   }
     * })
     */
    upsert<T extends ProcessCommentUpsertArgs>(args: SelectSubset<T, ProcessCommentUpsertArgs<ExtArgs>>): Prisma__ProcessCommentClient<$Result.GetResult<Prisma.$ProcessCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcessComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCommentCountArgs} args - Arguments to filter ProcessComments to count.
     * @example
     * // Count the number of ProcessComments
     * const count = await prisma.processComment.count({
     *   where: {
     *     // ... the filter for the ProcessComments we want to count
     *   }
     * })
    **/
    count<T extends ProcessCommentCountArgs>(
      args?: Subset<T, ProcessCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessCommentAggregateArgs>(args: Subset<T, ProcessCommentAggregateArgs>): Prisma.PrismaPromise<GetProcessCommentAggregateType<T>>

    /**
     * Group by ProcessComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessCommentGroupByArgs['orderBy'] }
        : { orderBy?: ProcessCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessComment model
   */
  readonly fields: ProcessCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicantProcess<T extends ApplicantProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicantProcessDefaultArgs<ExtArgs>>): Prisma__ApplicantProcessClient<$Result.GetResult<Prisma.$ApplicantProcessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessComment model
   */
  interface ProcessCommentFieldRefs {
    readonly id: FieldRef<"ProcessComment", 'String'>
    readonly applicantProcessId: FieldRef<"ProcessComment", 'String'>
    readonly userId: FieldRef<"ProcessComment", 'String'>
    readonly comment: FieldRef<"ProcessComment", 'String'>
    readonly createdAt: FieldRef<"ProcessComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProcessComment findUnique
   */
  export type ProcessCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProcessComment to fetch.
     */
    where: ProcessCommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment findUniqueOrThrow
   */
  export type ProcessCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProcessComment to fetch.
     */
    where: ProcessCommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment findFirst
   */
  export type ProcessCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProcessComment to fetch.
     */
    where?: ProcessCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessComments to fetch.
     */
    orderBy?: ProcessCommentOrderByWithRelationInput | ProcessCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessComments.
     */
    cursor?: ProcessCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessComments.
     */
    distinct?: ProcessCommentScalarFieldEnum | ProcessCommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment findFirstOrThrow
   */
  export type ProcessCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProcessComment to fetch.
     */
    where?: ProcessCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessComments to fetch.
     */
    orderBy?: ProcessCommentOrderByWithRelationInput | ProcessCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessComments.
     */
    cursor?: ProcessCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessComments.
     */
    distinct?: ProcessCommentScalarFieldEnum | ProcessCommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment findMany
   */
  export type ProcessCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProcessComments to fetch.
     */
    where?: ProcessCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessComments to fetch.
     */
    orderBy?: ProcessCommentOrderByWithRelationInput | ProcessCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessComments.
     */
    cursor?: ProcessCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessComments.
     */
    skip?: number
    distinct?: ProcessCommentScalarFieldEnum | ProcessCommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment create
   */
  export type ProcessCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcessComment.
     */
    data: XOR<ProcessCommentCreateInput, ProcessCommentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment createMany
   */
  export type ProcessCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessComments.
     */
    data: ProcessCommentCreateManyInput | ProcessCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessComment createManyAndReturn
   */
  export type ProcessCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * The data used to create many ProcessComments.
     */
    data: ProcessCommentCreateManyInput | ProcessCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessComment update
   */
  export type ProcessCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcessComment.
     */
    data: XOR<ProcessCommentUpdateInput, ProcessCommentUncheckedUpdateInput>
    /**
     * Choose, which ProcessComment to update.
     */
    where: ProcessCommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment updateMany
   */
  export type ProcessCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessComments.
     */
    data: XOR<ProcessCommentUpdateManyMutationInput, ProcessCommentUncheckedUpdateManyInput>
    /**
     * Filter which ProcessComments to update
     */
    where?: ProcessCommentWhereInput
    /**
     * Limit how many ProcessComments to update.
     */
    limit?: number
  }

  /**
   * ProcessComment updateManyAndReturn
   */
  export type ProcessCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * The data used to update ProcessComments.
     */
    data: XOR<ProcessCommentUpdateManyMutationInput, ProcessCommentUncheckedUpdateManyInput>
    /**
     * Filter which ProcessComments to update
     */
    where?: ProcessCommentWhereInput
    /**
     * Limit how many ProcessComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcessComment upsert
   */
  export type ProcessCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcessComment to update in case it exists.
     */
    where: ProcessCommentWhereUniqueInput
    /**
     * In case the ProcessComment found by the `where` argument doesn't exist, create a new ProcessComment with this data.
     */
    create: XOR<ProcessCommentCreateInput, ProcessCommentUncheckedCreateInput>
    /**
     * In case the ProcessComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessCommentUpdateInput, ProcessCommentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment delete
   */
  export type ProcessCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
    /**
     * Filter which ProcessComment to delete.
     */
    where: ProcessCommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessComment deleteMany
   */
  export type ProcessCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessComments to delete
     */
    where?: ProcessCommentWhereInput
    /**
     * Limit how many ProcessComments to delete.
     */
    limit?: number
  }

  /**
   * ProcessComment without action
   */
  export type ProcessCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessComment
     */
    select?: ProcessCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessComment
     */
    omit?: ProcessCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessCommentInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationUser
   */

  export type AggregateOrganizationUser = {
    _count: OrganizationUserCountAggregateOutputType | null
    _min: OrganizationUserMinAggregateOutputType | null
    _max: OrganizationUserMaxAggregateOutputType | null
  }

  export type OrganizationUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    superiorId: string | null
    title: string | null
  }

  export type OrganizationUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    superiorId: string | null
    title: string | null
  }

  export type OrganizationUserCountAggregateOutputType = {
    id: number
    userId: number
    superiorId: number
    title: number
    _all: number
  }


  export type OrganizationUserMinAggregateInputType = {
    id?: true
    userId?: true
    superiorId?: true
    title?: true
  }

  export type OrganizationUserMaxAggregateInputType = {
    id?: true
    userId?: true
    superiorId?: true
    title?: true
  }

  export type OrganizationUserCountAggregateInputType = {
    id?: true
    userId?: true
    superiorId?: true
    title?: true
    _all?: true
  }

  export type OrganizationUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationUser to aggregate.
     */
    where?: OrganizationUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationUsers to fetch.
     */
    orderBy?: OrganizationUserOrderByWithRelationInput | OrganizationUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationUsers
    **/
    _count?: true | OrganizationUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationUserMaxAggregateInputType
  }

  export type GetOrganizationUserAggregateType<T extends OrganizationUserAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationUser[P]>
      : GetScalarType<T[P], AggregateOrganizationUser[P]>
  }




  export type OrganizationUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationUserWhereInput
    orderBy?: OrganizationUserOrderByWithAggregationInput | OrganizationUserOrderByWithAggregationInput[]
    by: OrganizationUserScalarFieldEnum[] | OrganizationUserScalarFieldEnum
    having?: OrganizationUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationUserCountAggregateInputType | true
    _min?: OrganizationUserMinAggregateInputType
    _max?: OrganizationUserMaxAggregateInputType
  }

  export type OrganizationUserGroupByOutputType = {
    id: string
    userId: string
    superiorId: string | null
    title: string
    _count: OrganizationUserCountAggregateOutputType | null
    _min: OrganizationUserMinAggregateOutputType | null
    _max: OrganizationUserMaxAggregateOutputType | null
  }

  type GetOrganizationUserGroupByPayload<T extends OrganizationUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationUserGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationUserGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    superiorId?: boolean
    title?: boolean
    superior?: boolean | OrganizationUser$superiorArgs<ExtArgs>
    subordinates?: boolean | OrganizationUser$subordinatesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrganizationUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationUser"]>

  export type OrganizationUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    superiorId?: boolean
    title?: boolean
    superior?: boolean | OrganizationUser$superiorArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationUser"]>

  export type OrganizationUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    superiorId?: boolean
    title?: boolean
    superior?: boolean | OrganizationUser$superiorArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationUser"]>

  export type OrganizationUserSelectScalar = {
    id?: boolean
    userId?: boolean
    superiorId?: boolean
    title?: boolean
  }

  export type OrganizationUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "superiorId" | "title", ExtArgs["result"]["organizationUser"]>
  export type OrganizationUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superior?: boolean | OrganizationUser$superiorArgs<ExtArgs>
    subordinates?: boolean | OrganizationUser$subordinatesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrganizationUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superior?: boolean | OrganizationUser$superiorArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    superior?: boolean | OrganizationUser$superiorArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationUser"
    objects: {
      superior: Prisma.$OrganizationUserPayload<ExtArgs> | null
      subordinates: Prisma.$OrganizationUserPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      superiorId: string | null
      title: string
    }, ExtArgs["result"]["organizationUser"]>
    composites: {}
  }

  type OrganizationUserGetPayload<S extends boolean | null | undefined | OrganizationUserDefaultArgs> = $Result.GetResult<Prisma.$OrganizationUserPayload, S>

  type OrganizationUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: OrganizationUserCountAggregateInputType | true
    }

  export interface OrganizationUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationUser'], meta: { name: 'OrganizationUser' } }
    /**
     * Find zero or one OrganizationUser that matches the filter.
     * @param {OrganizationUserFindUniqueArgs} args - Arguments to find a OrganizationUser
     * @example
     * // Get one OrganizationUser
     * const organizationUser = await prisma.organizationUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationUserFindUniqueArgs>(args: SelectSubset<T, OrganizationUserFindUniqueArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationUserFindUniqueOrThrowArgs} args - Arguments to find a OrganizationUser
     * @example
     * // Get one OrganizationUser
     * const organizationUser = await prisma.organizationUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationUserFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserFindFirstArgs} args - Arguments to find a OrganizationUser
     * @example
     * // Get one OrganizationUser
     * const organizationUser = await prisma.organizationUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationUserFindFirstArgs>(args?: SelectSubset<T, OrganizationUserFindFirstArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserFindFirstOrThrowArgs} args - Arguments to find a OrganizationUser
     * @example
     * // Get one OrganizationUser
     * const organizationUser = await prisma.organizationUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationUserFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationUsers
     * const organizationUsers = await prisma.organizationUser.findMany()
     * 
     * // Get first 10 OrganizationUsers
     * const organizationUsers = await prisma.organizationUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationUserWithIdOnly = await prisma.organizationUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationUserFindManyArgs>(args?: SelectSubset<T, OrganizationUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationUser.
     * @param {OrganizationUserCreateArgs} args - Arguments to create a OrganizationUser.
     * @example
     * // Create one OrganizationUser
     * const OrganizationUser = await prisma.organizationUser.create({
     *   data: {
     *     // ... data to create a OrganizationUser
     *   }
     * })
     * 
     */
    create<T extends OrganizationUserCreateArgs>(args: SelectSubset<T, OrganizationUserCreateArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationUsers.
     * @param {OrganizationUserCreateManyArgs} args - Arguments to create many OrganizationUsers.
     * @example
     * // Create many OrganizationUsers
     * const organizationUser = await prisma.organizationUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationUserCreateManyArgs>(args?: SelectSubset<T, OrganizationUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationUsers and returns the data saved in the database.
     * @param {OrganizationUserCreateManyAndReturnArgs} args - Arguments to create many OrganizationUsers.
     * @example
     * // Create many OrganizationUsers
     * const organizationUser = await prisma.organizationUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationUsers and only return the `id`
     * const organizationUserWithIdOnly = await prisma.organizationUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationUserCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationUser.
     * @param {OrganizationUserDeleteArgs} args - Arguments to delete one OrganizationUser.
     * @example
     * // Delete one OrganizationUser
     * const OrganizationUser = await prisma.organizationUser.delete({
     *   where: {
     *     // ... filter to delete one OrganizationUser
     *   }
     * })
     * 
     */
    delete<T extends OrganizationUserDeleteArgs>(args: SelectSubset<T, OrganizationUserDeleteArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationUser.
     * @param {OrganizationUserUpdateArgs} args - Arguments to update one OrganizationUser.
     * @example
     * // Update one OrganizationUser
     * const organizationUser = await prisma.organizationUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUserUpdateArgs>(args: SelectSubset<T, OrganizationUserUpdateArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationUsers.
     * @param {OrganizationUserDeleteManyArgs} args - Arguments to filter OrganizationUsers to delete.
     * @example
     * // Delete a few OrganizationUsers
     * const { count } = await prisma.organizationUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationUserDeleteManyArgs>(args?: SelectSubset<T, OrganizationUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationUsers
     * const organizationUser = await prisma.organizationUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUserUpdateManyArgs>(args: SelectSubset<T, OrganizationUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationUsers and returns the data updated in the database.
     * @param {OrganizationUserUpdateManyAndReturnArgs} args - Arguments to update many OrganizationUsers.
     * @example
     * // Update many OrganizationUsers
     * const organizationUser = await prisma.organizationUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationUsers and only return the `id`
     * const organizationUserWithIdOnly = await prisma.organizationUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUserUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationUser.
     * @param {OrganizationUserUpsertArgs} args - Arguments to update or create a OrganizationUser.
     * @example
     * // Update or create a OrganizationUser
     * const organizationUser = await prisma.organizationUser.upsert({
     *   create: {
     *     // ... data to create a OrganizationUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationUser we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUserUpsertArgs>(args: SelectSubset<T, OrganizationUserUpsertArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserCountArgs} args - Arguments to filter OrganizationUsers to count.
     * @example
     * // Count the number of OrganizationUsers
     * const count = await prisma.organizationUser.count({
     *   where: {
     *     // ... the filter for the OrganizationUsers we want to count
     *   }
     * })
    **/
    count<T extends OrganizationUserCountArgs>(
      args?: Subset<T, OrganizationUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationUserAggregateArgs>(args: Subset<T, OrganizationUserAggregateArgs>): Prisma.PrismaPromise<GetOrganizationUserAggregateType<T>>

    /**
     * Group by OrganizationUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationUserGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationUser model
   */
  readonly fields: OrganizationUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    superior<T extends OrganizationUser$superiorArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationUser$superiorArgs<ExtArgs>>): Prisma__OrganizationUserClient<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subordinates<T extends OrganizationUser$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationUser$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationUser model
   */
  interface OrganizationUserFieldRefs {
    readonly id: FieldRef<"OrganizationUser", 'String'>
    readonly userId: FieldRef<"OrganizationUser", 'String'>
    readonly superiorId: FieldRef<"OrganizationUser", 'String'>
    readonly title: FieldRef<"OrganizationUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationUser findUnique
   */
  export type OrganizationUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUser to fetch.
     */
    where: OrganizationUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser findUniqueOrThrow
   */
  export type OrganizationUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUser to fetch.
     */
    where: OrganizationUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser findFirst
   */
  export type OrganizationUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUser to fetch.
     */
    where?: OrganizationUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationUsers to fetch.
     */
    orderBy?: OrganizationUserOrderByWithRelationInput | OrganizationUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationUsers.
     */
    cursor?: OrganizationUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationUsers.
     */
    distinct?: OrganizationUserScalarFieldEnum | OrganizationUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser findFirstOrThrow
   */
  export type OrganizationUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUser to fetch.
     */
    where?: OrganizationUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationUsers to fetch.
     */
    orderBy?: OrganizationUserOrderByWithRelationInput | OrganizationUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationUsers.
     */
    cursor?: OrganizationUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationUsers.
     */
    distinct?: OrganizationUserScalarFieldEnum | OrganizationUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser findMany
   */
  export type OrganizationUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationUsers to fetch.
     */
    where?: OrganizationUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationUsers to fetch.
     */
    orderBy?: OrganizationUserOrderByWithRelationInput | OrganizationUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationUsers.
     */
    cursor?: OrganizationUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationUsers.
     */
    skip?: number
    distinct?: OrganizationUserScalarFieldEnum | OrganizationUserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser create
   */
  export type OrganizationUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationUser.
     */
    data: XOR<OrganizationUserCreateInput, OrganizationUserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser createMany
   */
  export type OrganizationUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationUsers.
     */
    data: OrganizationUserCreateManyInput | OrganizationUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationUser createManyAndReturn
   */
  export type OrganizationUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationUsers.
     */
    data: OrganizationUserCreateManyInput | OrganizationUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationUser update
   */
  export type OrganizationUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationUser.
     */
    data: XOR<OrganizationUserUpdateInput, OrganizationUserUncheckedUpdateInput>
    /**
     * Choose, which OrganizationUser to update.
     */
    where: OrganizationUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser updateMany
   */
  export type OrganizationUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationUsers.
     */
    data: XOR<OrganizationUserUpdateManyMutationInput, OrganizationUserUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationUsers to update
     */
    where?: OrganizationUserWhereInput
    /**
     * Limit how many OrganizationUsers to update.
     */
    limit?: number
  }

  /**
   * OrganizationUser updateManyAndReturn
   */
  export type OrganizationUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationUsers.
     */
    data: XOR<OrganizationUserUpdateManyMutationInput, OrganizationUserUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationUsers to update
     */
    where?: OrganizationUserWhereInput
    /**
     * Limit how many OrganizationUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationUser upsert
   */
  export type OrganizationUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationUser to update in case it exists.
     */
    where: OrganizationUserWhereUniqueInput
    /**
     * In case the OrganizationUser found by the `where` argument doesn't exist, create a new OrganizationUser with this data.
     */
    create: XOR<OrganizationUserCreateInput, OrganizationUserUncheckedCreateInput>
    /**
     * In case the OrganizationUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUserUpdateInput, OrganizationUserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser delete
   */
  export type OrganizationUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    /**
     * Filter which OrganizationUser to delete.
     */
    where: OrganizationUserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OrganizationUser deleteMany
   */
  export type OrganizationUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationUsers to delete
     */
    where?: OrganizationUserWhereInput
    /**
     * Limit how many OrganizationUsers to delete.
     */
    limit?: number
  }

  /**
   * OrganizationUser.superior
   */
  export type OrganizationUser$superiorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    where?: OrganizationUserWhereInput
  }

  /**
   * OrganizationUser.subordinates
   */
  export type OrganizationUser$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
    where?: OrganizationUserWhereInput
    orderBy?: OrganizationUserOrderByWithRelationInput | OrganizationUserOrderByWithRelationInput[]
    cursor?: OrganizationUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationUserScalarFieldEnum | OrganizationUserScalarFieldEnum[]
  }

  /**
   * OrganizationUser without action
   */
  export type OrganizationUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationUser
     */
    select?: OrganizationUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationUser
     */
    omit?: OrganizationUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationUserInclude<ExtArgs> | null
  }


  /**
   * Model Dashboard
   */

  export type AggregateDashboard = {
    _count: DashboardCountAggregateOutputType | null
    _min: DashboardMinAggregateOutputType | null
    _max: DashboardMaxAggregateOutputType | null
  }

  export type DashboardMinAggregateOutputType = {
    id: string | null
    name: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardCountAggregateOutputType = {
    id: number
    name: number
    ownerId: number
    allowedUsers: number
    allowedRoles: number
    layout: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DashboardMinAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardMaxAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardCountAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    allowedUsers?: true
    allowedRoles?: true
    layout?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DashboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboard to aggregate.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dashboards
    **/
    _count?: true | DashboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardMaxAggregateInputType
  }

  export type GetDashboardAggregateType<T extends DashboardAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboard[P]>
      : GetScalarType<T[P], AggregateDashboard[P]>
  }




  export type DashboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardWhereInput
    orderBy?: DashboardOrderByWithAggregationInput | DashboardOrderByWithAggregationInput[]
    by: DashboardScalarFieldEnum[] | DashboardScalarFieldEnum
    having?: DashboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardCountAggregateInputType | true
    _min?: DashboardMinAggregateInputType
    _max?: DashboardMaxAggregateInputType
  }

  export type DashboardGroupByOutputType = {
    id: string
    name: string
    ownerId: string
    allowedUsers: string[]
    allowedRoles: string[]
    layout: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DashboardCountAggregateOutputType | null
    _min: DashboardMinAggregateOutputType | null
    _max: DashboardMaxAggregateOutputType | null
  }

  type GetDashboardGroupByPayload<T extends DashboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardGroupByOutputType[P]>
        }
      >
    >


  export type DashboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    allowedUsers?: boolean
    allowedRoles?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    widgets?: boolean | Dashboard$widgetsArgs<ExtArgs>
    _count?: boolean | DashboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    allowedUsers?: boolean
    allowedRoles?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    allowedUsers?: boolean
    allowedRoles?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dashboard"]>

  export type DashboardSelectScalar = {
    id?: boolean
    name?: boolean
    ownerId?: boolean
    allowedUsers?: boolean
    allowedRoles?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DashboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "ownerId" | "allowedUsers" | "allowedRoles" | "layout" | "createdAt" | "updatedAt", ExtArgs["result"]["dashboard"]>
  export type DashboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    widgets?: boolean | Dashboard$widgetsArgs<ExtArgs>
    _count?: boolean | DashboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DashboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DashboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DashboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dashboard"
    objects: {
      widgets: Prisma.$WidgetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ownerId: string
      allowedUsers: string[]
      allowedRoles: string[]
      layout: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dashboard"]>
    composites: {}
  }

  type DashboardGetPayload<S extends boolean | null | undefined | DashboardDefaultArgs> = $Result.GetResult<Prisma.$DashboardPayload, S>

  type DashboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DashboardCountAggregateInputType | true
    }

  export interface DashboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dashboard'], meta: { name: 'Dashboard' } }
    /**
     * Find zero or one Dashboard that matches the filter.
     * @param {DashboardFindUniqueArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardFindUniqueArgs>(args: SelectSubset<T, DashboardFindUniqueArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dashboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardFindUniqueOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dashboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardFindFirstArgs>(args?: SelectSubset<T, DashboardFindFirstArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dashboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dashboards
     * const dashboards = await prisma.dashboard.findMany()
     * 
     * // Get first 10 Dashboards
     * const dashboards = await prisma.dashboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardFindManyArgs>(args?: SelectSubset<T, DashboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dashboard.
     * @param {DashboardCreateArgs} args - Arguments to create a Dashboard.
     * @example
     * // Create one Dashboard
     * const Dashboard = await prisma.dashboard.create({
     *   data: {
     *     // ... data to create a Dashboard
     *   }
     * })
     * 
     */
    create<T extends DashboardCreateArgs>(args: SelectSubset<T, DashboardCreateArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dashboards.
     * @param {DashboardCreateManyArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardCreateManyArgs>(args?: SelectSubset<T, DashboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dashboards and returns the data saved in the database.
     * @param {DashboardCreateManyAndReturnArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dashboard.
     * @param {DashboardDeleteArgs} args - Arguments to delete one Dashboard.
     * @example
     * // Delete one Dashboard
     * const Dashboard = await prisma.dashboard.delete({
     *   where: {
     *     // ... filter to delete one Dashboard
     *   }
     * })
     * 
     */
    delete<T extends DashboardDeleteArgs>(args: SelectSubset<T, DashboardDeleteArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dashboard.
     * @param {DashboardUpdateArgs} args - Arguments to update one Dashboard.
     * @example
     * // Update one Dashboard
     * const dashboard = await prisma.dashboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardUpdateArgs>(args: SelectSubset<T, DashboardUpdateArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dashboards.
     * @param {DashboardDeleteManyArgs} args - Arguments to filter Dashboards to delete.
     * @example
     * // Delete a few Dashboards
     * const { count } = await prisma.dashboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardDeleteManyArgs>(args?: SelectSubset<T, DashboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardUpdateManyArgs>(args: SelectSubset<T, DashboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dashboards and returns the data updated in the database.
     * @param {DashboardUpdateManyAndReturnArgs} args - Arguments to update many Dashboards.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dashboard.
     * @param {DashboardUpsertArgs} args - Arguments to update or create a Dashboard.
     * @example
     * // Update or create a Dashboard
     * const dashboard = await prisma.dashboard.upsert({
     *   create: {
     *     // ... data to create a Dashboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dashboard we want to update
     *   }
     * })
     */
    upsert<T extends DashboardUpsertArgs>(args: SelectSubset<T, DashboardUpsertArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardCountArgs} args - Arguments to filter Dashboards to count.
     * @example
     * // Count the number of Dashboards
     * const count = await prisma.dashboard.count({
     *   where: {
     *     // ... the filter for the Dashboards we want to count
     *   }
     * })
    **/
    count<T extends DashboardCountArgs>(
      args?: Subset<T, DashboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardAggregateArgs>(args: Subset<T, DashboardAggregateArgs>): Prisma.PrismaPromise<GetDashboardAggregateType<T>>

    /**
     * Group by Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardGroupByArgs['orderBy'] }
        : { orderBy?: DashboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dashboard model
   */
  readonly fields: DashboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dashboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    widgets<T extends Dashboard$widgetsArgs<ExtArgs> = {}>(args?: Subset<T, Dashboard$widgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dashboard model
   */
  interface DashboardFieldRefs {
    readonly id: FieldRef<"Dashboard", 'String'>
    readonly name: FieldRef<"Dashboard", 'String'>
    readonly ownerId: FieldRef<"Dashboard", 'String'>
    readonly allowedUsers: FieldRef<"Dashboard", 'String[]'>
    readonly allowedRoles: FieldRef<"Dashboard", 'String[]'>
    readonly layout: FieldRef<"Dashboard", 'Json'>
    readonly createdAt: FieldRef<"Dashboard", 'DateTime'>
    readonly updatedAt: FieldRef<"Dashboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dashboard findUnique
   */
  export type DashboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard findUniqueOrThrow
   */
  export type DashboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard findFirst
   */
  export type DashboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard findFirstOrThrow
   */
  export type DashboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard findMany
   */
  export type DashboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter, which Dashboards to fetch.
     */
    where?: DashboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dashboards.
     */
    cursor?: DashboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dashboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dashboards.
     */
    skip?: number
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard create
   */
  export type DashboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Dashboard.
     */
    data: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard createMany
   */
  export type DashboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dashboard createManyAndReturn
   */
  export type DashboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dashboard update
   */
  export type DashboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Dashboard.
     */
    data: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>
    /**
     * Choose, which Dashboard to update.
     */
    where: DashboardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard updateMany
   */
  export type DashboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number
  }

  /**
   * Dashboard updateManyAndReturn
   */
  export type DashboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number
  }

  /**
   * Dashboard upsert
   */
  export type DashboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Dashboard to update in case it exists.
     */
    where: DashboardWhereUniqueInput
    /**
     * In case the Dashboard found by the `where` argument doesn't exist, create a new Dashboard with this data.
     */
    create: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>
    /**
     * In case the Dashboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard delete
   */
  export type DashboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
    /**
     * Filter which Dashboard to delete.
     */
    where: DashboardWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Dashboard deleteMany
   */
  export type DashboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dashboards to delete
     */
    where?: DashboardWhereInput
    /**
     * Limit how many Dashboards to delete.
     */
    limit?: number
  }

  /**
   * Dashboard.widgets
   */
  export type Dashboard$widgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    where?: WidgetWhereInput
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    cursor?: WidgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[]
  }

  /**
   * Dashboard without action
   */
  export type DashboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null
  }


  /**
   * Model Widget
   */

  export type AggregateWidget = {
    _count: WidgetCountAggregateOutputType | null
    _avg: WidgetAvgAggregateOutputType | null
    _sum: WidgetSumAggregateOutputType | null
    _min: WidgetMinAggregateOutputType | null
    _max: WidgetMaxAggregateOutputType | null
  }

  export type WidgetAvgAggregateOutputType = {
    order: number | null
  }

  export type WidgetSumAggregateOutputType = {
    order: number | null
  }

  export type WidgetMinAggregateOutputType = {
    id: string | null
    dashboardId: string | null
    title: string | null
    visualizationType: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WidgetMaxAggregateOutputType = {
    id: string | null
    dashboardId: string | null
    title: string | null
    visualizationType: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WidgetCountAggregateOutputType = {
    id: number
    dashboardId: number
    title: number
    visualizationType: number
    config: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WidgetAvgAggregateInputType = {
    order?: true
  }

  export type WidgetSumAggregateInputType = {
    order?: true
  }

  export type WidgetMinAggregateInputType = {
    id?: true
    dashboardId?: true
    title?: true
    visualizationType?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WidgetMaxAggregateInputType = {
    id?: true
    dashboardId?: true
    title?: true
    visualizationType?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WidgetCountAggregateInputType = {
    id?: true
    dashboardId?: true
    title?: true
    visualizationType?: true
    config?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WidgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Widget to aggregate.
     */
    where?: WidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Widgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Widgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Widgets
    **/
    _count?: true | WidgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WidgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WidgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WidgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WidgetMaxAggregateInputType
  }

  export type GetWidgetAggregateType<T extends WidgetAggregateArgs> = {
        [P in keyof T & keyof AggregateWidget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWidget[P]>
      : GetScalarType<T[P], AggregateWidget[P]>
  }




  export type WidgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WidgetWhereInput
    orderBy?: WidgetOrderByWithAggregationInput | WidgetOrderByWithAggregationInput[]
    by: WidgetScalarFieldEnum[] | WidgetScalarFieldEnum
    having?: WidgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WidgetCountAggregateInputType | true
    _avg?: WidgetAvgAggregateInputType
    _sum?: WidgetSumAggregateInputType
    _min?: WidgetMinAggregateInputType
    _max?: WidgetMaxAggregateInputType
  }

  export type WidgetGroupByOutputType = {
    id: string
    dashboardId: string
    title: string
    visualizationType: string
    config: JsonValue
    order: number
    createdAt: Date
    updatedAt: Date
    _count: WidgetCountAggregateOutputType | null
    _avg: WidgetAvgAggregateOutputType | null
    _sum: WidgetSumAggregateOutputType | null
    _min: WidgetMinAggregateOutputType | null
    _max: WidgetMaxAggregateOutputType | null
  }

  type GetWidgetGroupByPayload<T extends WidgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WidgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WidgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WidgetGroupByOutputType[P]>
            : GetScalarType<T[P], WidgetGroupByOutputType[P]>
        }
      >
    >


  export type WidgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dashboardId?: boolean
    title?: boolean
    visualizationType?: boolean
    config?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["widget"]>

  export type WidgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dashboardId?: boolean
    title?: boolean
    visualizationType?: boolean
    config?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["widget"]>

  export type WidgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dashboardId?: boolean
    title?: boolean
    visualizationType?: boolean
    config?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["widget"]>

  export type WidgetSelectScalar = {
    id?: boolean
    dashboardId?: boolean
    title?: boolean
    visualizationType?: boolean
    config?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WidgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dashboardId" | "title" | "visualizationType" | "config" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["widget"]>
  export type WidgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type WidgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }
  export type WidgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>
  }

  export type $WidgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Widget"
    objects: {
      dashboard: Prisma.$DashboardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dashboardId: string
      title: string
      visualizationType: string
      config: Prisma.JsonValue
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["widget"]>
    composites: {}
  }

  type WidgetGetPayload<S extends boolean | null | undefined | WidgetDefaultArgs> = $Result.GetResult<Prisma.$WidgetPayload, S>

  type WidgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WidgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WidgetCountAggregateInputType | true
    }

  export interface WidgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Widget'], meta: { name: 'Widget' } }
    /**
     * Find zero or one Widget that matches the filter.
     * @param {WidgetFindUniqueArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WidgetFindUniqueArgs>(args: SelectSubset<T, WidgetFindUniqueArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Widget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WidgetFindUniqueOrThrowArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WidgetFindUniqueOrThrowArgs>(args: SelectSubset<T, WidgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Widget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindFirstArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WidgetFindFirstArgs>(args?: SelectSubset<T, WidgetFindFirstArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Widget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindFirstOrThrowArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WidgetFindFirstOrThrowArgs>(args?: SelectSubset<T, WidgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Widgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Widgets
     * const widgets = await prisma.widget.findMany()
     * 
     * // Get first 10 Widgets
     * const widgets = await prisma.widget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const widgetWithIdOnly = await prisma.widget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WidgetFindManyArgs>(args?: SelectSubset<T, WidgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Widget.
     * @param {WidgetCreateArgs} args - Arguments to create a Widget.
     * @example
     * // Create one Widget
     * const Widget = await prisma.widget.create({
     *   data: {
     *     // ... data to create a Widget
     *   }
     * })
     * 
     */
    create<T extends WidgetCreateArgs>(args: SelectSubset<T, WidgetCreateArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Widgets.
     * @param {WidgetCreateManyArgs} args - Arguments to create many Widgets.
     * @example
     * // Create many Widgets
     * const widget = await prisma.widget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WidgetCreateManyArgs>(args?: SelectSubset<T, WidgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Widgets and returns the data saved in the database.
     * @param {WidgetCreateManyAndReturnArgs} args - Arguments to create many Widgets.
     * @example
     * // Create many Widgets
     * const widget = await prisma.widget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Widgets and only return the `id`
     * const widgetWithIdOnly = await prisma.widget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WidgetCreateManyAndReturnArgs>(args?: SelectSubset<T, WidgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Widget.
     * @param {WidgetDeleteArgs} args - Arguments to delete one Widget.
     * @example
     * // Delete one Widget
     * const Widget = await prisma.widget.delete({
     *   where: {
     *     // ... filter to delete one Widget
     *   }
     * })
     * 
     */
    delete<T extends WidgetDeleteArgs>(args: SelectSubset<T, WidgetDeleteArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Widget.
     * @param {WidgetUpdateArgs} args - Arguments to update one Widget.
     * @example
     * // Update one Widget
     * const widget = await prisma.widget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WidgetUpdateArgs>(args: SelectSubset<T, WidgetUpdateArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Widgets.
     * @param {WidgetDeleteManyArgs} args - Arguments to filter Widgets to delete.
     * @example
     * // Delete a few Widgets
     * const { count } = await prisma.widget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WidgetDeleteManyArgs>(args?: SelectSubset<T, WidgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Widgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Widgets
     * const widget = await prisma.widget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WidgetUpdateManyArgs>(args: SelectSubset<T, WidgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Widgets and returns the data updated in the database.
     * @param {WidgetUpdateManyAndReturnArgs} args - Arguments to update many Widgets.
     * @example
     * // Update many Widgets
     * const widget = await prisma.widget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Widgets and only return the `id`
     * const widgetWithIdOnly = await prisma.widget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WidgetUpdateManyAndReturnArgs>(args: SelectSubset<T, WidgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Widget.
     * @param {WidgetUpsertArgs} args - Arguments to update or create a Widget.
     * @example
     * // Update or create a Widget
     * const widget = await prisma.widget.upsert({
     *   create: {
     *     // ... data to create a Widget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Widget we want to update
     *   }
     * })
     */
    upsert<T extends WidgetUpsertArgs>(args: SelectSubset<T, WidgetUpsertArgs<ExtArgs>>): Prisma__WidgetClient<$Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Widgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetCountArgs} args - Arguments to filter Widgets to count.
     * @example
     * // Count the number of Widgets
     * const count = await prisma.widget.count({
     *   where: {
     *     // ... the filter for the Widgets we want to count
     *   }
     * })
    **/
    count<T extends WidgetCountArgs>(
      args?: Subset<T, WidgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WidgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Widget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WidgetAggregateArgs>(args: Subset<T, WidgetAggregateArgs>): Prisma.PrismaPromise<GetWidgetAggregateType<T>>

    /**
     * Group by Widget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WidgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WidgetGroupByArgs['orderBy'] }
        : { orderBy?: WidgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WidgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWidgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Widget model
   */
  readonly fields: WidgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Widget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WidgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dashboard<T extends DashboardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DashboardDefaultArgs<ExtArgs>>): Prisma__DashboardClient<$Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Widget model
   */
  interface WidgetFieldRefs {
    readonly id: FieldRef<"Widget", 'String'>
    readonly dashboardId: FieldRef<"Widget", 'String'>
    readonly title: FieldRef<"Widget", 'String'>
    readonly visualizationType: FieldRef<"Widget", 'String'>
    readonly config: FieldRef<"Widget", 'Json'>
    readonly order: FieldRef<"Widget", 'Int'>
    readonly createdAt: FieldRef<"Widget", 'DateTime'>
    readonly updatedAt: FieldRef<"Widget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Widget findUnique
   */
  export type WidgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * Filter, which Widget to fetch.
     */
    where: WidgetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget findUniqueOrThrow
   */
  export type WidgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * Filter, which Widget to fetch.
     */
    where: WidgetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget findFirst
   */
  export type WidgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * Filter, which Widget to fetch.
     */
    where?: WidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Widgets.
     */
    cursor?: WidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Widgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Widgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Widgets.
     */
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget findFirstOrThrow
   */
  export type WidgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * Filter, which Widget to fetch.
     */
    where?: WidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Widgets.
     */
    cursor?: WidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Widgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Widgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Widgets.
     */
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget findMany
   */
  export type WidgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * Filter, which Widgets to fetch.
     */
    where?: WidgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Widgets.
     */
    cursor?: WidgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Widgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Widgets.
     */
    skip?: number
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget create
   */
  export type WidgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Widget.
     */
    data: XOR<WidgetCreateInput, WidgetUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget createMany
   */
  export type WidgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Widgets.
     */
    data: WidgetCreateManyInput | WidgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Widget createManyAndReturn
   */
  export type WidgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * The data used to create many Widgets.
     */
    data: WidgetCreateManyInput | WidgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Widget update
   */
  export type WidgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Widget.
     */
    data: XOR<WidgetUpdateInput, WidgetUncheckedUpdateInput>
    /**
     * Choose, which Widget to update.
     */
    where: WidgetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget updateMany
   */
  export type WidgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Widgets.
     */
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyInput>
    /**
     * Filter which Widgets to update
     */
    where?: WidgetWhereInput
    /**
     * Limit how many Widgets to update.
     */
    limit?: number
  }

  /**
   * Widget updateManyAndReturn
   */
  export type WidgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * The data used to update Widgets.
     */
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyInput>
    /**
     * Filter which Widgets to update
     */
    where?: WidgetWhereInput
    /**
     * Limit how many Widgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Widget upsert
   */
  export type WidgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Widget to update in case it exists.
     */
    where: WidgetWhereUniqueInput
    /**
     * In case the Widget found by the `where` argument doesn't exist, create a new Widget with this data.
     */
    create: XOR<WidgetCreateInput, WidgetUncheckedCreateInput>
    /**
     * In case the Widget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WidgetUpdateInput, WidgetUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget delete
   */
  export type WidgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
    /**
     * Filter which Widget to delete.
     */
    where: WidgetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Widget deleteMany
   */
  export type WidgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Widgets to delete
     */
    where?: WidgetWhereInput
    /**
     * Limit how many Widgets to delete.
     */
    limit?: number
  }

  /**
   * Widget without action
   */
  export type WidgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null
  }


  /**
   * Model QrCodeDocument
   */

  export type AggregateQrCodeDocument = {
    _count: QrCodeDocumentCountAggregateOutputType | null
    _min: QrCodeDocumentMinAggregateOutputType | null
    _max: QrCodeDocumentMaxAggregateOutputType | null
  }

  export type QrCodeDocumentMinAggregateOutputType = {
    id: string | null
    documentName: string | null
    fileName: string | null
    qrCodeId: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QrCodeDocumentMaxAggregateOutputType = {
    id: string | null
    documentName: string | null
    fileName: string | null
    qrCodeId: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QrCodeDocumentCountAggregateOutputType = {
    id: number
    documentName: number
    fileName: number
    qrCodeId: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QrCodeDocumentMinAggregateInputType = {
    id?: true
    documentName?: true
    fileName?: true
    qrCodeId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QrCodeDocumentMaxAggregateInputType = {
    id?: true
    documentName?: true
    fileName?: true
    qrCodeId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QrCodeDocumentCountAggregateInputType = {
    id?: true
    documentName?: true
    fileName?: true
    qrCodeId?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QrCodeDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QrCodeDocument to aggregate.
     */
    where?: QrCodeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QrCodeDocuments to fetch.
     */
    orderBy?: QrCodeDocumentOrderByWithRelationInput | QrCodeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QrCodeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QrCodeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QrCodeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QrCodeDocuments
    **/
    _count?: true | QrCodeDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QrCodeDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QrCodeDocumentMaxAggregateInputType
  }

  export type GetQrCodeDocumentAggregateType<T extends QrCodeDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateQrCodeDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQrCodeDocument[P]>
      : GetScalarType<T[P], AggregateQrCodeDocument[P]>
  }




  export type QrCodeDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QrCodeDocumentWhereInput
    orderBy?: QrCodeDocumentOrderByWithAggregationInput | QrCodeDocumentOrderByWithAggregationInput[]
    by: QrCodeDocumentScalarFieldEnum[] | QrCodeDocumentScalarFieldEnum
    having?: QrCodeDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QrCodeDocumentCountAggregateInputType | true
    _min?: QrCodeDocumentMinAggregateInputType
    _max?: QrCodeDocumentMaxAggregateInputType
  }

  export type QrCodeDocumentGroupByOutputType = {
    id: string
    documentName: string
    fileName: string
    qrCodeId: string
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: QrCodeDocumentCountAggregateOutputType | null
    _min: QrCodeDocumentMinAggregateOutputType | null
    _max: QrCodeDocumentMaxAggregateOutputType | null
  }

  type GetQrCodeDocumentGroupByPayload<T extends QrCodeDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QrCodeDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QrCodeDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QrCodeDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], QrCodeDocumentGroupByOutputType[P]>
        }
      >
    >


  export type QrCodeDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentName?: boolean
    fileName?: boolean
    qrCodeId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qrCodeDocument"]>

  export type QrCodeDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentName?: boolean
    fileName?: boolean
    qrCodeId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qrCodeDocument"]>

  export type QrCodeDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentName?: boolean
    fileName?: boolean
    qrCodeId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qrCodeDocument"]>

  export type QrCodeDocumentSelectScalar = {
    id?: boolean
    documentName?: boolean
    fileName?: boolean
    qrCodeId?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QrCodeDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentName" | "fileName" | "qrCodeId" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["qrCodeDocument"]>
  export type QrCodeDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QrCodeDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QrCodeDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QrCodeDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QrCodeDocument"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentName: string
      fileName: string
      qrCodeId: string
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qrCodeDocument"]>
    composites: {}
  }

  type QrCodeDocumentGetPayload<S extends boolean | null | undefined | QrCodeDocumentDefaultArgs> = $Result.GetResult<Prisma.$QrCodeDocumentPayload, S>

  type QrCodeDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QrCodeDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: QrCodeDocumentCountAggregateInputType | true
    }

  export interface QrCodeDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QrCodeDocument'], meta: { name: 'QrCodeDocument' } }
    /**
     * Find zero or one QrCodeDocument that matches the filter.
     * @param {QrCodeDocumentFindUniqueArgs} args - Arguments to find a QrCodeDocument
     * @example
     * // Get one QrCodeDocument
     * const qrCodeDocument = await prisma.qrCodeDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QrCodeDocumentFindUniqueArgs>(args: SelectSubset<T, QrCodeDocumentFindUniqueArgs<ExtArgs>>): Prisma__QrCodeDocumentClient<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QrCodeDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QrCodeDocumentFindUniqueOrThrowArgs} args - Arguments to find a QrCodeDocument
     * @example
     * // Get one QrCodeDocument
     * const qrCodeDocument = await prisma.qrCodeDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QrCodeDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, QrCodeDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QrCodeDocumentClient<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QrCodeDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeDocumentFindFirstArgs} args - Arguments to find a QrCodeDocument
     * @example
     * // Get one QrCodeDocument
     * const qrCodeDocument = await prisma.qrCodeDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QrCodeDocumentFindFirstArgs>(args?: SelectSubset<T, QrCodeDocumentFindFirstArgs<ExtArgs>>): Prisma__QrCodeDocumentClient<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QrCodeDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeDocumentFindFirstOrThrowArgs} args - Arguments to find a QrCodeDocument
     * @example
     * // Get one QrCodeDocument
     * const qrCodeDocument = await prisma.qrCodeDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QrCodeDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, QrCodeDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__QrCodeDocumentClient<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QrCodeDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QrCodeDocuments
     * const qrCodeDocuments = await prisma.qrCodeDocument.findMany()
     * 
     * // Get first 10 QrCodeDocuments
     * const qrCodeDocuments = await prisma.qrCodeDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qrCodeDocumentWithIdOnly = await prisma.qrCodeDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QrCodeDocumentFindManyArgs>(args?: SelectSubset<T, QrCodeDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QrCodeDocument.
     * @param {QrCodeDocumentCreateArgs} args - Arguments to create a QrCodeDocument.
     * @example
     * // Create one QrCodeDocument
     * const QrCodeDocument = await prisma.qrCodeDocument.create({
     *   data: {
     *     // ... data to create a QrCodeDocument
     *   }
     * })
     * 
     */
    create<T extends QrCodeDocumentCreateArgs>(args: SelectSubset<T, QrCodeDocumentCreateArgs<ExtArgs>>): Prisma__QrCodeDocumentClient<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QrCodeDocuments.
     * @param {QrCodeDocumentCreateManyArgs} args - Arguments to create many QrCodeDocuments.
     * @example
     * // Create many QrCodeDocuments
     * const qrCodeDocument = await prisma.qrCodeDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QrCodeDocumentCreateManyArgs>(args?: SelectSubset<T, QrCodeDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QrCodeDocuments and returns the data saved in the database.
     * @param {QrCodeDocumentCreateManyAndReturnArgs} args - Arguments to create many QrCodeDocuments.
     * @example
     * // Create many QrCodeDocuments
     * const qrCodeDocument = await prisma.qrCodeDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QrCodeDocuments and only return the `id`
     * const qrCodeDocumentWithIdOnly = await prisma.qrCodeDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QrCodeDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, QrCodeDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QrCodeDocument.
     * @param {QrCodeDocumentDeleteArgs} args - Arguments to delete one QrCodeDocument.
     * @example
     * // Delete one QrCodeDocument
     * const QrCodeDocument = await prisma.qrCodeDocument.delete({
     *   where: {
     *     // ... filter to delete one QrCodeDocument
     *   }
     * })
     * 
     */
    delete<T extends QrCodeDocumentDeleteArgs>(args: SelectSubset<T, QrCodeDocumentDeleteArgs<ExtArgs>>): Prisma__QrCodeDocumentClient<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QrCodeDocument.
     * @param {QrCodeDocumentUpdateArgs} args - Arguments to update one QrCodeDocument.
     * @example
     * // Update one QrCodeDocument
     * const qrCodeDocument = await prisma.qrCodeDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QrCodeDocumentUpdateArgs>(args: SelectSubset<T, QrCodeDocumentUpdateArgs<ExtArgs>>): Prisma__QrCodeDocumentClient<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QrCodeDocuments.
     * @param {QrCodeDocumentDeleteManyArgs} args - Arguments to filter QrCodeDocuments to delete.
     * @example
     * // Delete a few QrCodeDocuments
     * const { count } = await prisma.qrCodeDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QrCodeDocumentDeleteManyArgs>(args?: SelectSubset<T, QrCodeDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QrCodeDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QrCodeDocuments
     * const qrCodeDocument = await prisma.qrCodeDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QrCodeDocumentUpdateManyArgs>(args: SelectSubset<T, QrCodeDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QrCodeDocuments and returns the data updated in the database.
     * @param {QrCodeDocumentUpdateManyAndReturnArgs} args - Arguments to update many QrCodeDocuments.
     * @example
     * // Update many QrCodeDocuments
     * const qrCodeDocument = await prisma.qrCodeDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QrCodeDocuments and only return the `id`
     * const qrCodeDocumentWithIdOnly = await prisma.qrCodeDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QrCodeDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, QrCodeDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QrCodeDocument.
     * @param {QrCodeDocumentUpsertArgs} args - Arguments to update or create a QrCodeDocument.
     * @example
     * // Update or create a QrCodeDocument
     * const qrCodeDocument = await prisma.qrCodeDocument.upsert({
     *   create: {
     *     // ... data to create a QrCodeDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QrCodeDocument we want to update
     *   }
     * })
     */
    upsert<T extends QrCodeDocumentUpsertArgs>(args: SelectSubset<T, QrCodeDocumentUpsertArgs<ExtArgs>>): Prisma__QrCodeDocumentClient<$Result.GetResult<Prisma.$QrCodeDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QrCodeDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeDocumentCountArgs} args - Arguments to filter QrCodeDocuments to count.
     * @example
     * // Count the number of QrCodeDocuments
     * const count = await prisma.qrCodeDocument.count({
     *   where: {
     *     // ... the filter for the QrCodeDocuments we want to count
     *   }
     * })
    **/
    count<T extends QrCodeDocumentCountArgs>(
      args?: Subset<T, QrCodeDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QrCodeDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QrCodeDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QrCodeDocumentAggregateArgs>(args: Subset<T, QrCodeDocumentAggregateArgs>): Prisma.PrismaPromise<GetQrCodeDocumentAggregateType<T>>

    /**
     * Group by QrCodeDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QrCodeDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QrCodeDocumentGroupByArgs['orderBy'] }
        : { orderBy?: QrCodeDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QrCodeDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQrCodeDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QrCodeDocument model
   */
  readonly fields: QrCodeDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QrCodeDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QrCodeDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QrCodeDocument model
   */
  interface QrCodeDocumentFieldRefs {
    readonly id: FieldRef<"QrCodeDocument", 'String'>
    readonly documentName: FieldRef<"QrCodeDocument", 'String'>
    readonly fileName: FieldRef<"QrCodeDocument", 'String'>
    readonly qrCodeId: FieldRef<"QrCodeDocument", 'String'>
    readonly creatorId: FieldRef<"QrCodeDocument", 'String'>
    readonly createdAt: FieldRef<"QrCodeDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"QrCodeDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QrCodeDocument findUnique
   */
  export type QrCodeDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which QrCodeDocument to fetch.
     */
    where: QrCodeDocumentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument findUniqueOrThrow
   */
  export type QrCodeDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which QrCodeDocument to fetch.
     */
    where: QrCodeDocumentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument findFirst
   */
  export type QrCodeDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which QrCodeDocument to fetch.
     */
    where?: QrCodeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QrCodeDocuments to fetch.
     */
    orderBy?: QrCodeDocumentOrderByWithRelationInput | QrCodeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QrCodeDocuments.
     */
    cursor?: QrCodeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QrCodeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QrCodeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QrCodeDocuments.
     */
    distinct?: QrCodeDocumentScalarFieldEnum | QrCodeDocumentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument findFirstOrThrow
   */
  export type QrCodeDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which QrCodeDocument to fetch.
     */
    where?: QrCodeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QrCodeDocuments to fetch.
     */
    orderBy?: QrCodeDocumentOrderByWithRelationInput | QrCodeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QrCodeDocuments.
     */
    cursor?: QrCodeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QrCodeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QrCodeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QrCodeDocuments.
     */
    distinct?: QrCodeDocumentScalarFieldEnum | QrCodeDocumentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument findMany
   */
  export type QrCodeDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which QrCodeDocuments to fetch.
     */
    where?: QrCodeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QrCodeDocuments to fetch.
     */
    orderBy?: QrCodeDocumentOrderByWithRelationInput | QrCodeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QrCodeDocuments.
     */
    cursor?: QrCodeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QrCodeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QrCodeDocuments.
     */
    skip?: number
    distinct?: QrCodeDocumentScalarFieldEnum | QrCodeDocumentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument create
   */
  export type QrCodeDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a QrCodeDocument.
     */
    data: XOR<QrCodeDocumentCreateInput, QrCodeDocumentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument createMany
   */
  export type QrCodeDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QrCodeDocuments.
     */
    data: QrCodeDocumentCreateManyInput | QrCodeDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QrCodeDocument createManyAndReturn
   */
  export type QrCodeDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many QrCodeDocuments.
     */
    data: QrCodeDocumentCreateManyInput | QrCodeDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QrCodeDocument update
   */
  export type QrCodeDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a QrCodeDocument.
     */
    data: XOR<QrCodeDocumentUpdateInput, QrCodeDocumentUncheckedUpdateInput>
    /**
     * Choose, which QrCodeDocument to update.
     */
    where: QrCodeDocumentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument updateMany
   */
  export type QrCodeDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QrCodeDocuments.
     */
    data: XOR<QrCodeDocumentUpdateManyMutationInput, QrCodeDocumentUncheckedUpdateManyInput>
    /**
     * Filter which QrCodeDocuments to update
     */
    where?: QrCodeDocumentWhereInput
    /**
     * Limit how many QrCodeDocuments to update.
     */
    limit?: number
  }

  /**
   * QrCodeDocument updateManyAndReturn
   */
  export type QrCodeDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * The data used to update QrCodeDocuments.
     */
    data: XOR<QrCodeDocumentUpdateManyMutationInput, QrCodeDocumentUncheckedUpdateManyInput>
    /**
     * Filter which QrCodeDocuments to update
     */
    where?: QrCodeDocumentWhereInput
    /**
     * Limit how many QrCodeDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QrCodeDocument upsert
   */
  export type QrCodeDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the QrCodeDocument to update in case it exists.
     */
    where: QrCodeDocumentWhereUniqueInput
    /**
     * In case the QrCodeDocument found by the `where` argument doesn't exist, create a new QrCodeDocument with this data.
     */
    create: XOR<QrCodeDocumentCreateInput, QrCodeDocumentUncheckedCreateInput>
    /**
     * In case the QrCodeDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QrCodeDocumentUpdateInput, QrCodeDocumentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument delete
   */
  export type QrCodeDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
    /**
     * Filter which QrCodeDocument to delete.
     */
    where: QrCodeDocumentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * QrCodeDocument deleteMany
   */
  export type QrCodeDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QrCodeDocuments to delete
     */
    where?: QrCodeDocumentWhereInput
    /**
     * Limit how many QrCodeDocuments to delete.
     */
    limit?: number
  }

  /**
   * QrCodeDocument without action
   */
  export type QrCodeDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QrCodeDocument
     */
    select?: QrCodeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QrCodeDocument
     */
    omit?: QrCodeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QrCodeDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    expiresAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    email: string | null
    otp: string | null
    expiresAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    email: number
    otp: number
    expiresAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    expiresAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    email: string
    otp: string
    expiresAt: Date
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    email?: boolean
    otp?: boolean
    expiresAt?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otp" | "expiresAt", ExtArgs["result"]["otp"]>

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      otp: string
      expiresAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {OtpCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {OtpUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly email: FieldRef<"Otp", 'String'>
    readonly otp: FieldRef<"Otp", 'String'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp createManyAndReturn
   */
  export type OtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp updateManyAndReturn
   */
  export type OtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
  }


  /**
   * Model Management
   */

  export type AggregateManagement = {
    _count: ManagementCountAggregateOutputType | null
    _min: ManagementMinAggregateOutputType | null
    _max: ManagementMaxAggregateOutputType | null
  }

  export type ManagementMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    fileUrl: string | null
    type: $Enums.ManagementType | null
    uploadedAt: Date | null
    updatedAt: Date | null
  }

  export type ManagementMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    fileUrl: string | null
    type: $Enums.ManagementType | null
    uploadedAt: Date | null
    updatedAt: Date | null
  }

  export type ManagementCountAggregateOutputType = {
    id: number
    fileName: number
    fileUrl: number
    type: number
    uploadedAt: number
    updatedAt: number
    _all: number
  }


  export type ManagementMinAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    type?: true
    uploadedAt?: true
    updatedAt?: true
  }

  export type ManagementMaxAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    type?: true
    uploadedAt?: true
    updatedAt?: true
  }

  export type ManagementCountAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    type?: true
    uploadedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ManagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Management to aggregate.
     */
    where?: ManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managements to fetch.
     */
    orderBy?: ManagementOrderByWithRelationInput | ManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managements
    **/
    _count?: true | ManagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagementMaxAggregateInputType
  }

  export type GetManagementAggregateType<T extends ManagementAggregateArgs> = {
        [P in keyof T & keyof AggregateManagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManagement[P]>
      : GetScalarType<T[P], AggregateManagement[P]>
  }




  export type ManagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagementWhereInput
    orderBy?: ManagementOrderByWithAggregationInput | ManagementOrderByWithAggregationInput[]
    by: ManagementScalarFieldEnum[] | ManagementScalarFieldEnum
    having?: ManagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagementCountAggregateInputType | true
    _min?: ManagementMinAggregateInputType
    _max?: ManagementMaxAggregateInputType
  }

  export type ManagementGroupByOutputType = {
    id: string
    fileName: string
    fileUrl: string | null
    type: $Enums.ManagementType
    uploadedAt: Date
    updatedAt: Date
    _count: ManagementCountAggregateOutputType | null
    _min: ManagementMinAggregateOutputType | null
    _max: ManagementMaxAggregateOutputType | null
  }

  type GetManagementGroupByPayload<T extends ManagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagementGroupByOutputType[P]>
            : GetScalarType<T[P], ManagementGroupByOutputType[P]>
        }
      >
    >


  export type ManagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    type?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["management"]>

  export type ManagementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    type?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["management"]>

  export type ManagementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    type?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["management"]>

  export type ManagementSelectScalar = {
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    type?: boolean
    uploadedAt?: boolean
    updatedAt?: boolean
  }

  export type ManagementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileName" | "fileUrl" | "type" | "uploadedAt" | "updatedAt", ExtArgs["result"]["management"]>

  export type $ManagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Management"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      fileUrl: string | null
      type: $Enums.ManagementType
      uploadedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["management"]>
    composites: {}
  }

  type ManagementGetPayload<S extends boolean | null | undefined | ManagementDefaultArgs> = $Result.GetResult<Prisma.$ManagementPayload, S>

  type ManagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManagementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ManagementCountAggregateInputType | true
    }

  export interface ManagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Management'], meta: { name: 'Management' } }
    /**
     * Find zero or one Management that matches the filter.
     * @param {ManagementFindUniqueArgs} args - Arguments to find a Management
     * @example
     * // Get one Management
     * const management = await prisma.management.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagementFindUniqueArgs>(args: SelectSubset<T, ManagementFindUniqueArgs<ExtArgs>>): Prisma__ManagementClient<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Management that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManagementFindUniqueOrThrowArgs} args - Arguments to find a Management
     * @example
     * // Get one Management
     * const management = await prisma.management.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagementFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagementClient<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Management that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagementFindFirstArgs} args - Arguments to find a Management
     * @example
     * // Get one Management
     * const management = await prisma.management.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagementFindFirstArgs>(args?: SelectSubset<T, ManagementFindFirstArgs<ExtArgs>>): Prisma__ManagementClient<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Management that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagementFindFirstOrThrowArgs} args - Arguments to find a Management
     * @example
     * // Get one Management
     * const management = await prisma.management.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagementFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagementClient<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Managements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managements
     * const managements = await prisma.management.findMany()
     * 
     * // Get first 10 Managements
     * const managements = await prisma.management.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managementWithIdOnly = await prisma.management.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagementFindManyArgs>(args?: SelectSubset<T, ManagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Management.
     * @param {ManagementCreateArgs} args - Arguments to create a Management.
     * @example
     * // Create one Management
     * const Management = await prisma.management.create({
     *   data: {
     *     // ... data to create a Management
     *   }
     * })
     * 
     */
    create<T extends ManagementCreateArgs>(args: SelectSubset<T, ManagementCreateArgs<ExtArgs>>): Prisma__ManagementClient<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Managements.
     * @param {ManagementCreateManyArgs} args - Arguments to create many Managements.
     * @example
     * // Create many Managements
     * const management = await prisma.management.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagementCreateManyArgs>(args?: SelectSubset<T, ManagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Managements and returns the data saved in the database.
     * @param {ManagementCreateManyAndReturnArgs} args - Arguments to create many Managements.
     * @example
     * // Create many Managements
     * const management = await prisma.management.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Managements and only return the `id`
     * const managementWithIdOnly = await prisma.management.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManagementCreateManyAndReturnArgs>(args?: SelectSubset<T, ManagementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Management.
     * @param {ManagementDeleteArgs} args - Arguments to delete one Management.
     * @example
     * // Delete one Management
     * const Management = await prisma.management.delete({
     *   where: {
     *     // ... filter to delete one Management
     *   }
     * })
     * 
     */
    delete<T extends ManagementDeleteArgs>(args: SelectSubset<T, ManagementDeleteArgs<ExtArgs>>): Prisma__ManagementClient<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Management.
     * @param {ManagementUpdateArgs} args - Arguments to update one Management.
     * @example
     * // Update one Management
     * const management = await prisma.management.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagementUpdateArgs>(args: SelectSubset<T, ManagementUpdateArgs<ExtArgs>>): Prisma__ManagementClient<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Managements.
     * @param {ManagementDeleteManyArgs} args - Arguments to filter Managements to delete.
     * @example
     * // Delete a few Managements
     * const { count } = await prisma.management.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagementDeleteManyArgs>(args?: SelectSubset<T, ManagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managements
     * const management = await prisma.management.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagementUpdateManyArgs>(args: SelectSubset<T, ManagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managements and returns the data updated in the database.
     * @param {ManagementUpdateManyAndReturnArgs} args - Arguments to update many Managements.
     * @example
     * // Update many Managements
     * const management = await prisma.management.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Managements and only return the `id`
     * const managementWithIdOnly = await prisma.management.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ManagementUpdateManyAndReturnArgs>(args: SelectSubset<T, ManagementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Management.
     * @param {ManagementUpsertArgs} args - Arguments to update or create a Management.
     * @example
     * // Update or create a Management
     * const management = await prisma.management.upsert({
     *   create: {
     *     // ... data to create a Management
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Management we want to update
     *   }
     * })
     */
    upsert<T extends ManagementUpsertArgs>(args: SelectSubset<T, ManagementUpsertArgs<ExtArgs>>): Prisma__ManagementClient<$Result.GetResult<Prisma.$ManagementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Managements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagementCountArgs} args - Arguments to filter Managements to count.
     * @example
     * // Count the number of Managements
     * const count = await prisma.management.count({
     *   where: {
     *     // ... the filter for the Managements we want to count
     *   }
     * })
    **/
    count<T extends ManagementCountArgs>(
      args?: Subset<T, ManagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Management.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagementAggregateArgs>(args: Subset<T, ManagementAggregateArgs>): Prisma.PrismaPromise<GetManagementAggregateType<T>>

    /**
     * Group by Management.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagementGroupByArgs['orderBy'] }
        : { orderBy?: ManagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Management model
   */
  readonly fields: ManagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Management.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Management model
   */
  interface ManagementFieldRefs {
    readonly id: FieldRef<"Management", 'String'>
    readonly fileName: FieldRef<"Management", 'String'>
    readonly fileUrl: FieldRef<"Management", 'String'>
    readonly type: FieldRef<"Management", 'ManagementType'>
    readonly uploadedAt: FieldRef<"Management", 'DateTime'>
    readonly updatedAt: FieldRef<"Management", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Management findUnique
   */
  export type ManagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * Filter, which Management to fetch.
     */
    where: ManagementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management findUniqueOrThrow
   */
  export type ManagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * Filter, which Management to fetch.
     */
    where: ManagementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management findFirst
   */
  export type ManagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * Filter, which Management to fetch.
     */
    where?: ManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managements to fetch.
     */
    orderBy?: ManagementOrderByWithRelationInput | ManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managements.
     */
    cursor?: ManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managements.
     */
    distinct?: ManagementScalarFieldEnum | ManagementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management findFirstOrThrow
   */
  export type ManagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * Filter, which Management to fetch.
     */
    where?: ManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managements to fetch.
     */
    orderBy?: ManagementOrderByWithRelationInput | ManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managements.
     */
    cursor?: ManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managements.
     */
    distinct?: ManagementScalarFieldEnum | ManagementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management findMany
   */
  export type ManagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * Filter, which Managements to fetch.
     */
    where?: ManagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managements to fetch.
     */
    orderBy?: ManagementOrderByWithRelationInput | ManagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managements.
     */
    cursor?: ManagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managements.
     */
    skip?: number
    distinct?: ManagementScalarFieldEnum | ManagementScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management create
   */
  export type ManagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * The data needed to create a Management.
     */
    data: XOR<ManagementCreateInput, ManagementUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management createMany
   */
  export type ManagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managements.
     */
    data: ManagementCreateManyInput | ManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Management createManyAndReturn
   */
  export type ManagementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * The data used to create many Managements.
     */
    data: ManagementCreateManyInput | ManagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Management update
   */
  export type ManagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * The data needed to update a Management.
     */
    data: XOR<ManagementUpdateInput, ManagementUncheckedUpdateInput>
    /**
     * Choose, which Management to update.
     */
    where: ManagementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management updateMany
   */
  export type ManagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managements.
     */
    data: XOR<ManagementUpdateManyMutationInput, ManagementUncheckedUpdateManyInput>
    /**
     * Filter which Managements to update
     */
    where?: ManagementWhereInput
    /**
     * Limit how many Managements to update.
     */
    limit?: number
  }

  /**
   * Management updateManyAndReturn
   */
  export type ManagementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * The data used to update Managements.
     */
    data: XOR<ManagementUpdateManyMutationInput, ManagementUncheckedUpdateManyInput>
    /**
     * Filter which Managements to update
     */
    where?: ManagementWhereInput
    /**
     * Limit how many Managements to update.
     */
    limit?: number
  }

  /**
   * Management upsert
   */
  export type ManagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * The filter to search for the Management to update in case it exists.
     */
    where: ManagementWhereUniqueInput
    /**
     * In case the Management found by the `where` argument doesn't exist, create a new Management with this data.
     */
    create: XOR<ManagementCreateInput, ManagementUncheckedCreateInput>
    /**
     * In case the Management was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagementUpdateInput, ManagementUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management delete
   */
  export type ManagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
    /**
     * Filter which Management to delete.
     */
    where: ManagementWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Management deleteMany
   */
  export type ManagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managements to delete
     */
    where?: ManagementWhereInput
    /**
     * Limit how many Managements to delete.
     */
    limit?: number
  }

  /**
   * Management without action
   */
  export type ManagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Management
     */
    select?: ManagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Management
     */
    omit?: ManagementOmit<ExtArgs> | null
  }


  /**
   * Model AddToDatabase
   */

  export type AggregateAddToDatabase = {
    _count: AddToDatabaseCountAggregateOutputType | null
    _min: AddToDatabaseMinAggregateOutputType | null
    _max: AddToDatabaseMaxAggregateOutputType | null
  }

  export type AddToDatabaseMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.AddToDatabaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddToDatabaseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.AddToDatabaseStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddToDatabaseCountAggregateOutputType = {
    id: number
    name: number
    status: number
    levels: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddToDatabaseMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddToDatabaseMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddToDatabaseCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    levels?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddToDatabaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddToDatabase to aggregate.
     */
    where?: AddToDatabaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddToDatabases to fetch.
     */
    orderBy?: AddToDatabaseOrderByWithRelationInput | AddToDatabaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddToDatabaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddToDatabases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddToDatabases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddToDatabases
    **/
    _count?: true | AddToDatabaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddToDatabaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddToDatabaseMaxAggregateInputType
  }

  export type GetAddToDatabaseAggregateType<T extends AddToDatabaseAggregateArgs> = {
        [P in keyof T & keyof AggregateAddToDatabase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddToDatabase[P]>
      : GetScalarType<T[P], AggregateAddToDatabase[P]>
  }




  export type AddToDatabaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddToDatabaseWhereInput
    orderBy?: AddToDatabaseOrderByWithAggregationInput | AddToDatabaseOrderByWithAggregationInput[]
    by: AddToDatabaseScalarFieldEnum[] | AddToDatabaseScalarFieldEnum
    having?: AddToDatabaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddToDatabaseCountAggregateInputType | true
    _min?: AddToDatabaseMinAggregateInputType
    _max?: AddToDatabaseMaxAggregateInputType
  }

  export type AddToDatabaseGroupByOutputType = {
    id: string
    name: string
    status: $Enums.AddToDatabaseStatus
    levels: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: AddToDatabaseCountAggregateOutputType | null
    _min: AddToDatabaseMinAggregateOutputType | null
    _max: AddToDatabaseMaxAggregateOutputType | null
  }

  type GetAddToDatabaseGroupByPayload<T extends AddToDatabaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddToDatabaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddToDatabaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddToDatabaseGroupByOutputType[P]>
            : GetScalarType<T[P], AddToDatabaseGroupByOutputType[P]>
        }
      >
    >


  export type AddToDatabaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    levels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["addToDatabase"]>

  export type AddToDatabaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    levels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["addToDatabase"]>

  export type AddToDatabaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    levels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["addToDatabase"]>

  export type AddToDatabaseSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    levels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddToDatabaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "levels" | "createdAt" | "updatedAt", ExtArgs["result"]["addToDatabase"]>

  export type $AddToDatabasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddToDatabase"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: $Enums.AddToDatabaseStatus
      levels: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["addToDatabase"]>
    composites: {}
  }

  type AddToDatabaseGetPayload<S extends boolean | null | undefined | AddToDatabaseDefaultArgs> = $Result.GetResult<Prisma.$AddToDatabasePayload, S>

  type AddToDatabaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddToDatabaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AddToDatabaseCountAggregateInputType | true
    }

  export interface AddToDatabaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddToDatabase'], meta: { name: 'AddToDatabase' } }
    /**
     * Find zero or one AddToDatabase that matches the filter.
     * @param {AddToDatabaseFindUniqueArgs} args - Arguments to find a AddToDatabase
     * @example
     * // Get one AddToDatabase
     * const addToDatabase = await prisma.addToDatabase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddToDatabaseFindUniqueArgs>(args: SelectSubset<T, AddToDatabaseFindUniqueArgs<ExtArgs>>): Prisma__AddToDatabaseClient<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddToDatabase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddToDatabaseFindUniqueOrThrowArgs} args - Arguments to find a AddToDatabase
     * @example
     * // Get one AddToDatabase
     * const addToDatabase = await prisma.addToDatabase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddToDatabaseFindUniqueOrThrowArgs>(args: SelectSubset<T, AddToDatabaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddToDatabaseClient<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddToDatabase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToDatabaseFindFirstArgs} args - Arguments to find a AddToDatabase
     * @example
     * // Get one AddToDatabase
     * const addToDatabase = await prisma.addToDatabase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddToDatabaseFindFirstArgs>(args?: SelectSubset<T, AddToDatabaseFindFirstArgs<ExtArgs>>): Prisma__AddToDatabaseClient<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddToDatabase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToDatabaseFindFirstOrThrowArgs} args - Arguments to find a AddToDatabase
     * @example
     * // Get one AddToDatabase
     * const addToDatabase = await prisma.addToDatabase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddToDatabaseFindFirstOrThrowArgs>(args?: SelectSubset<T, AddToDatabaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddToDatabaseClient<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddToDatabases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToDatabaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddToDatabases
     * const addToDatabases = await prisma.addToDatabase.findMany()
     * 
     * // Get first 10 AddToDatabases
     * const addToDatabases = await prisma.addToDatabase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addToDatabaseWithIdOnly = await prisma.addToDatabase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddToDatabaseFindManyArgs>(args?: SelectSubset<T, AddToDatabaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddToDatabase.
     * @param {AddToDatabaseCreateArgs} args - Arguments to create a AddToDatabase.
     * @example
     * // Create one AddToDatabase
     * const AddToDatabase = await prisma.addToDatabase.create({
     *   data: {
     *     // ... data to create a AddToDatabase
     *   }
     * })
     * 
     */
    create<T extends AddToDatabaseCreateArgs>(args: SelectSubset<T, AddToDatabaseCreateArgs<ExtArgs>>): Prisma__AddToDatabaseClient<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddToDatabases.
     * @param {AddToDatabaseCreateManyArgs} args - Arguments to create many AddToDatabases.
     * @example
     * // Create many AddToDatabases
     * const addToDatabase = await prisma.addToDatabase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddToDatabaseCreateManyArgs>(args?: SelectSubset<T, AddToDatabaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddToDatabases and returns the data saved in the database.
     * @param {AddToDatabaseCreateManyAndReturnArgs} args - Arguments to create many AddToDatabases.
     * @example
     * // Create many AddToDatabases
     * const addToDatabase = await prisma.addToDatabase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddToDatabases and only return the `id`
     * const addToDatabaseWithIdOnly = await prisma.addToDatabase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddToDatabaseCreateManyAndReturnArgs>(args?: SelectSubset<T, AddToDatabaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AddToDatabase.
     * @param {AddToDatabaseDeleteArgs} args - Arguments to delete one AddToDatabase.
     * @example
     * // Delete one AddToDatabase
     * const AddToDatabase = await prisma.addToDatabase.delete({
     *   where: {
     *     // ... filter to delete one AddToDatabase
     *   }
     * })
     * 
     */
    delete<T extends AddToDatabaseDeleteArgs>(args: SelectSubset<T, AddToDatabaseDeleteArgs<ExtArgs>>): Prisma__AddToDatabaseClient<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddToDatabase.
     * @param {AddToDatabaseUpdateArgs} args - Arguments to update one AddToDatabase.
     * @example
     * // Update one AddToDatabase
     * const addToDatabase = await prisma.addToDatabase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddToDatabaseUpdateArgs>(args: SelectSubset<T, AddToDatabaseUpdateArgs<ExtArgs>>): Prisma__AddToDatabaseClient<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddToDatabases.
     * @param {AddToDatabaseDeleteManyArgs} args - Arguments to filter AddToDatabases to delete.
     * @example
     * // Delete a few AddToDatabases
     * const { count } = await prisma.addToDatabase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddToDatabaseDeleteManyArgs>(args?: SelectSubset<T, AddToDatabaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddToDatabases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToDatabaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddToDatabases
     * const addToDatabase = await prisma.addToDatabase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddToDatabaseUpdateManyArgs>(args: SelectSubset<T, AddToDatabaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddToDatabases and returns the data updated in the database.
     * @param {AddToDatabaseUpdateManyAndReturnArgs} args - Arguments to update many AddToDatabases.
     * @example
     * // Update many AddToDatabases
     * const addToDatabase = await prisma.addToDatabase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AddToDatabases and only return the `id`
     * const addToDatabaseWithIdOnly = await prisma.addToDatabase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddToDatabaseUpdateManyAndReturnArgs>(args: SelectSubset<T, AddToDatabaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AddToDatabase.
     * @param {AddToDatabaseUpsertArgs} args - Arguments to update or create a AddToDatabase.
     * @example
     * // Update or create a AddToDatabase
     * const addToDatabase = await prisma.addToDatabase.upsert({
     *   create: {
     *     // ... data to create a AddToDatabase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddToDatabase we want to update
     *   }
     * })
     */
    upsert<T extends AddToDatabaseUpsertArgs>(args: SelectSubset<T, AddToDatabaseUpsertArgs<ExtArgs>>): Prisma__AddToDatabaseClient<$Result.GetResult<Prisma.$AddToDatabasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddToDatabases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToDatabaseCountArgs} args - Arguments to filter AddToDatabases to count.
     * @example
     * // Count the number of AddToDatabases
     * const count = await prisma.addToDatabase.count({
     *   where: {
     *     // ... the filter for the AddToDatabases we want to count
     *   }
     * })
    **/
    count<T extends AddToDatabaseCountArgs>(
      args?: Subset<T, AddToDatabaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddToDatabaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddToDatabase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToDatabaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddToDatabaseAggregateArgs>(args: Subset<T, AddToDatabaseAggregateArgs>): Prisma.PrismaPromise<GetAddToDatabaseAggregateType<T>>

    /**
     * Group by AddToDatabase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddToDatabaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddToDatabaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddToDatabaseGroupByArgs['orderBy'] }
        : { orderBy?: AddToDatabaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddToDatabaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddToDatabaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddToDatabase model
   */
  readonly fields: AddToDatabaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddToDatabase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddToDatabaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddToDatabase model
   */
  interface AddToDatabaseFieldRefs {
    readonly id: FieldRef<"AddToDatabase", 'String'>
    readonly name: FieldRef<"AddToDatabase", 'String'>
    readonly status: FieldRef<"AddToDatabase", 'AddToDatabaseStatus'>
    readonly levels: FieldRef<"AddToDatabase", 'Json'>
    readonly createdAt: FieldRef<"AddToDatabase", 'DateTime'>
    readonly updatedAt: FieldRef<"AddToDatabase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AddToDatabase findUnique
   */
  export type AddToDatabaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * Filter, which AddToDatabase to fetch.
     */
    where: AddToDatabaseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase findUniqueOrThrow
   */
  export type AddToDatabaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * Filter, which AddToDatabase to fetch.
     */
    where: AddToDatabaseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase findFirst
   */
  export type AddToDatabaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * Filter, which AddToDatabase to fetch.
     */
    where?: AddToDatabaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddToDatabases to fetch.
     */
    orderBy?: AddToDatabaseOrderByWithRelationInput | AddToDatabaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddToDatabases.
     */
    cursor?: AddToDatabaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddToDatabases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddToDatabases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddToDatabases.
     */
    distinct?: AddToDatabaseScalarFieldEnum | AddToDatabaseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase findFirstOrThrow
   */
  export type AddToDatabaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * Filter, which AddToDatabase to fetch.
     */
    where?: AddToDatabaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddToDatabases to fetch.
     */
    orderBy?: AddToDatabaseOrderByWithRelationInput | AddToDatabaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddToDatabases.
     */
    cursor?: AddToDatabaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddToDatabases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddToDatabases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddToDatabases.
     */
    distinct?: AddToDatabaseScalarFieldEnum | AddToDatabaseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase findMany
   */
  export type AddToDatabaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * Filter, which AddToDatabases to fetch.
     */
    where?: AddToDatabaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddToDatabases to fetch.
     */
    orderBy?: AddToDatabaseOrderByWithRelationInput | AddToDatabaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddToDatabases.
     */
    cursor?: AddToDatabaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddToDatabases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddToDatabases.
     */
    skip?: number
    distinct?: AddToDatabaseScalarFieldEnum | AddToDatabaseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase create
   */
  export type AddToDatabaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * The data needed to create a AddToDatabase.
     */
    data: XOR<AddToDatabaseCreateInput, AddToDatabaseUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase createMany
   */
  export type AddToDatabaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddToDatabases.
     */
    data: AddToDatabaseCreateManyInput | AddToDatabaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddToDatabase createManyAndReturn
   */
  export type AddToDatabaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * The data used to create many AddToDatabases.
     */
    data: AddToDatabaseCreateManyInput | AddToDatabaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddToDatabase update
   */
  export type AddToDatabaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * The data needed to update a AddToDatabase.
     */
    data: XOR<AddToDatabaseUpdateInput, AddToDatabaseUncheckedUpdateInput>
    /**
     * Choose, which AddToDatabase to update.
     */
    where: AddToDatabaseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase updateMany
   */
  export type AddToDatabaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddToDatabases.
     */
    data: XOR<AddToDatabaseUpdateManyMutationInput, AddToDatabaseUncheckedUpdateManyInput>
    /**
     * Filter which AddToDatabases to update
     */
    where?: AddToDatabaseWhereInput
    /**
     * Limit how many AddToDatabases to update.
     */
    limit?: number
  }

  /**
   * AddToDatabase updateManyAndReturn
   */
  export type AddToDatabaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * The data used to update AddToDatabases.
     */
    data: XOR<AddToDatabaseUpdateManyMutationInput, AddToDatabaseUncheckedUpdateManyInput>
    /**
     * Filter which AddToDatabases to update
     */
    where?: AddToDatabaseWhereInput
    /**
     * Limit how many AddToDatabases to update.
     */
    limit?: number
  }

  /**
   * AddToDatabase upsert
   */
  export type AddToDatabaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * The filter to search for the AddToDatabase to update in case it exists.
     */
    where: AddToDatabaseWhereUniqueInput
    /**
     * In case the AddToDatabase found by the `where` argument doesn't exist, create a new AddToDatabase with this data.
     */
    create: XOR<AddToDatabaseCreateInput, AddToDatabaseUncheckedCreateInput>
    /**
     * In case the AddToDatabase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddToDatabaseUpdateInput, AddToDatabaseUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase delete
   */
  export type AddToDatabaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
    /**
     * Filter which AddToDatabase to delete.
     */
    where: AddToDatabaseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AddToDatabase deleteMany
   */
  export type AddToDatabaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddToDatabases to delete
     */
    where?: AddToDatabaseWhereInput
    /**
     * Limit how many AddToDatabases to delete.
     */
    limit?: number
  }

  /**
   * AddToDatabase without action
   */
  export type AddToDatabaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddToDatabase
     */
    select?: AddToDatabaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddToDatabase
     */
    omit?: AddToDatabaseOmit<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    title: string | null
    userId: string | null
    visibility: string | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    title: string | null
    userId: string | null
    visibility: string | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    createdAt: number
    title: number
    userId: number
    visibility: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    userId?: true
    visibility?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    userId?: true
    visibility?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    userId?: true
    visibility?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    createdAt: Date
    title: string
    userId: string
    visibility: string
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    userId?: boolean
    visibility?: boolean
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    userId?: boolean
    visibility?: boolean
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    userId?: boolean
    visibility?: boolean
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    userId?: boolean
    visibility?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "title" | "userId" | "visibility", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      title: string
      userId: string
      visibility: string
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {ChatUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly title: FieldRef<"Chat", 'String'>
    readonly userId: FieldRef<"Chat", 'String'>
    readonly visibility: FieldRef<"Chat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat updateManyAndReturn
   */
  export type ChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    chatId: number
    role: number
    parts: number
    attachments: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    chatId?: true
    role?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    role?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    chatId?: true
    role?: true
    parts?: true
    attachments?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    chatId: string
    role: string
    parts: JsonValue
    attachments: JsonValue
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    role?: boolean
    parts?: boolean
    attachments?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    votes?: boolean | Message$votesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    role?: boolean
    parts?: boolean
    attachments?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    role?: boolean
    parts?: boolean
    attachments?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    role?: boolean
    parts?: boolean
    attachments?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "role" | "parts" | "attachments" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    votes?: boolean | Message$votesArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      votes: Prisma.$VotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      role: string
      parts: Prisma.JsonValue
      attachments: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends Message$votesArgs<ExtArgs> = {}>(args?: Subset<T, Message$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly role: FieldRef<"Message", 'String'>
    readonly parts: FieldRef<"Message", 'Json'>
    readonly attachments: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.votes
   */
  export type Message$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteMinAggregateOutputType = {
    chatId: string | null
    messageId: string | null
    isUpvoted: boolean | null
  }

  export type VoteMaxAggregateOutputType = {
    chatId: string | null
    messageId: string | null
    isUpvoted: boolean | null
  }

  export type VoteCountAggregateOutputType = {
    chatId: number
    messageId: number
    isUpvoted: number
    _all: number
  }


  export type VoteMinAggregateInputType = {
    chatId?: true
    messageId?: true
    isUpvoted?: true
  }

  export type VoteMaxAggregateInputType = {
    chatId?: true
    messageId?: true
    isUpvoted?: true
  }

  export type VoteCountAggregateInputType = {
    chatId?: true
    messageId?: true
    isUpvoted?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    chatId: string
    messageId: string
    isUpvoted: boolean
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatId?: boolean
    messageId?: boolean
    isUpvoted?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatId?: boolean
    messageId?: boolean
    isUpvoted?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatId?: boolean
    messageId?: boolean
    isUpvoted?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectScalar = {
    chatId?: boolean
    messageId?: boolean
    isUpvoted?: boolean
  }

  export type VoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chatId" | "messageId" | "isUpvoted", ExtArgs["result"]["vote"]>
  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type VoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type VoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      chatId: string
      messageId: string
      isUpvoted: boolean
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `chatId`
     * const voteWithChatIdOnly = await prisma.vote.findMany({ select: { chatId: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {VoteCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Votes and only return the `chatId`
     * const voteWithChatIdOnly = await prisma.vote.createManyAndReturn({
     *   select: { chatId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoteCreateManyAndReturnArgs>(args?: SelectSubset<T, VoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes and returns the data updated in the database.
     * @param {VoteUpdateManyAndReturnArgs} args - Arguments to update many Votes.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Votes and only return the `chatId`
     * const voteWithChatIdOnly = await prisma.vote.updateManyAndReturn({
     *   select: { chatId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoteUpdateManyAndReturnArgs>(args: SelectSubset<T, VoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly chatId: FieldRef<"Vote", 'String'>
    readonly messageId: FieldRef<"Vote", 'String'>
    readonly isUpvoted: FieldRef<"Vote", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vote createManyAndReturn
   */
  export type VoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
  }

  /**
   * Vote updateManyAndReturn
   */
  export type VoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to delete.
     */
    limit?: number
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    title: string | null
    content: string | null
    kind: string | null
    userId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    title: string | null
    content: string | null
    kind: string | null
    userId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    createdAt: number
    title: number
    content: number
    kind: number
    userId: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    kind?: true
    userId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    kind?: true
    userId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    kind?: true
    userId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    createdAt: Date
    title: string
    content: string | null
    kind: string
    userId: string
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    kind?: boolean
    userId?: boolean
    suggestions?: boolean | Document$suggestionsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    kind?: boolean
    userId?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    kind?: boolean
    userId?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    kind?: boolean
    userId?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "title" | "content" | "kind" | "userId", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suggestions?: boolean | Document$suggestionsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      suggestions: Prisma.$SuggestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      title: string
      content: string | null
      kind: string
      userId: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    suggestions<T extends Document$suggestionsArgs<ExtArgs> = {}>(args?: Subset<T, Document$suggestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly title: FieldRef<"Document", 'String'>
    readonly content: FieldRef<"Document", 'String'>
    readonly kind: FieldRef<"Document", 'String'>
    readonly userId: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.suggestions
   */
  export type Document$suggestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    where?: SuggestionWhereInput
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    cursor?: SuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Suggestion
   */

  export type AggregateSuggestion = {
    _count: SuggestionCountAggregateOutputType | null
    _min: SuggestionMinAggregateOutputType | null
    _max: SuggestionMaxAggregateOutputType | null
  }

  export type SuggestionMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    documentCreatedAt: Date | null
    originalText: string | null
    suggestedText: string | null
    description: string | null
    isResolved: boolean | null
    userId: string | null
    createdAt: Date | null
  }

  export type SuggestionMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    documentCreatedAt: Date | null
    originalText: string | null
    suggestedText: string | null
    description: string | null
    isResolved: boolean | null
    userId: string | null
    createdAt: Date | null
  }

  export type SuggestionCountAggregateOutputType = {
    id: number
    documentId: number
    documentCreatedAt: number
    originalText: number
    suggestedText: number
    description: number
    isResolved: number
    userId: number
    createdAt: number
    _all: number
  }


  export type SuggestionMinAggregateInputType = {
    id?: true
    documentId?: true
    documentCreatedAt?: true
    originalText?: true
    suggestedText?: true
    description?: true
    isResolved?: true
    userId?: true
    createdAt?: true
  }

  export type SuggestionMaxAggregateInputType = {
    id?: true
    documentId?: true
    documentCreatedAt?: true
    originalText?: true
    suggestedText?: true
    description?: true
    isResolved?: true
    userId?: true
    createdAt?: true
  }

  export type SuggestionCountAggregateInputType = {
    id?: true
    documentId?: true
    documentCreatedAt?: true
    originalText?: true
    suggestedText?: true
    description?: true
    isResolved?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type SuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suggestion to aggregate.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suggestions
    **/
    _count?: true | SuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestionMaxAggregateInputType
  }

  export type GetSuggestionAggregateType<T extends SuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestion[P]>
      : GetScalarType<T[P], AggregateSuggestion[P]>
  }




  export type SuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestionWhereInput
    orderBy?: SuggestionOrderByWithAggregationInput | SuggestionOrderByWithAggregationInput[]
    by: SuggestionScalarFieldEnum[] | SuggestionScalarFieldEnum
    having?: SuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestionCountAggregateInputType | true
    _min?: SuggestionMinAggregateInputType
    _max?: SuggestionMaxAggregateInputType
  }

  export type SuggestionGroupByOutputType = {
    id: string
    documentId: string
    documentCreatedAt: Date
    originalText: string
    suggestedText: string
    description: string | null
    isResolved: boolean
    userId: string
    createdAt: Date
    _count: SuggestionCountAggregateOutputType | null
    _min: SuggestionMinAggregateOutputType | null
    _max: SuggestionMaxAggregateOutputType | null
  }

  type GetSuggestionGroupByPayload<T extends SuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestionGroupByOutputType[P]>
        }
      >
    >


  export type SuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentCreatedAt?: boolean
    originalText?: boolean
    suggestedText?: boolean
    description?: boolean
    isResolved?: boolean
    userId?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentCreatedAt?: boolean
    originalText?: boolean
    suggestedText?: boolean
    description?: boolean
    isResolved?: boolean
    userId?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    documentCreatedAt?: boolean
    originalText?: boolean
    suggestedText?: boolean
    description?: boolean
    isResolved?: boolean
    userId?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectScalar = {
    id?: boolean
    documentId?: boolean
    documentCreatedAt?: boolean
    originalText?: boolean
    suggestedText?: boolean
    description?: boolean
    isResolved?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type SuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "documentCreatedAt" | "originalText" | "suggestedText" | "description" | "isResolved" | "userId" | "createdAt", ExtArgs["result"]["suggestion"]>
  export type SuggestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type SuggestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type SuggestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $SuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Suggestion"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      documentCreatedAt: Date
      originalText: string
      suggestedText: string
      description: string | null
      isResolved: boolean
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["suggestion"]>
    composites: {}
  }

  type SuggestionGetPayload<S extends boolean | null | undefined | SuggestionDefaultArgs> = $Result.GetResult<Prisma.$SuggestionPayload, S>

  type SuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SuggestionCountAggregateInputType | true
    }

  export interface SuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Suggestion'], meta: { name: 'Suggestion' } }
    /**
     * Find zero or one Suggestion that matches the filter.
     * @param {SuggestionFindUniqueArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuggestionFindUniqueArgs>(args: SelectSubset<T, SuggestionFindUniqueArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Suggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuggestionFindUniqueOrThrowArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, SuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindFirstArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuggestionFindFirstArgs>(args?: SelectSubset<T, SuggestionFindFirstArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindFirstOrThrowArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, SuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suggestions
     * const suggestions = await prisma.suggestion.findMany()
     * 
     * // Get first 10 Suggestions
     * const suggestions = await prisma.suggestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suggestionWithIdOnly = await prisma.suggestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuggestionFindManyArgs>(args?: SelectSubset<T, SuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Suggestion.
     * @param {SuggestionCreateArgs} args - Arguments to create a Suggestion.
     * @example
     * // Create one Suggestion
     * const Suggestion = await prisma.suggestion.create({
     *   data: {
     *     // ... data to create a Suggestion
     *   }
     * })
     * 
     */
    create<T extends SuggestionCreateArgs>(args: SelectSubset<T, SuggestionCreateArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suggestions.
     * @param {SuggestionCreateManyArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestion = await prisma.suggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuggestionCreateManyArgs>(args?: SelectSubset<T, SuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suggestions and returns the data saved in the database.
     * @param {SuggestionCreateManyAndReturnArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestion = await prisma.suggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suggestions and only return the `id`
     * const suggestionWithIdOnly = await prisma.suggestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, SuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Suggestion.
     * @param {SuggestionDeleteArgs} args - Arguments to delete one Suggestion.
     * @example
     * // Delete one Suggestion
     * const Suggestion = await prisma.suggestion.delete({
     *   where: {
     *     // ... filter to delete one Suggestion
     *   }
     * })
     * 
     */
    delete<T extends SuggestionDeleteArgs>(args: SelectSubset<T, SuggestionDeleteArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Suggestion.
     * @param {SuggestionUpdateArgs} args - Arguments to update one Suggestion.
     * @example
     * // Update one Suggestion
     * const suggestion = await prisma.suggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuggestionUpdateArgs>(args: SelectSubset<T, SuggestionUpdateArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suggestions.
     * @param {SuggestionDeleteManyArgs} args - Arguments to filter Suggestions to delete.
     * @example
     * // Delete a few Suggestions
     * const { count } = await prisma.suggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuggestionDeleteManyArgs>(args?: SelectSubset<T, SuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suggestions
     * const suggestion = await prisma.suggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuggestionUpdateManyArgs>(args: SelectSubset<T, SuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions and returns the data updated in the database.
     * @param {SuggestionUpdateManyAndReturnArgs} args - Arguments to update many Suggestions.
     * @example
     * // Update many Suggestions
     * const suggestion = await prisma.suggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suggestions and only return the `id`
     * const suggestionWithIdOnly = await prisma.suggestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, SuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Suggestion.
     * @param {SuggestionUpsertArgs} args - Arguments to update or create a Suggestion.
     * @example
     * // Update or create a Suggestion
     * const suggestion = await prisma.suggestion.upsert({
     *   create: {
     *     // ... data to create a Suggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suggestion we want to update
     *   }
     * })
     */
    upsert<T extends SuggestionUpsertArgs>(args: SelectSubset<T, SuggestionUpsertArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionCountArgs} args - Arguments to filter Suggestions to count.
     * @example
     * // Count the number of Suggestions
     * const count = await prisma.suggestion.count({
     *   where: {
     *     // ... the filter for the Suggestions we want to count
     *   }
     * })
    **/
    count<T extends SuggestionCountArgs>(
      args?: Subset<T, SuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestionAggregateArgs>(args: Subset<T, SuggestionAggregateArgs>): Prisma.PrismaPromise<GetSuggestionAggregateType<T>>

    /**
     * Group by Suggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuggestionGroupByArgs['orderBy'] }
        : { orderBy?: SuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Suggestion model
   */
  readonly fields: SuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Suggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Suggestion model
   */
  interface SuggestionFieldRefs {
    readonly id: FieldRef<"Suggestion", 'String'>
    readonly documentId: FieldRef<"Suggestion", 'String'>
    readonly documentCreatedAt: FieldRef<"Suggestion", 'DateTime'>
    readonly originalText: FieldRef<"Suggestion", 'String'>
    readonly suggestedText: FieldRef<"Suggestion", 'String'>
    readonly description: FieldRef<"Suggestion", 'String'>
    readonly isResolved: FieldRef<"Suggestion", 'Boolean'>
    readonly userId: FieldRef<"Suggestion", 'String'>
    readonly createdAt: FieldRef<"Suggestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Suggestion findUnique
   */
  export type SuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where: SuggestionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion findUniqueOrThrow
   */
  export type SuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where: SuggestionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion findFirst
   */
  export type SuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suggestions.
     */
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion findFirstOrThrow
   */
  export type SuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suggestions.
     */
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion findMany
   */
  export type SuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter, which Suggestions to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion create
   */
  export type SuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Suggestion.
     */
    data: XOR<SuggestionCreateInput, SuggestionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion createMany
   */
  export type SuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suggestions.
     */
    data: SuggestionCreateManyInput | SuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Suggestion createManyAndReturn
   */
  export type SuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many Suggestions.
     */
    data: SuggestionCreateManyInput | SuggestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Suggestion update
   */
  export type SuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Suggestion.
     */
    data: XOR<SuggestionUpdateInput, SuggestionUncheckedUpdateInput>
    /**
     * Choose, which Suggestion to update.
     */
    where: SuggestionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion updateMany
   */
  export type SuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suggestions.
     */
    data: XOR<SuggestionUpdateManyMutationInput, SuggestionUncheckedUpdateManyInput>
    /**
     * Filter which Suggestions to update
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to update.
     */
    limit?: number
  }

  /**
   * Suggestion updateManyAndReturn
   */
  export type SuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The data used to update Suggestions.
     */
    data: XOR<SuggestionUpdateManyMutationInput, SuggestionUncheckedUpdateManyInput>
    /**
     * Filter which Suggestions to update
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Suggestion upsert
   */
  export type SuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Suggestion to update in case it exists.
     */
    where: SuggestionWhereUniqueInput
    /**
     * In case the Suggestion found by the `where` argument doesn't exist, create a new Suggestion with this data.
     */
    create: XOR<SuggestionCreateInput, SuggestionUncheckedCreateInput>
    /**
     * In case the Suggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuggestionUpdateInput, SuggestionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion delete
   */
  export type SuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
    /**
     * Filter which Suggestion to delete.
     */
    where: SuggestionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Suggestion deleteMany
   */
  export type SuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suggestions to delete
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to delete.
     */
    limit?: number
  }

  /**
   * Suggestion without action
   */
  export type SuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuggestionInclude<ExtArgs> | null
  }


  /**
   * Model ProcessSave
   */

  export type AggregateProcessSave = {
    _count: ProcessSaveCountAggregateOutputType | null
    _min: ProcessSaveMinAggregateOutputType | null
    _max: ProcessSaveMaxAggregateOutputType | null
  }

  export type ProcessSaveMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    isComplete: boolean | null
    createdAt: Date | null
  }

  export type ProcessSaveMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    isComplete: boolean | null
    createdAt: Date | null
  }

  export type ProcessSaveCountAggregateOutputType = {
    id: number
    chatId: number
    rolesData: number
    processData: number
    stepsData: number
    formsData: number
    isComplete: number
    createdAt: number
    _all: number
  }


  export type ProcessSaveMinAggregateInputType = {
    id?: true
    chatId?: true
    isComplete?: true
    createdAt?: true
  }

  export type ProcessSaveMaxAggregateInputType = {
    id?: true
    chatId?: true
    isComplete?: true
    createdAt?: true
  }

  export type ProcessSaveCountAggregateInputType = {
    id?: true
    chatId?: true
    rolesData?: true
    processData?: true
    stepsData?: true
    formsData?: true
    isComplete?: true
    createdAt?: true
    _all?: true
  }

  export type ProcessSaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessSave to aggregate.
     */
    where?: ProcessSaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSaves to fetch.
     */
    orderBy?: ProcessSaveOrderByWithRelationInput | ProcessSaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcessSaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcessSaves
    **/
    _count?: true | ProcessSaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcessSaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcessSaveMaxAggregateInputType
  }

  export type GetProcessSaveAggregateType<T extends ProcessSaveAggregateArgs> = {
        [P in keyof T & keyof AggregateProcessSave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessSave[P]>
      : GetScalarType<T[P], AggregateProcessSave[P]>
  }




  export type ProcessSaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcessSaveWhereInput
    orderBy?: ProcessSaveOrderByWithAggregationInput | ProcessSaveOrderByWithAggregationInput[]
    by: ProcessSaveScalarFieldEnum[] | ProcessSaveScalarFieldEnum
    having?: ProcessSaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcessSaveCountAggregateInputType | true
    _min?: ProcessSaveMinAggregateInputType
    _max?: ProcessSaveMaxAggregateInputType
  }

  export type ProcessSaveGroupByOutputType = {
    id: string
    chatId: string
    rolesData: JsonValue | null
    processData: JsonValue | null
    stepsData: JsonValue | null
    formsData: JsonValue | null
    isComplete: boolean
    createdAt: Date
    _count: ProcessSaveCountAggregateOutputType | null
    _min: ProcessSaveMinAggregateOutputType | null
    _max: ProcessSaveMaxAggregateOutputType | null
  }

  type GetProcessSaveGroupByPayload<T extends ProcessSaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcessSaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcessSaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessSaveGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessSaveGroupByOutputType[P]>
        }
      >
    >


  export type ProcessSaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    rolesData?: boolean
    processData?: boolean
    stepsData?: boolean
    formsData?: boolean
    isComplete?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["processSave"]>

  export type ProcessSaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    rolesData?: boolean
    processData?: boolean
    stepsData?: boolean
    formsData?: boolean
    isComplete?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["processSave"]>

  export type ProcessSaveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    rolesData?: boolean
    processData?: boolean
    stepsData?: boolean
    formsData?: boolean
    isComplete?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["processSave"]>

  export type ProcessSaveSelectScalar = {
    id?: boolean
    chatId?: boolean
    rolesData?: boolean
    processData?: boolean
    stepsData?: boolean
    formsData?: boolean
    isComplete?: boolean
    createdAt?: boolean
  }

  export type ProcessSaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "rolesData" | "processData" | "stepsData" | "formsData" | "isComplete" | "createdAt", ExtArgs["result"]["processSave"]>

  export type $ProcessSavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcessSave"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      rolesData: Prisma.JsonValue | null
      processData: Prisma.JsonValue | null
      stepsData: Prisma.JsonValue | null
      formsData: Prisma.JsonValue | null
      isComplete: boolean
      createdAt: Date
    }, ExtArgs["result"]["processSave"]>
    composites: {}
  }

  type ProcessSaveGetPayload<S extends boolean | null | undefined | ProcessSaveDefaultArgs> = $Result.GetResult<Prisma.$ProcessSavePayload, S>

  type ProcessSaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProcessSaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProcessSaveCountAggregateInputType | true
    }

  export interface ProcessSaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcessSave'], meta: { name: 'ProcessSave' } }
    /**
     * Find zero or one ProcessSave that matches the filter.
     * @param {ProcessSaveFindUniqueArgs} args - Arguments to find a ProcessSave
     * @example
     * // Get one ProcessSave
     * const processSave = await prisma.processSave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessSaveFindUniqueArgs>(args: SelectSubset<T, ProcessSaveFindUniqueArgs<ExtArgs>>): Prisma__ProcessSaveClient<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProcessSave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessSaveFindUniqueOrThrowArgs} args - Arguments to find a ProcessSave
     * @example
     * // Get one ProcessSave
     * const processSave = await prisma.processSave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessSaveFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcessSaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcessSaveClient<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessSave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessSaveFindFirstArgs} args - Arguments to find a ProcessSave
     * @example
     * // Get one ProcessSave
     * const processSave = await prisma.processSave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessSaveFindFirstArgs>(args?: SelectSubset<T, ProcessSaveFindFirstArgs<ExtArgs>>): Prisma__ProcessSaveClient<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProcessSave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessSaveFindFirstOrThrowArgs} args - Arguments to find a ProcessSave
     * @example
     * // Get one ProcessSave
     * const processSave = await prisma.processSave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessSaveFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcessSaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcessSaveClient<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProcessSaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessSaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessSaves
     * const processSaves = await prisma.processSave.findMany()
     * 
     * // Get first 10 ProcessSaves
     * const processSaves = await prisma.processSave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const processSaveWithIdOnly = await prisma.processSave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcessSaveFindManyArgs>(args?: SelectSubset<T, ProcessSaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProcessSave.
     * @param {ProcessSaveCreateArgs} args - Arguments to create a ProcessSave.
     * @example
     * // Create one ProcessSave
     * const ProcessSave = await prisma.processSave.create({
     *   data: {
     *     // ... data to create a ProcessSave
     *   }
     * })
     * 
     */
    create<T extends ProcessSaveCreateArgs>(args: SelectSubset<T, ProcessSaveCreateArgs<ExtArgs>>): Prisma__ProcessSaveClient<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProcessSaves.
     * @param {ProcessSaveCreateManyArgs} args - Arguments to create many ProcessSaves.
     * @example
     * // Create many ProcessSaves
     * const processSave = await prisma.processSave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcessSaveCreateManyArgs>(args?: SelectSubset<T, ProcessSaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcessSaves and returns the data saved in the database.
     * @param {ProcessSaveCreateManyAndReturnArgs} args - Arguments to create many ProcessSaves.
     * @example
     * // Create many ProcessSaves
     * const processSave = await prisma.processSave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcessSaves and only return the `id`
     * const processSaveWithIdOnly = await prisma.processSave.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcessSaveCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcessSaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProcessSave.
     * @param {ProcessSaveDeleteArgs} args - Arguments to delete one ProcessSave.
     * @example
     * // Delete one ProcessSave
     * const ProcessSave = await prisma.processSave.delete({
     *   where: {
     *     // ... filter to delete one ProcessSave
     *   }
     * })
     * 
     */
    delete<T extends ProcessSaveDeleteArgs>(args: SelectSubset<T, ProcessSaveDeleteArgs<ExtArgs>>): Prisma__ProcessSaveClient<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProcessSave.
     * @param {ProcessSaveUpdateArgs} args - Arguments to update one ProcessSave.
     * @example
     * // Update one ProcessSave
     * const processSave = await prisma.processSave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcessSaveUpdateArgs>(args: SelectSubset<T, ProcessSaveUpdateArgs<ExtArgs>>): Prisma__ProcessSaveClient<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProcessSaves.
     * @param {ProcessSaveDeleteManyArgs} args - Arguments to filter ProcessSaves to delete.
     * @example
     * // Delete a few ProcessSaves
     * const { count } = await prisma.processSave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcessSaveDeleteManyArgs>(args?: SelectSubset<T, ProcessSaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessSaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessSaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessSaves
     * const processSave = await prisma.processSave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcessSaveUpdateManyArgs>(args: SelectSubset<T, ProcessSaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcessSaves and returns the data updated in the database.
     * @param {ProcessSaveUpdateManyAndReturnArgs} args - Arguments to update many ProcessSaves.
     * @example
     * // Update many ProcessSaves
     * const processSave = await prisma.processSave.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProcessSaves and only return the `id`
     * const processSaveWithIdOnly = await prisma.processSave.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProcessSaveUpdateManyAndReturnArgs>(args: SelectSubset<T, ProcessSaveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProcessSave.
     * @param {ProcessSaveUpsertArgs} args - Arguments to update or create a ProcessSave.
     * @example
     * // Update or create a ProcessSave
     * const processSave = await prisma.processSave.upsert({
     *   create: {
     *     // ... data to create a ProcessSave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessSave we want to update
     *   }
     * })
     */
    upsert<T extends ProcessSaveUpsertArgs>(args: SelectSubset<T, ProcessSaveUpsertArgs<ExtArgs>>): Prisma__ProcessSaveClient<$Result.GetResult<Prisma.$ProcessSavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProcessSaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessSaveCountArgs} args - Arguments to filter ProcessSaves to count.
     * @example
     * // Count the number of ProcessSaves
     * const count = await prisma.processSave.count({
     *   where: {
     *     // ... the filter for the ProcessSaves we want to count
     *   }
     * })
    **/
    count<T extends ProcessSaveCountArgs>(
      args?: Subset<T, ProcessSaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessSaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcessSave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessSaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcessSaveAggregateArgs>(args: Subset<T, ProcessSaveAggregateArgs>): Prisma.PrismaPromise<GetProcessSaveAggregateType<T>>

    /**
     * Group by ProcessSave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessSaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcessSaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessSaveGroupByArgs['orderBy'] }
        : { orderBy?: ProcessSaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcessSaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcessSaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcessSave model
   */
  readonly fields: ProcessSaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessSave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessSaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcessSave model
   */
  interface ProcessSaveFieldRefs {
    readonly id: FieldRef<"ProcessSave", 'String'>
    readonly chatId: FieldRef<"ProcessSave", 'String'>
    readonly rolesData: FieldRef<"ProcessSave", 'Json'>
    readonly processData: FieldRef<"ProcessSave", 'Json'>
    readonly stepsData: FieldRef<"ProcessSave", 'Json'>
    readonly formsData: FieldRef<"ProcessSave", 'Json'>
    readonly isComplete: FieldRef<"ProcessSave", 'Boolean'>
    readonly createdAt: FieldRef<"ProcessSave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProcessSave findUnique
   */
  export type ProcessSaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * Filter, which ProcessSave to fetch.
     */
    where: ProcessSaveWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave findUniqueOrThrow
   */
  export type ProcessSaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * Filter, which ProcessSave to fetch.
     */
    where: ProcessSaveWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave findFirst
   */
  export type ProcessSaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * Filter, which ProcessSave to fetch.
     */
    where?: ProcessSaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSaves to fetch.
     */
    orderBy?: ProcessSaveOrderByWithRelationInput | ProcessSaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessSaves.
     */
    cursor?: ProcessSaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessSaves.
     */
    distinct?: ProcessSaveScalarFieldEnum | ProcessSaveScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave findFirstOrThrow
   */
  export type ProcessSaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * Filter, which ProcessSave to fetch.
     */
    where?: ProcessSaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSaves to fetch.
     */
    orderBy?: ProcessSaveOrderByWithRelationInput | ProcessSaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcessSaves.
     */
    cursor?: ProcessSaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcessSaves.
     */
    distinct?: ProcessSaveScalarFieldEnum | ProcessSaveScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave findMany
   */
  export type ProcessSaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * Filter, which ProcessSaves to fetch.
     */
    where?: ProcessSaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcessSaves to fetch.
     */
    orderBy?: ProcessSaveOrderByWithRelationInput | ProcessSaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcessSaves.
     */
    cursor?: ProcessSaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcessSaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcessSaves.
     */
    skip?: number
    distinct?: ProcessSaveScalarFieldEnum | ProcessSaveScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave create
   */
  export type ProcessSaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * The data needed to create a ProcessSave.
     */
    data: XOR<ProcessSaveCreateInput, ProcessSaveUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave createMany
   */
  export type ProcessSaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcessSaves.
     */
    data: ProcessSaveCreateManyInput | ProcessSaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessSave createManyAndReturn
   */
  export type ProcessSaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * The data used to create many ProcessSaves.
     */
    data: ProcessSaveCreateManyInput | ProcessSaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcessSave update
   */
  export type ProcessSaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * The data needed to update a ProcessSave.
     */
    data: XOR<ProcessSaveUpdateInput, ProcessSaveUncheckedUpdateInput>
    /**
     * Choose, which ProcessSave to update.
     */
    where: ProcessSaveWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave updateMany
   */
  export type ProcessSaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcessSaves.
     */
    data: XOR<ProcessSaveUpdateManyMutationInput, ProcessSaveUncheckedUpdateManyInput>
    /**
     * Filter which ProcessSaves to update
     */
    where?: ProcessSaveWhereInput
    /**
     * Limit how many ProcessSaves to update.
     */
    limit?: number
  }

  /**
   * ProcessSave updateManyAndReturn
   */
  export type ProcessSaveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * The data used to update ProcessSaves.
     */
    data: XOR<ProcessSaveUpdateManyMutationInput, ProcessSaveUncheckedUpdateManyInput>
    /**
     * Filter which ProcessSaves to update
     */
    where?: ProcessSaveWhereInput
    /**
     * Limit how many ProcessSaves to update.
     */
    limit?: number
  }

  /**
   * ProcessSave upsert
   */
  export type ProcessSaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * The filter to search for the ProcessSave to update in case it exists.
     */
    where: ProcessSaveWhereUniqueInput
    /**
     * In case the ProcessSave found by the `where` argument doesn't exist, create a new ProcessSave with this data.
     */
    create: XOR<ProcessSaveCreateInput, ProcessSaveUncheckedCreateInput>
    /**
     * In case the ProcessSave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessSaveUpdateInput, ProcessSaveUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave delete
   */
  export type ProcessSaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
    /**
     * Filter which ProcessSave to delete.
     */
    where: ProcessSaveWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProcessSave deleteMany
   */
  export type ProcessSaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcessSaves to delete
     */
    where?: ProcessSaveWhereInput
    /**
     * Limit how many ProcessSaves to delete.
     */
    limit?: number
  }

  /**
   * ProcessSave without action
   */
  export type ProcessSaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcessSave
     */
    select?: ProcessSaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProcessSave
     */
    omit?: ProcessSaveOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    photo: 'photo',
    googleId: 'googleId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId',
    status: 'status'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    fileUrl: 'fileUrl',
    thumbnailUrl: 'thumbnailUrl',
    size: 'size',
    isPrivate: 'isPrivate',
    title: 'title',
    userId: 'userId',
    fileType: 'fileType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    status: 'status',
    errorMessage: 'errorMessage'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupRoleScalarFieldEnum: {
    groupId: 'groupId',
    roleId: 'roleId',
    status: 'status'
  };

  export type GroupRoleScalarFieldEnum = (typeof GroupRoleScalarFieldEnum)[keyof typeof GroupRoleScalarFieldEnum]


  export const ProcessScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    groupId: 'groupId',
    creatorId: 'creatorId',
    status: 'status',
    archived: 'archived',
    staffViewForms: 'staffViewForms',
    applicantViewProcessLevel: 'applicantViewProcessLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcessScalarFieldEnum = (typeof ProcessScalarFieldEnum)[keyof typeof ProcessScalarFieldEnum]


  export const ProcessRoleScalarFieldEnum: {
    processId: 'processId',
    roleId: 'roleId',
    status: 'status'
  };

  export type ProcessRoleScalarFieldEnum = (typeof ProcessRoleScalarFieldEnum)[keyof typeof ProcessRoleScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    archived: 'archived',
    creatorId: 'creatorId',
    folderId: 'folderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    design: 'design'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const FormResponseScalarFieldEnum: {
    id: 'id',
    formId: 'formId',
    applicantProcessId: 'applicantProcessId',
    responses: 'responses',
    createdAt: 'createdAt',
    processId: 'processId'
  };

  export type FormResponseScalarFieldEnum = (typeof FormResponseScalarFieldEnum)[keyof typeof FormResponseScalarFieldEnum]


  export const ProcessFormScalarFieldEnum: {
    id: 'id',
    processId: 'processId',
    formId: 'formId',
    order: 'order',
    nextStepType: 'nextStepType',
    nextStepRoles: 'nextStepRoles',
    nextStaffId: 'nextStaffId',
    nextStepSpecifiedTo: 'nextStepSpecifiedTo',
    notificationType: 'notificationType',
    notificationRoles: 'notificationRoles',
    notificationToId: 'notificationToId',
    notificationComment: 'notificationComment',
    notifyApplicant: 'notifyApplicant',
    applicantNotificationContent: 'applicantNotificationContent',
    editApplicationStatus: 'editApplicationStatus',
    applicantViewFormAfterCompletion: 'applicantViewFormAfterCompletion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcessFormScalarFieldEnum = (typeof ProcessFormScalarFieldEnum)[keyof typeof ProcessFormScalarFieldEnum]


  export const ApplicantProcessScalarFieldEnum: {
    id: 'id',
    applicantId: 'applicantId',
    processId: 'processId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ApplicantProcessScalarFieldEnum = (typeof ApplicantProcessScalarFieldEnum)[keyof typeof ApplicantProcessScalarFieldEnum]


  export const ProcessedApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    processId: 'processId',
    applicantProcessId: 'applicantProcessId',
    formId: 'formId',
    formRoleIds: 'formRoleIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcessedApplicationScalarFieldEnum = (typeof ProcessedApplicationScalarFieldEnum)[keyof typeof ProcessedApplicationScalarFieldEnum]


  export const APCompletedFormScalarFieldEnum: {
    id: 'id',
    applicantProcessId: 'applicantProcessId',
    formId: 'formId',
    reviewerId: 'reviewerId',
    nextStaffId: 'nextStaffId',
    nextStepType: 'nextStepType',
    nextStepRoles: 'nextStepRoles',
    nextStepSpecifiedTo: 'nextStepSpecifiedTo',
    notificationType: 'notificationType',
    notificationToId: 'notificationToId',
    notificationToRoles: 'notificationToRoles',
    notificationComment: 'notificationComment',
    notifyApplicant: 'notifyApplicant',
    applicantNotificationContent: 'applicantNotificationContent',
    editApplicationStatus: 'editApplicationStatus',
    applicantViewFormAfterCompletion: 'applicantViewFormAfterCompletion',
    createdAt: 'createdAt'
  };

  export type APCompletedFormScalarFieldEnum = (typeof APCompletedFormScalarFieldEnum)[keyof typeof APCompletedFormScalarFieldEnum]


  export const ProcessCommentScalarFieldEnum: {
    id: 'id',
    applicantProcessId: 'applicantProcessId',
    userId: 'userId',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ProcessCommentScalarFieldEnum = (typeof ProcessCommentScalarFieldEnum)[keyof typeof ProcessCommentScalarFieldEnum]


  export const OrganizationUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    superiorId: 'superiorId',
    title: 'title'
  };

  export type OrganizationUserScalarFieldEnum = (typeof OrganizationUserScalarFieldEnum)[keyof typeof OrganizationUserScalarFieldEnum]


  export const DashboardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ownerId: 'ownerId',
    allowedUsers: 'allowedUsers',
    allowedRoles: 'allowedRoles',
    layout: 'layout',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DashboardScalarFieldEnum = (typeof DashboardScalarFieldEnum)[keyof typeof DashboardScalarFieldEnum]


  export const WidgetScalarFieldEnum: {
    id: 'id',
    dashboardId: 'dashboardId',
    title: 'title',
    visualizationType: 'visualizationType',
    config: 'config',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WidgetScalarFieldEnum = (typeof WidgetScalarFieldEnum)[keyof typeof WidgetScalarFieldEnum]


  export const QrCodeDocumentScalarFieldEnum: {
    id: 'id',
    documentName: 'documentName',
    fileName: 'fileName',
    qrCodeId: 'qrCodeId',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QrCodeDocumentScalarFieldEnum = (typeof QrCodeDocumentScalarFieldEnum)[keyof typeof QrCodeDocumentScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp',
    expiresAt: 'expiresAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const ManagementScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    type: 'type',
    uploadedAt: 'uploadedAt',
    updatedAt: 'updatedAt'
  };

  export type ManagementScalarFieldEnum = (typeof ManagementScalarFieldEnum)[keyof typeof ManagementScalarFieldEnum]


  export const AddToDatabaseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    levels: 'levels',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddToDatabaseScalarFieldEnum = (typeof AddToDatabaseScalarFieldEnum)[keyof typeof AddToDatabaseScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    userId: 'userId',
    visibility: 'visibility'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    role: 'role',
    parts: 'parts',
    attachments: 'attachments',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    chatId: 'chatId',
    messageId: 'messageId',
    isUpvoted: 'isUpvoted'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    content: 'content',
    kind: 'kind',
    userId: 'userId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const SuggestionScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    documentCreatedAt: 'documentCreatedAt',
    originalText: 'originalText',
    suggestedText: 'suggestedText',
    description: 'description',
    isResolved: 'isResolved',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type SuggestionScalarFieldEnum = (typeof SuggestionScalarFieldEnum)[keyof typeof SuggestionScalarFieldEnum]


  export const ProcessSaveScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    rolesData: 'rolesData',
    processData: 'processData',
    stepsData: 'stepsData',
    formsData: 'formsData',
    isComplete: 'isComplete',
    createdAt: 'createdAt'
  };

  export type ProcessSaveScalarFieldEnum = (typeof ProcessSaveScalarFieldEnum)[keyof typeof ProcessSaveScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    photo: 'photo',
    googleId: 'googleId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RoleOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const UserRoleOrderByRelevanceFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleOrderByRelevanceFieldEnum = (typeof UserRoleOrderByRelevanceFieldEnum)[keyof typeof UserRoleOrderByRelevanceFieldEnum]


  export const FileOrderByRelevanceFieldEnum: {
    id: 'id',
    fileUrl: 'fileUrl',
    thumbnailUrl: 'thumbnailUrl',
    title: 'title',
    userId: 'userId',
    fileType: 'fileType'
  };

  export type FileOrderByRelevanceFieldEnum = (typeof FileOrderByRelevanceFieldEnum)[keyof typeof FileOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const AuditLogOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    status: 'status',
    errorMessage: 'errorMessage'
  };

  export type AuditLogOrderByRelevanceFieldEnum = (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum]


  export const GroupOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    creatorId: 'creatorId'
  };

  export type GroupOrderByRelevanceFieldEnum = (typeof GroupOrderByRelevanceFieldEnum)[keyof typeof GroupOrderByRelevanceFieldEnum]


  export const GroupRoleOrderByRelevanceFieldEnum: {
    groupId: 'groupId',
    roleId: 'roleId'
  };

  export type GroupRoleOrderByRelevanceFieldEnum = (typeof GroupRoleOrderByRelevanceFieldEnum)[keyof typeof GroupRoleOrderByRelevanceFieldEnum]


  export const ProcessOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    groupId: 'groupId',
    creatorId: 'creatorId'
  };

  export type ProcessOrderByRelevanceFieldEnum = (typeof ProcessOrderByRelevanceFieldEnum)[keyof typeof ProcessOrderByRelevanceFieldEnum]


  export const ProcessRoleOrderByRelevanceFieldEnum: {
    processId: 'processId',
    roleId: 'roleId'
  };

  export type ProcessRoleOrderByRelevanceFieldEnum = (typeof ProcessRoleOrderByRelevanceFieldEnum)[keyof typeof ProcessRoleOrderByRelevanceFieldEnum]


  export const FolderOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    creatorId: 'creatorId'
  };

  export type FolderOrderByRelevanceFieldEnum = (typeof FolderOrderByRelevanceFieldEnum)[keyof typeof FolderOrderByRelevanceFieldEnum]


  export const FormOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    creatorId: 'creatorId',
    folderId: 'folderId'
  };

  export type FormOrderByRelevanceFieldEnum = (typeof FormOrderByRelevanceFieldEnum)[keyof typeof FormOrderByRelevanceFieldEnum]


  export const FormResponseOrderByRelevanceFieldEnum: {
    id: 'id',
    formId: 'formId',
    applicantProcessId: 'applicantProcessId',
    processId: 'processId'
  };

  export type FormResponseOrderByRelevanceFieldEnum = (typeof FormResponseOrderByRelevanceFieldEnum)[keyof typeof FormResponseOrderByRelevanceFieldEnum]


  export const ProcessFormOrderByRelevanceFieldEnum: {
    id: 'id',
    processId: 'processId',
    formId: 'formId',
    nextStepRoles: 'nextStepRoles',
    nextStaffId: 'nextStaffId',
    nextStepSpecifiedTo: 'nextStepSpecifiedTo',
    notificationRoles: 'notificationRoles',
    notificationToId: 'notificationToId',
    notificationComment: 'notificationComment',
    applicantNotificationContent: 'applicantNotificationContent'
  };

  export type ProcessFormOrderByRelevanceFieldEnum = (typeof ProcessFormOrderByRelevanceFieldEnum)[keyof typeof ProcessFormOrderByRelevanceFieldEnum]


  export const ApplicantProcessOrderByRelevanceFieldEnum: {
    id: 'id',
    applicantId: 'applicantId',
    processId: 'processId'
  };

  export type ApplicantProcessOrderByRelevanceFieldEnum = (typeof ApplicantProcessOrderByRelevanceFieldEnum)[keyof typeof ApplicantProcessOrderByRelevanceFieldEnum]


  export const ProcessedApplicationOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    processId: 'processId',
    applicantProcessId: 'applicantProcessId',
    formId: 'formId',
    formRoleIds: 'formRoleIds'
  };

  export type ProcessedApplicationOrderByRelevanceFieldEnum = (typeof ProcessedApplicationOrderByRelevanceFieldEnum)[keyof typeof ProcessedApplicationOrderByRelevanceFieldEnum]


  export const APCompletedFormOrderByRelevanceFieldEnum: {
    id: 'id',
    applicantProcessId: 'applicantProcessId',
    formId: 'formId',
    reviewerId: 'reviewerId',
    nextStaffId: 'nextStaffId',
    nextStepRoles: 'nextStepRoles',
    nextStepSpecifiedTo: 'nextStepSpecifiedTo',
    notificationToId: 'notificationToId',
    notificationToRoles: 'notificationToRoles',
    notificationComment: 'notificationComment',
    applicantNotificationContent: 'applicantNotificationContent'
  };

  export type APCompletedFormOrderByRelevanceFieldEnum = (typeof APCompletedFormOrderByRelevanceFieldEnum)[keyof typeof APCompletedFormOrderByRelevanceFieldEnum]


  export const ProcessCommentOrderByRelevanceFieldEnum: {
    id: 'id',
    applicantProcessId: 'applicantProcessId',
    userId: 'userId',
    comment: 'comment'
  };

  export type ProcessCommentOrderByRelevanceFieldEnum = (typeof ProcessCommentOrderByRelevanceFieldEnum)[keyof typeof ProcessCommentOrderByRelevanceFieldEnum]


  export const OrganizationUserOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    superiorId: 'superiorId',
    title: 'title'
  };

  export type OrganizationUserOrderByRelevanceFieldEnum = (typeof OrganizationUserOrderByRelevanceFieldEnum)[keyof typeof OrganizationUserOrderByRelevanceFieldEnum]


  export const DashboardOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    ownerId: 'ownerId',
    allowedUsers: 'allowedUsers',
    allowedRoles: 'allowedRoles'
  };

  export type DashboardOrderByRelevanceFieldEnum = (typeof DashboardOrderByRelevanceFieldEnum)[keyof typeof DashboardOrderByRelevanceFieldEnum]


  export const WidgetOrderByRelevanceFieldEnum: {
    id: 'id',
    dashboardId: 'dashboardId',
    title: 'title',
    visualizationType: 'visualizationType'
  };

  export type WidgetOrderByRelevanceFieldEnum = (typeof WidgetOrderByRelevanceFieldEnum)[keyof typeof WidgetOrderByRelevanceFieldEnum]


  export const QrCodeDocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    documentName: 'documentName',
    fileName: 'fileName',
    qrCodeId: 'qrCodeId',
    creatorId: 'creatorId'
  };

  export type QrCodeDocumentOrderByRelevanceFieldEnum = (typeof QrCodeDocumentOrderByRelevanceFieldEnum)[keyof typeof QrCodeDocumentOrderByRelevanceFieldEnum]


  export const OtpOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp'
  };

  export type OtpOrderByRelevanceFieldEnum = (typeof OtpOrderByRelevanceFieldEnum)[keyof typeof OtpOrderByRelevanceFieldEnum]


  export const ManagementOrderByRelevanceFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    fileUrl: 'fileUrl'
  };

  export type ManagementOrderByRelevanceFieldEnum = (typeof ManagementOrderByRelevanceFieldEnum)[keyof typeof ManagementOrderByRelevanceFieldEnum]


  export const AddToDatabaseOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AddToDatabaseOrderByRelevanceFieldEnum = (typeof AddToDatabaseOrderByRelevanceFieldEnum)[keyof typeof AddToDatabaseOrderByRelevanceFieldEnum]


  export const ChatOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    userId: 'userId',
    visibility: 'visibility'
  };

  export type ChatOrderByRelevanceFieldEnum = (typeof ChatOrderByRelevanceFieldEnum)[keyof typeof ChatOrderByRelevanceFieldEnum]


  export const MessageOrderByRelevanceFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    role: 'role'
  };

  export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


  export const VoteOrderByRelevanceFieldEnum: {
    chatId: 'chatId',
    messageId: 'messageId'
  };

  export type VoteOrderByRelevanceFieldEnum = (typeof VoteOrderByRelevanceFieldEnum)[keyof typeof VoteOrderByRelevanceFieldEnum]


  export const DocumentOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    kind: 'kind',
    userId: 'userId'
  };

  export type DocumentOrderByRelevanceFieldEnum = (typeof DocumentOrderByRelevanceFieldEnum)[keyof typeof DocumentOrderByRelevanceFieldEnum]


  export const SuggestionOrderByRelevanceFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    originalText: 'originalText',
    suggestedText: 'suggestedText',
    description: 'description',
    userId: 'userId'
  };

  export type SuggestionOrderByRelevanceFieldEnum = (typeof SuggestionOrderByRelevanceFieldEnum)[keyof typeof SuggestionOrderByRelevanceFieldEnum]


  export const ProcessSaveOrderByRelevanceFieldEnum: {
    id: 'id',
    chatId: 'chatId'
  };

  export type ProcessSaveOrderByRelevanceFieldEnum = (typeof ProcessSaveOrderByRelevanceFieldEnum)[keyof typeof ProcessSaveOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'RoleStatus'
   */
  export type EnumRoleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleStatus'>
    


  /**
   * Reference to a field of type 'RoleStatus[]'
   */
  export type ListEnumRoleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'GroupStatus'
   */
  export type EnumGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupStatus'>
    


  /**
   * Reference to a field of type 'GroupStatus[]'
   */
  export type ListEnumGroupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupStatus[]'>
    


  /**
   * Reference to a field of type 'ProcessType'
   */
  export type EnumProcessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessType'>
    


  /**
   * Reference to a field of type 'ProcessType[]'
   */
  export type ListEnumProcessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessType[]'>
    


  /**
   * Reference to a field of type 'ProcessStatus'
   */
  export type EnumProcessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessStatus'>
    


  /**
   * Reference to a field of type 'ProcessStatus[]'
   */
  export type ListEnumProcessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessStatus[]'>
    


  /**
   * Reference to a field of type 'FormType'
   */
  export type EnumFormTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormType'>
    


  /**
   * Reference to a field of type 'FormType[]'
   */
  export type ListEnumFormTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormType[]'>
    


  /**
   * Reference to a field of type 'FormStatus'
   */
  export type EnumFormStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormStatus'>
    


  /**
   * Reference to a field of type 'FormStatus[]'
   */
  export type ListEnumFormStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormStatus[]'>
    


  /**
   * Reference to a field of type 'NextStepType'
   */
  export type EnumNextStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NextStepType'>
    


  /**
   * Reference to a field of type 'NextStepType[]'
   */
  export type ListEnumNextStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NextStepType[]'>
    


  /**
   * Reference to a field of type 'ManagementType'
   */
  export type EnumManagementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ManagementType'>
    


  /**
   * Reference to a field of type 'ManagementType[]'
   */
  export type ListEnumManagementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ManagementType[]'>
    


  /**
   * Reference to a field of type 'AddToDatabaseStatus'
   */
  export type EnumAddToDatabaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddToDatabaseStatus'>
    


  /**
   * Reference to a field of type 'AddToDatabaseStatus[]'
   */
  export type ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddToDatabaseStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    applicantProcesses?: ApplicantProcessListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    files?: FileListRelationFilter
    createdForms?: FormListRelationFilter
    createdFolders?: FolderListRelationFilter
    createdGroups?: GroupListRelationFilter
    organization?: XOR<OrganizationUserNullableScalarRelationFilter, OrganizationUserWhereInput> | null
    createdProcesses?: ProcessListRelationFilter
    processedApplications?: ProcessedApplicationListRelationFilter
    qrCodeDocuments?: QrCodeDocumentListRelationFilter
    roles?: UserRoleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantProcesses?: ApplicantProcessOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    createdForms?: FormOrderByRelationAggregateInput
    createdFolders?: FolderOrderByRelationAggregateInput
    createdGroups?: GroupOrderByRelationAggregateInput
    organization?: OrganizationUserOrderByWithRelationInput
    createdProcesses?: ProcessOrderByRelationAggregateInput
    processedApplications?: ProcessedApplicationOrderByRelationAggregateInput
    qrCodeDocuments?: QrCodeDocumentOrderByRelationAggregateInput
    roles?: UserRoleOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    applicantProcesses?: ApplicantProcessListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    files?: FileListRelationFilter
    createdForms?: FormListRelationFilter
    createdFolders?: FolderListRelationFilter
    createdGroups?: GroupListRelationFilter
    organization?: XOR<OrganizationUserNullableScalarRelationFilter, OrganizationUserWhereInput> | null
    createdProcesses?: ProcessListRelationFilter
    processedApplications?: ProcessedApplicationListRelationFilter
    qrCodeDocuments?: QrCodeDocumentListRelationFilter
    roles?: UserRoleListRelationFilter
  }, "id" | "email" | "googleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: UuidFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    status?: EnumRoleStatusFilter<"Role"> | $Enums.RoleStatus
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    groups?: GroupRoleListRelationFilter
    processes?: ProcessRoleListRelationFilter
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groups?: GroupRoleOrderByRelationAggregateInput
    processes?: ProcessRoleOrderByRelationAggregateInput
    users?: UserRoleOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    status?: EnumRoleStatusFilter<"Role"> | $Enums.RoleStatus
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    groups?: GroupRoleListRelationFilter
    processes?: ProcessRoleListRelationFilter
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    status?: EnumRoleStatusWithAggregatesFilter<"Role"> | $Enums.RoleStatus
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    status?: EnumRoleStatusFilter<"UserRole"> | $Enums.RoleStatus
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: UserRoleOrderByRelevanceInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    status?: EnumRoleStatusFilter<"UserRole"> | $Enums.RoleStatus
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserRole"> | string
    roleId?: UuidWithAggregatesFilter<"UserRole"> | string
    status?: EnumRoleStatusWithAggregatesFilter<"UserRole"> | $Enums.RoleStatus
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: UuidFilter<"File"> | string
    fileUrl?: StringFilter<"File"> | string
    thumbnailUrl?: StringNullableFilter<"File"> | string | null
    size?: IntFilter<"File"> | number
    isPrivate?: BoolFilter<"File"> | boolean
    title?: StringFilter<"File"> | string
    userId?: UuidFilter<"File"> | string
    fileType?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    size?: SortOrder
    isPrivate?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: FileOrderByRelevanceInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    fileUrl?: StringFilter<"File"> | string
    thumbnailUrl?: StringNullableFilter<"File"> | string | null
    size?: IntFilter<"File"> | number
    isPrivate?: BoolFilter<"File"> | boolean
    title?: StringFilter<"File"> | string
    userId?: UuidFilter<"File"> | string
    fileType?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    size?: SortOrder
    isPrivate?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"File"> | string
    fileUrl?: StringWithAggregatesFilter<"File"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"File"> | string | null
    size?: IntWithAggregatesFilter<"File"> | number
    isPrivate?: BoolWithAggregatesFilter<"File"> | boolean
    title?: StringWithAggregatesFilter<"File"> | string
    userId?: UuidWithAggregatesFilter<"File"> | string
    fileType?: StringWithAggregatesFilter<"File"> | string
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AuditLogOrderByRelevanceInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    userId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    status?: StringWithAggregatesFilter<"AuditLog"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: UuidFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    status?: EnumGroupStatusFilter<"Group"> | $Enums.GroupStatus
    creatorId?: UuidFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    roles?: GroupRoleListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    processes?: ProcessListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: GroupRoleOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    processes?: ProcessOrderByRelationAggregateInput
    _relevance?: GroupOrderByRelevanceInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    status?: EnumGroupStatusFilter<"Group"> | $Enums.GroupStatus
    creatorId?: UuidFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    roles?: GroupRoleListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    processes?: ProcessListRelationFilter
  }, "id" | "name">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    status?: EnumGroupStatusWithAggregatesFilter<"Group"> | $Enums.GroupStatus
    creatorId?: UuidWithAggregatesFilter<"Group"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type GroupRoleWhereInput = {
    AND?: GroupRoleWhereInput | GroupRoleWhereInput[]
    OR?: GroupRoleWhereInput[]
    NOT?: GroupRoleWhereInput | GroupRoleWhereInput[]
    groupId?: UuidFilter<"GroupRole"> | string
    roleId?: UuidFilter<"GroupRole"> | string
    status?: EnumRoleStatusFilter<"GroupRole"> | $Enums.RoleStatus
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type GroupRoleOrderByWithRelationInput = {
    groupId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    group?: GroupOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    _relevance?: GroupRoleOrderByRelevanceInput
  }

  export type GroupRoleWhereUniqueInput = Prisma.AtLeast<{
    groupId_roleId?: GroupRoleGroupIdRoleIdCompoundUniqueInput
    AND?: GroupRoleWhereInput | GroupRoleWhereInput[]
    OR?: GroupRoleWhereInput[]
    NOT?: GroupRoleWhereInput | GroupRoleWhereInput[]
    groupId?: UuidFilter<"GroupRole"> | string
    roleId?: UuidFilter<"GroupRole"> | string
    status?: EnumRoleStatusFilter<"GroupRole"> | $Enums.RoleStatus
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "groupId_roleId">

  export type GroupRoleOrderByWithAggregationInput = {
    groupId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    _count?: GroupRoleCountOrderByAggregateInput
    _max?: GroupRoleMaxOrderByAggregateInput
    _min?: GroupRoleMinOrderByAggregateInput
  }

  export type GroupRoleScalarWhereWithAggregatesInput = {
    AND?: GroupRoleScalarWhereWithAggregatesInput | GroupRoleScalarWhereWithAggregatesInput[]
    OR?: GroupRoleScalarWhereWithAggregatesInput[]
    NOT?: GroupRoleScalarWhereWithAggregatesInput | GroupRoleScalarWhereWithAggregatesInput[]
    groupId?: UuidWithAggregatesFilter<"GroupRole"> | string
    roleId?: UuidWithAggregatesFilter<"GroupRole"> | string
    status?: EnumRoleStatusWithAggregatesFilter<"GroupRole"> | $Enums.RoleStatus
  }

  export type ProcessWhereInput = {
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    id?: UuidFilter<"Process"> | string
    name?: StringFilter<"Process"> | string
    type?: EnumProcessTypeFilter<"Process"> | $Enums.ProcessType
    groupId?: UuidFilter<"Process"> | string
    creatorId?: UuidFilter<"Process"> | string
    status?: EnumProcessStatusFilter<"Process"> | $Enums.ProcessStatus
    archived?: BoolFilter<"Process"> | boolean
    staffViewForms?: BoolFilter<"Process"> | boolean
    applicantViewProcessLevel?: BoolFilter<"Process"> | boolean
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
    applicantProcesses?: ApplicantProcessListRelationFilter
    formResponses?: FormResponseListRelationFilter
    forms?: ProcessFormListRelationFilter
    processedApplications?: ProcessedApplicationListRelationFilter
    roles?: ProcessRoleListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type ProcessOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    staffViewForms?: SortOrder
    applicantViewProcessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applicantProcesses?: ApplicantProcessOrderByRelationAggregateInput
    formResponses?: FormResponseOrderByRelationAggregateInput
    forms?: ProcessFormOrderByRelationAggregateInput
    processedApplications?: ProcessedApplicationOrderByRelationAggregateInput
    roles?: ProcessRoleOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
    _relevance?: ProcessOrderByRelevanceInput
  }

  export type ProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessWhereInput | ProcessWhereInput[]
    OR?: ProcessWhereInput[]
    NOT?: ProcessWhereInput | ProcessWhereInput[]
    name?: StringFilter<"Process"> | string
    type?: EnumProcessTypeFilter<"Process"> | $Enums.ProcessType
    groupId?: UuidFilter<"Process"> | string
    creatorId?: UuidFilter<"Process"> | string
    status?: EnumProcessStatusFilter<"Process"> | $Enums.ProcessStatus
    archived?: BoolFilter<"Process"> | boolean
    staffViewForms?: BoolFilter<"Process"> | boolean
    applicantViewProcessLevel?: BoolFilter<"Process"> | boolean
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
    applicantProcesses?: ApplicantProcessListRelationFilter
    formResponses?: FormResponseListRelationFilter
    forms?: ProcessFormListRelationFilter
    processedApplications?: ProcessedApplicationListRelationFilter
    roles?: ProcessRoleListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id">

  export type ProcessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    staffViewForms?: SortOrder
    applicantViewProcessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcessCountOrderByAggregateInput
    _max?: ProcessMaxOrderByAggregateInput
    _min?: ProcessMinOrderByAggregateInput
  }

  export type ProcessScalarWhereWithAggregatesInput = {
    AND?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    OR?: ProcessScalarWhereWithAggregatesInput[]
    NOT?: ProcessScalarWhereWithAggregatesInput | ProcessScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Process"> | string
    name?: StringWithAggregatesFilter<"Process"> | string
    type?: EnumProcessTypeWithAggregatesFilter<"Process"> | $Enums.ProcessType
    groupId?: UuidWithAggregatesFilter<"Process"> | string
    creatorId?: UuidWithAggregatesFilter<"Process"> | string
    status?: EnumProcessStatusWithAggregatesFilter<"Process"> | $Enums.ProcessStatus
    archived?: BoolWithAggregatesFilter<"Process"> | boolean
    staffViewForms?: BoolWithAggregatesFilter<"Process"> | boolean
    applicantViewProcessLevel?: BoolWithAggregatesFilter<"Process"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Process"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Process"> | Date | string
  }

  export type ProcessRoleWhereInput = {
    AND?: ProcessRoleWhereInput | ProcessRoleWhereInput[]
    OR?: ProcessRoleWhereInput[]
    NOT?: ProcessRoleWhereInput | ProcessRoleWhereInput[]
    processId?: UuidFilter<"ProcessRole"> | string
    roleId?: UuidFilter<"ProcessRole"> | string
    status?: EnumRoleStatusFilter<"ProcessRole"> | $Enums.RoleStatus
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type ProcessRoleOrderByWithRelationInput = {
    processId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    process?: ProcessOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    _relevance?: ProcessRoleOrderByRelevanceInput
  }

  export type ProcessRoleWhereUniqueInput = Prisma.AtLeast<{
    processId_roleId?: ProcessRoleProcessIdRoleIdCompoundUniqueInput
    AND?: ProcessRoleWhereInput | ProcessRoleWhereInput[]
    OR?: ProcessRoleWhereInput[]
    NOT?: ProcessRoleWhereInput | ProcessRoleWhereInput[]
    processId?: UuidFilter<"ProcessRole"> | string
    roleId?: UuidFilter<"ProcessRole"> | string
    status?: EnumRoleStatusFilter<"ProcessRole"> | $Enums.RoleStatus
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "processId_roleId">

  export type ProcessRoleOrderByWithAggregationInput = {
    processId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    _count?: ProcessRoleCountOrderByAggregateInput
    _max?: ProcessRoleMaxOrderByAggregateInput
    _min?: ProcessRoleMinOrderByAggregateInput
  }

  export type ProcessRoleScalarWhereWithAggregatesInput = {
    AND?: ProcessRoleScalarWhereWithAggregatesInput | ProcessRoleScalarWhereWithAggregatesInput[]
    OR?: ProcessRoleScalarWhereWithAggregatesInput[]
    NOT?: ProcessRoleScalarWhereWithAggregatesInput | ProcessRoleScalarWhereWithAggregatesInput[]
    processId?: UuidWithAggregatesFilter<"ProcessRole"> | string
    roleId?: UuidWithAggregatesFilter<"ProcessRole"> | string
    status?: EnumRoleStatusWithAggregatesFilter<"ProcessRole"> | $Enums.RoleStatus
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: UuidFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    creatorId?: UuidFilter<"Folder"> | string
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    forms?: FormListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    forms?: FormOrderByRelationAggregateInput
    _relevance?: FolderOrderByRelevanceInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    creatorId?: UuidFilter<"Folder"> | string
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    forms?: FormListRelationFilter
  }, "id">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
    description?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    creatorId?: UuidWithAggregatesFilter<"Folder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
  }

  export type FormWhereInput = {
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    id?: UuidFilter<"Form"> | string
    name?: StringFilter<"Form"> | string
    type?: EnumFormTypeFilter<"Form"> | $Enums.FormType
    status?: EnumFormStatusFilter<"Form"> | $Enums.FormStatus
    archived?: BoolFilter<"Form"> | boolean
    creatorId?: UuidFilter<"Form"> | string
    folderId?: UuidNullableFilter<"Form"> | string | null
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    design?: JsonNullableFilter<"Form">
    responses?: FormResponseListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    processForms?: ProcessFormListRelationFilter
  }

  export type FormOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    creatorId?: SortOrder
    folderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    design?: SortOrderInput | SortOrder
    responses?: FormResponseOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    folder?: FolderOrderByWithRelationInput
    processForms?: ProcessFormOrderByRelationAggregateInput
    _relevance?: FormOrderByRelevanceInput
  }

  export type FormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormWhereInput | FormWhereInput[]
    OR?: FormWhereInput[]
    NOT?: FormWhereInput | FormWhereInput[]
    name?: StringFilter<"Form"> | string
    type?: EnumFormTypeFilter<"Form"> | $Enums.FormType
    status?: EnumFormStatusFilter<"Form"> | $Enums.FormStatus
    archived?: BoolFilter<"Form"> | boolean
    creatorId?: UuidFilter<"Form"> | string
    folderId?: UuidNullableFilter<"Form"> | string | null
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    design?: JsonNullableFilter<"Form">
    responses?: FormResponseListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    processForms?: ProcessFormListRelationFilter
  }, "id">

  export type FormOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    creatorId?: SortOrder
    folderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    design?: SortOrderInput | SortOrder
    _count?: FormCountOrderByAggregateInput
    _max?: FormMaxOrderByAggregateInput
    _min?: FormMinOrderByAggregateInput
  }

  export type FormScalarWhereWithAggregatesInput = {
    AND?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    OR?: FormScalarWhereWithAggregatesInput[]
    NOT?: FormScalarWhereWithAggregatesInput | FormScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Form"> | string
    name?: StringWithAggregatesFilter<"Form"> | string
    type?: EnumFormTypeWithAggregatesFilter<"Form"> | $Enums.FormType
    status?: EnumFormStatusWithAggregatesFilter<"Form"> | $Enums.FormStatus
    archived?: BoolWithAggregatesFilter<"Form"> | boolean
    creatorId?: UuidWithAggregatesFilter<"Form"> | string
    folderId?: UuidNullableWithAggregatesFilter<"Form"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Form"> | Date | string
    design?: JsonNullableWithAggregatesFilter<"Form">
  }

  export type FormResponseWhereInput = {
    AND?: FormResponseWhereInput | FormResponseWhereInput[]
    OR?: FormResponseWhereInput[]
    NOT?: FormResponseWhereInput | FormResponseWhereInput[]
    id?: UuidFilter<"FormResponse"> | string
    formId?: UuidFilter<"FormResponse"> | string
    applicantProcessId?: UuidFilter<"FormResponse"> | string
    responses?: JsonFilter<"FormResponse">
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
    processId?: UuidFilter<"FormResponse"> | string
    applicantProcess?: XOR<ApplicantProcessScalarRelationFilter, ApplicantProcessWhereInput>
    form?: XOR<FormScalarRelationFilter, FormWhereInput>
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
  }

  export type FormResponseOrderByWithRelationInput = {
    id?: SortOrder
    formId?: SortOrder
    applicantProcessId?: SortOrder
    responses?: SortOrder
    createdAt?: SortOrder
    processId?: SortOrder
    applicantProcess?: ApplicantProcessOrderByWithRelationInput
    form?: FormOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
    _relevance?: FormResponseOrderByRelevanceInput
  }

  export type FormResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    formId_applicantProcessId?: FormResponseFormIdApplicantProcessIdCompoundUniqueInput
    AND?: FormResponseWhereInput | FormResponseWhereInput[]
    OR?: FormResponseWhereInput[]
    NOT?: FormResponseWhereInput | FormResponseWhereInput[]
    formId?: UuidFilter<"FormResponse"> | string
    applicantProcessId?: UuidFilter<"FormResponse"> | string
    responses?: JsonFilter<"FormResponse">
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
    processId?: UuidFilter<"FormResponse"> | string
    applicantProcess?: XOR<ApplicantProcessScalarRelationFilter, ApplicantProcessWhereInput>
    form?: XOR<FormScalarRelationFilter, FormWhereInput>
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
  }, "id" | "formId_applicantProcessId">

  export type FormResponseOrderByWithAggregationInput = {
    id?: SortOrder
    formId?: SortOrder
    applicantProcessId?: SortOrder
    responses?: SortOrder
    createdAt?: SortOrder
    processId?: SortOrder
    _count?: FormResponseCountOrderByAggregateInput
    _max?: FormResponseMaxOrderByAggregateInput
    _min?: FormResponseMinOrderByAggregateInput
  }

  export type FormResponseScalarWhereWithAggregatesInput = {
    AND?: FormResponseScalarWhereWithAggregatesInput | FormResponseScalarWhereWithAggregatesInput[]
    OR?: FormResponseScalarWhereWithAggregatesInput[]
    NOT?: FormResponseScalarWhereWithAggregatesInput | FormResponseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FormResponse"> | string
    formId?: UuidWithAggregatesFilter<"FormResponse"> | string
    applicantProcessId?: UuidWithAggregatesFilter<"FormResponse"> | string
    responses?: JsonWithAggregatesFilter<"FormResponse">
    createdAt?: DateTimeWithAggregatesFilter<"FormResponse"> | Date | string
    processId?: UuidWithAggregatesFilter<"FormResponse"> | string
  }

  export type ProcessFormWhereInput = {
    AND?: ProcessFormWhereInput | ProcessFormWhereInput[]
    OR?: ProcessFormWhereInput[]
    NOT?: ProcessFormWhereInput | ProcessFormWhereInput[]
    id?: UuidFilter<"ProcessForm"> | string
    processId?: UuidFilter<"ProcessForm"> | string
    formId?: UuidFilter<"ProcessForm"> | string
    order?: IntFilter<"ProcessForm"> | number
    nextStepType?: EnumNextStepTypeFilter<"ProcessForm"> | $Enums.NextStepType
    nextStepRoles?: StringNullableListFilter<"ProcessForm">
    nextStaffId?: UuidNullableFilter<"ProcessForm"> | string | null
    nextStepSpecifiedTo?: StringNullableFilter<"ProcessForm"> | string | null
    notificationType?: EnumNextStepTypeFilter<"ProcessForm"> | $Enums.NextStepType
    notificationRoles?: StringNullableListFilter<"ProcessForm">
    notificationToId?: UuidNullableFilter<"ProcessForm"> | string | null
    notificationComment?: StringNullableFilter<"ProcessForm"> | string | null
    notifyApplicant?: BoolFilter<"ProcessForm"> | boolean
    applicantNotificationContent?: StringNullableFilter<"ProcessForm"> | string | null
    editApplicationStatus?: BoolFilter<"ProcessForm"> | boolean
    applicantViewFormAfterCompletion?: BoolFilter<"ProcessForm"> | boolean
    createdAt?: DateTimeFilter<"ProcessForm"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessForm"> | Date | string
    form?: XOR<FormScalarRelationFilter, FormWhereInput>
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
  }

  export type ProcessFormOrderByWithRelationInput = {
    id?: SortOrder
    processId?: SortOrder
    formId?: SortOrder
    order?: SortOrder
    nextStepType?: SortOrder
    nextStepRoles?: SortOrder
    nextStaffId?: SortOrderInput | SortOrder
    nextStepSpecifiedTo?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    notificationRoles?: SortOrder
    notificationToId?: SortOrderInput | SortOrder
    notificationComment?: SortOrderInput | SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrderInput | SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    form?: FormOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
    _relevance?: ProcessFormOrderByRelevanceInput
  }

  export type ProcessFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessFormWhereInput | ProcessFormWhereInput[]
    OR?: ProcessFormWhereInput[]
    NOT?: ProcessFormWhereInput | ProcessFormWhereInput[]
    processId?: UuidFilter<"ProcessForm"> | string
    formId?: UuidFilter<"ProcessForm"> | string
    order?: IntFilter<"ProcessForm"> | number
    nextStepType?: EnumNextStepTypeFilter<"ProcessForm"> | $Enums.NextStepType
    nextStepRoles?: StringNullableListFilter<"ProcessForm">
    nextStaffId?: UuidNullableFilter<"ProcessForm"> | string | null
    nextStepSpecifiedTo?: StringNullableFilter<"ProcessForm"> | string | null
    notificationType?: EnumNextStepTypeFilter<"ProcessForm"> | $Enums.NextStepType
    notificationRoles?: StringNullableListFilter<"ProcessForm">
    notificationToId?: UuidNullableFilter<"ProcessForm"> | string | null
    notificationComment?: StringNullableFilter<"ProcessForm"> | string | null
    notifyApplicant?: BoolFilter<"ProcessForm"> | boolean
    applicantNotificationContent?: StringNullableFilter<"ProcessForm"> | string | null
    editApplicationStatus?: BoolFilter<"ProcessForm"> | boolean
    applicantViewFormAfterCompletion?: BoolFilter<"ProcessForm"> | boolean
    createdAt?: DateTimeFilter<"ProcessForm"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessForm"> | Date | string
    form?: XOR<FormScalarRelationFilter, FormWhereInput>
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
  }, "id">

  export type ProcessFormOrderByWithAggregationInput = {
    id?: SortOrder
    processId?: SortOrder
    formId?: SortOrder
    order?: SortOrder
    nextStepType?: SortOrder
    nextStepRoles?: SortOrder
    nextStaffId?: SortOrderInput | SortOrder
    nextStepSpecifiedTo?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    notificationRoles?: SortOrder
    notificationToId?: SortOrderInput | SortOrder
    notificationComment?: SortOrderInput | SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrderInput | SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcessFormCountOrderByAggregateInput
    _avg?: ProcessFormAvgOrderByAggregateInput
    _max?: ProcessFormMaxOrderByAggregateInput
    _min?: ProcessFormMinOrderByAggregateInput
    _sum?: ProcessFormSumOrderByAggregateInput
  }

  export type ProcessFormScalarWhereWithAggregatesInput = {
    AND?: ProcessFormScalarWhereWithAggregatesInput | ProcessFormScalarWhereWithAggregatesInput[]
    OR?: ProcessFormScalarWhereWithAggregatesInput[]
    NOT?: ProcessFormScalarWhereWithAggregatesInput | ProcessFormScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProcessForm"> | string
    processId?: UuidWithAggregatesFilter<"ProcessForm"> | string
    formId?: UuidWithAggregatesFilter<"ProcessForm"> | string
    order?: IntWithAggregatesFilter<"ProcessForm"> | number
    nextStepType?: EnumNextStepTypeWithAggregatesFilter<"ProcessForm"> | $Enums.NextStepType
    nextStepRoles?: StringNullableListFilter<"ProcessForm">
    nextStaffId?: UuidNullableWithAggregatesFilter<"ProcessForm"> | string | null
    nextStepSpecifiedTo?: StringNullableWithAggregatesFilter<"ProcessForm"> | string | null
    notificationType?: EnumNextStepTypeWithAggregatesFilter<"ProcessForm"> | $Enums.NextStepType
    notificationRoles?: StringNullableListFilter<"ProcessForm">
    notificationToId?: UuidNullableWithAggregatesFilter<"ProcessForm"> | string | null
    notificationComment?: StringNullableWithAggregatesFilter<"ProcessForm"> | string | null
    notifyApplicant?: BoolWithAggregatesFilter<"ProcessForm"> | boolean
    applicantNotificationContent?: StringNullableWithAggregatesFilter<"ProcessForm"> | string | null
    editApplicationStatus?: BoolWithAggregatesFilter<"ProcessForm"> | boolean
    applicantViewFormAfterCompletion?: BoolWithAggregatesFilter<"ProcessForm"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProcessForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcessForm"> | Date | string
  }

  export type ApplicantProcessWhereInput = {
    AND?: ApplicantProcessWhereInput | ApplicantProcessWhereInput[]
    OR?: ApplicantProcessWhereInput[]
    NOT?: ApplicantProcessWhereInput | ApplicantProcessWhereInput[]
    id?: UuidFilter<"ApplicantProcess"> | string
    applicantId?: UuidFilter<"ApplicantProcess"> | string
    processId?: UuidFilter<"ApplicantProcess"> | string
    status?: EnumProcessStatusFilter<"ApplicantProcess"> | $Enums.ProcessStatus
    createdAt?: DateTimeFilter<"ApplicantProcess"> | Date | string
    completedForms?: APCompletedFormListRelationFilter
    applicant?: XOR<UserScalarRelationFilter, UserWhereInput>
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    processedApplications?: ProcessedApplicationListRelationFilter
    responses?: FormResponseListRelationFilter
    comments?: ProcessCommentListRelationFilter
  }

  export type ApplicantProcessOrderByWithRelationInput = {
    id?: SortOrder
    applicantId?: SortOrder
    processId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedForms?: APCompletedFormOrderByRelationAggregateInput
    applicant?: UserOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
    processedApplications?: ProcessedApplicationOrderByRelationAggregateInput
    responses?: FormResponseOrderByRelationAggregateInput
    comments?: ProcessCommentOrderByRelationAggregateInput
    _relevance?: ApplicantProcessOrderByRelevanceInput
  }

  export type ApplicantProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApplicantProcessWhereInput | ApplicantProcessWhereInput[]
    OR?: ApplicantProcessWhereInput[]
    NOT?: ApplicantProcessWhereInput | ApplicantProcessWhereInput[]
    applicantId?: UuidFilter<"ApplicantProcess"> | string
    processId?: UuidFilter<"ApplicantProcess"> | string
    status?: EnumProcessStatusFilter<"ApplicantProcess"> | $Enums.ProcessStatus
    createdAt?: DateTimeFilter<"ApplicantProcess"> | Date | string
    completedForms?: APCompletedFormListRelationFilter
    applicant?: XOR<UserScalarRelationFilter, UserWhereInput>
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    processedApplications?: ProcessedApplicationListRelationFilter
    responses?: FormResponseListRelationFilter
    comments?: ProcessCommentListRelationFilter
  }, "id">

  export type ApplicantProcessOrderByWithAggregationInput = {
    id?: SortOrder
    applicantId?: SortOrder
    processId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ApplicantProcessCountOrderByAggregateInput
    _max?: ApplicantProcessMaxOrderByAggregateInput
    _min?: ApplicantProcessMinOrderByAggregateInput
  }

  export type ApplicantProcessScalarWhereWithAggregatesInput = {
    AND?: ApplicantProcessScalarWhereWithAggregatesInput | ApplicantProcessScalarWhereWithAggregatesInput[]
    OR?: ApplicantProcessScalarWhereWithAggregatesInput[]
    NOT?: ApplicantProcessScalarWhereWithAggregatesInput | ApplicantProcessScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ApplicantProcess"> | string
    applicantId?: UuidWithAggregatesFilter<"ApplicantProcess"> | string
    processId?: UuidWithAggregatesFilter<"ApplicantProcess"> | string
    status?: EnumProcessStatusWithAggregatesFilter<"ApplicantProcess"> | $Enums.ProcessStatus
    createdAt?: DateTimeWithAggregatesFilter<"ApplicantProcess"> | Date | string
  }

  export type ProcessedApplicationWhereInput = {
    AND?: ProcessedApplicationWhereInput | ProcessedApplicationWhereInput[]
    OR?: ProcessedApplicationWhereInput[]
    NOT?: ProcessedApplicationWhereInput | ProcessedApplicationWhereInput[]
    id?: UuidFilter<"ProcessedApplication"> | string
    userId?: UuidFilter<"ProcessedApplication"> | string
    processId?: UuidFilter<"ProcessedApplication"> | string
    applicantProcessId?: UuidFilter<"ProcessedApplication"> | string
    formId?: UuidFilter<"ProcessedApplication"> | string
    formRoleIds?: StringNullableListFilter<"ProcessedApplication">
    createdAt?: DateTimeFilter<"ProcessedApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessedApplication"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    applicantProcess?: XOR<ApplicantProcessScalarRelationFilter, ApplicantProcessWhereInput>
  }

  export type ProcessedApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    processId?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    formRoleIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    process?: ProcessOrderByWithRelationInput
    applicantProcess?: ApplicantProcessOrderByWithRelationInput
    _relevance?: ProcessedApplicationOrderByRelevanceInput
  }

  export type ProcessedApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessedApplicationWhereInput | ProcessedApplicationWhereInput[]
    OR?: ProcessedApplicationWhereInput[]
    NOT?: ProcessedApplicationWhereInput | ProcessedApplicationWhereInput[]
    userId?: UuidFilter<"ProcessedApplication"> | string
    processId?: UuidFilter<"ProcessedApplication"> | string
    applicantProcessId?: UuidFilter<"ProcessedApplication"> | string
    formId?: UuidFilter<"ProcessedApplication"> | string
    formRoleIds?: StringNullableListFilter<"ProcessedApplication">
    createdAt?: DateTimeFilter<"ProcessedApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessedApplication"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    process?: XOR<ProcessScalarRelationFilter, ProcessWhereInput>
    applicantProcess?: XOR<ApplicantProcessScalarRelationFilter, ApplicantProcessWhereInput>
  }, "id">

  export type ProcessedApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    processId?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    formRoleIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcessedApplicationCountOrderByAggregateInput
    _max?: ProcessedApplicationMaxOrderByAggregateInput
    _min?: ProcessedApplicationMinOrderByAggregateInput
  }

  export type ProcessedApplicationScalarWhereWithAggregatesInput = {
    AND?: ProcessedApplicationScalarWhereWithAggregatesInput | ProcessedApplicationScalarWhereWithAggregatesInput[]
    OR?: ProcessedApplicationScalarWhereWithAggregatesInput[]
    NOT?: ProcessedApplicationScalarWhereWithAggregatesInput | ProcessedApplicationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProcessedApplication"> | string
    userId?: UuidWithAggregatesFilter<"ProcessedApplication"> | string
    processId?: UuidWithAggregatesFilter<"ProcessedApplication"> | string
    applicantProcessId?: UuidWithAggregatesFilter<"ProcessedApplication"> | string
    formId?: UuidWithAggregatesFilter<"ProcessedApplication"> | string
    formRoleIds?: StringNullableListFilter<"ProcessedApplication">
    createdAt?: DateTimeWithAggregatesFilter<"ProcessedApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcessedApplication"> | Date | string
  }

  export type APCompletedFormWhereInput = {
    AND?: APCompletedFormWhereInput | APCompletedFormWhereInput[]
    OR?: APCompletedFormWhereInput[]
    NOT?: APCompletedFormWhereInput | APCompletedFormWhereInput[]
    id?: UuidFilter<"APCompletedForm"> | string
    applicantProcessId?: UuidFilter<"APCompletedForm"> | string
    formId?: UuidFilter<"APCompletedForm"> | string
    reviewerId?: UuidNullableFilter<"APCompletedForm"> | string | null
    nextStaffId?: UuidNullableFilter<"APCompletedForm"> | string | null
    nextStepType?: EnumNextStepTypeFilter<"APCompletedForm"> | $Enums.NextStepType
    nextStepRoles?: StringNullableListFilter<"APCompletedForm">
    nextStepSpecifiedTo?: StringNullableFilter<"APCompletedForm"> | string | null
    notificationType?: EnumNextStepTypeFilter<"APCompletedForm"> | $Enums.NextStepType
    notificationToId?: UuidNullableFilter<"APCompletedForm"> | string | null
    notificationToRoles?: StringNullableListFilter<"APCompletedForm">
    notificationComment?: StringNullableFilter<"APCompletedForm"> | string | null
    notifyApplicant?: BoolFilter<"APCompletedForm"> | boolean
    applicantNotificationContent?: StringNullableFilter<"APCompletedForm"> | string | null
    editApplicationStatus?: BoolFilter<"APCompletedForm"> | boolean
    applicantViewFormAfterCompletion?: BoolFilter<"APCompletedForm"> | boolean
    createdAt?: DateTimeFilter<"APCompletedForm"> | Date | string
    applicantProcess?: XOR<ApplicantProcessScalarRelationFilter, ApplicantProcessWhereInput>
  }

  export type APCompletedFormOrderByWithRelationInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    reviewerId?: SortOrderInput | SortOrder
    nextStaffId?: SortOrderInput | SortOrder
    nextStepType?: SortOrder
    nextStepRoles?: SortOrder
    nextStepSpecifiedTo?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    notificationToId?: SortOrderInput | SortOrder
    notificationToRoles?: SortOrder
    notificationComment?: SortOrderInput | SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrderInput | SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
    applicantProcess?: ApplicantProcessOrderByWithRelationInput
    _relevance?: APCompletedFormOrderByRelevanceInput
  }

  export type APCompletedFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: APCompletedFormWhereInput | APCompletedFormWhereInput[]
    OR?: APCompletedFormWhereInput[]
    NOT?: APCompletedFormWhereInput | APCompletedFormWhereInput[]
    applicantProcessId?: UuidFilter<"APCompletedForm"> | string
    formId?: UuidFilter<"APCompletedForm"> | string
    reviewerId?: UuidNullableFilter<"APCompletedForm"> | string | null
    nextStaffId?: UuidNullableFilter<"APCompletedForm"> | string | null
    nextStepType?: EnumNextStepTypeFilter<"APCompletedForm"> | $Enums.NextStepType
    nextStepRoles?: StringNullableListFilter<"APCompletedForm">
    nextStepSpecifiedTo?: StringNullableFilter<"APCompletedForm"> | string | null
    notificationType?: EnumNextStepTypeFilter<"APCompletedForm"> | $Enums.NextStepType
    notificationToId?: UuidNullableFilter<"APCompletedForm"> | string | null
    notificationToRoles?: StringNullableListFilter<"APCompletedForm">
    notificationComment?: StringNullableFilter<"APCompletedForm"> | string | null
    notifyApplicant?: BoolFilter<"APCompletedForm"> | boolean
    applicantNotificationContent?: StringNullableFilter<"APCompletedForm"> | string | null
    editApplicationStatus?: BoolFilter<"APCompletedForm"> | boolean
    applicantViewFormAfterCompletion?: BoolFilter<"APCompletedForm"> | boolean
    createdAt?: DateTimeFilter<"APCompletedForm"> | Date | string
    applicantProcess?: XOR<ApplicantProcessScalarRelationFilter, ApplicantProcessWhereInput>
  }, "id">

  export type APCompletedFormOrderByWithAggregationInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    reviewerId?: SortOrderInput | SortOrder
    nextStaffId?: SortOrderInput | SortOrder
    nextStepType?: SortOrder
    nextStepRoles?: SortOrder
    nextStepSpecifiedTo?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    notificationToId?: SortOrderInput | SortOrder
    notificationToRoles?: SortOrder
    notificationComment?: SortOrderInput | SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrderInput | SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
    _count?: APCompletedFormCountOrderByAggregateInput
    _max?: APCompletedFormMaxOrderByAggregateInput
    _min?: APCompletedFormMinOrderByAggregateInput
  }

  export type APCompletedFormScalarWhereWithAggregatesInput = {
    AND?: APCompletedFormScalarWhereWithAggregatesInput | APCompletedFormScalarWhereWithAggregatesInput[]
    OR?: APCompletedFormScalarWhereWithAggregatesInput[]
    NOT?: APCompletedFormScalarWhereWithAggregatesInput | APCompletedFormScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"APCompletedForm"> | string
    applicantProcessId?: UuidWithAggregatesFilter<"APCompletedForm"> | string
    formId?: UuidWithAggregatesFilter<"APCompletedForm"> | string
    reviewerId?: UuidNullableWithAggregatesFilter<"APCompletedForm"> | string | null
    nextStaffId?: UuidNullableWithAggregatesFilter<"APCompletedForm"> | string | null
    nextStepType?: EnumNextStepTypeWithAggregatesFilter<"APCompletedForm"> | $Enums.NextStepType
    nextStepRoles?: StringNullableListFilter<"APCompletedForm">
    nextStepSpecifiedTo?: StringNullableWithAggregatesFilter<"APCompletedForm"> | string | null
    notificationType?: EnumNextStepTypeWithAggregatesFilter<"APCompletedForm"> | $Enums.NextStepType
    notificationToId?: UuidNullableWithAggregatesFilter<"APCompletedForm"> | string | null
    notificationToRoles?: StringNullableListFilter<"APCompletedForm">
    notificationComment?: StringNullableWithAggregatesFilter<"APCompletedForm"> | string | null
    notifyApplicant?: BoolWithAggregatesFilter<"APCompletedForm"> | boolean
    applicantNotificationContent?: StringNullableWithAggregatesFilter<"APCompletedForm"> | string | null
    editApplicationStatus?: BoolWithAggregatesFilter<"APCompletedForm"> | boolean
    applicantViewFormAfterCompletion?: BoolWithAggregatesFilter<"APCompletedForm"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"APCompletedForm"> | Date | string
  }

  export type ProcessCommentWhereInput = {
    AND?: ProcessCommentWhereInput | ProcessCommentWhereInput[]
    OR?: ProcessCommentWhereInput[]
    NOT?: ProcessCommentWhereInput | ProcessCommentWhereInput[]
    id?: UuidFilter<"ProcessComment"> | string
    applicantProcessId?: UuidFilter<"ProcessComment"> | string
    userId?: UuidFilter<"ProcessComment"> | string
    comment?: StringFilter<"ProcessComment"> | string
    createdAt?: DateTimeFilter<"ProcessComment"> | Date | string
    applicantProcess?: XOR<ApplicantProcessScalarRelationFilter, ApplicantProcessWhereInput>
  }

  export type ProcessCommentOrderByWithRelationInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    applicantProcess?: ApplicantProcessOrderByWithRelationInput
    _relevance?: ProcessCommentOrderByRelevanceInput
  }

  export type ProcessCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcessCommentWhereInput | ProcessCommentWhereInput[]
    OR?: ProcessCommentWhereInput[]
    NOT?: ProcessCommentWhereInput | ProcessCommentWhereInput[]
    applicantProcessId?: UuidFilter<"ProcessComment"> | string
    userId?: UuidFilter<"ProcessComment"> | string
    comment?: StringFilter<"ProcessComment"> | string
    createdAt?: DateTimeFilter<"ProcessComment"> | Date | string
    applicantProcess?: XOR<ApplicantProcessScalarRelationFilter, ApplicantProcessWhereInput>
  }, "id">

  export type ProcessCommentOrderByWithAggregationInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    _count?: ProcessCommentCountOrderByAggregateInput
    _max?: ProcessCommentMaxOrderByAggregateInput
    _min?: ProcessCommentMinOrderByAggregateInput
  }

  export type ProcessCommentScalarWhereWithAggregatesInput = {
    AND?: ProcessCommentScalarWhereWithAggregatesInput | ProcessCommentScalarWhereWithAggregatesInput[]
    OR?: ProcessCommentScalarWhereWithAggregatesInput[]
    NOT?: ProcessCommentScalarWhereWithAggregatesInput | ProcessCommentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProcessComment"> | string
    applicantProcessId?: UuidWithAggregatesFilter<"ProcessComment"> | string
    userId?: UuidWithAggregatesFilter<"ProcessComment"> | string
    comment?: StringWithAggregatesFilter<"ProcessComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProcessComment"> | Date | string
  }

  export type OrganizationUserWhereInput = {
    AND?: OrganizationUserWhereInput | OrganizationUserWhereInput[]
    OR?: OrganizationUserWhereInput[]
    NOT?: OrganizationUserWhereInput | OrganizationUserWhereInput[]
    id?: UuidFilter<"OrganizationUser"> | string
    userId?: UuidFilter<"OrganizationUser"> | string
    superiorId?: UuidNullableFilter<"OrganizationUser"> | string | null
    title?: StringFilter<"OrganizationUser"> | string
    superior?: XOR<OrganizationUserNullableScalarRelationFilter, OrganizationUserWhereInput> | null
    subordinates?: OrganizationUserListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrganizationUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    superiorId?: SortOrderInput | SortOrder
    title?: SortOrder
    superior?: OrganizationUserOrderByWithRelationInput
    subordinates?: OrganizationUserOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    _relevance?: OrganizationUserOrderByRelevanceInput
  }

  export type OrganizationUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: OrganizationUserWhereInput | OrganizationUserWhereInput[]
    OR?: OrganizationUserWhereInput[]
    NOT?: OrganizationUserWhereInput | OrganizationUserWhereInput[]
    superiorId?: UuidNullableFilter<"OrganizationUser"> | string | null
    title?: StringFilter<"OrganizationUser"> | string
    superior?: XOR<OrganizationUserNullableScalarRelationFilter, OrganizationUserWhereInput> | null
    subordinates?: OrganizationUserListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type OrganizationUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    superiorId?: SortOrderInput | SortOrder
    title?: SortOrder
    _count?: OrganizationUserCountOrderByAggregateInput
    _max?: OrganizationUserMaxOrderByAggregateInput
    _min?: OrganizationUserMinOrderByAggregateInput
  }

  export type OrganizationUserScalarWhereWithAggregatesInput = {
    AND?: OrganizationUserScalarWhereWithAggregatesInput | OrganizationUserScalarWhereWithAggregatesInput[]
    OR?: OrganizationUserScalarWhereWithAggregatesInput[]
    NOT?: OrganizationUserScalarWhereWithAggregatesInput | OrganizationUserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OrganizationUser"> | string
    userId?: UuidWithAggregatesFilter<"OrganizationUser"> | string
    superiorId?: UuidNullableWithAggregatesFilter<"OrganizationUser"> | string | null
    title?: StringWithAggregatesFilter<"OrganizationUser"> | string
  }

  export type DashboardWhereInput = {
    AND?: DashboardWhereInput | DashboardWhereInput[]
    OR?: DashboardWhereInput[]
    NOT?: DashboardWhereInput | DashboardWhereInput[]
    id?: UuidFilter<"Dashboard"> | string
    name?: StringFilter<"Dashboard"> | string
    ownerId?: UuidFilter<"Dashboard"> | string
    allowedUsers?: StringNullableListFilter<"Dashboard">
    allowedRoles?: StringNullableListFilter<"Dashboard">
    layout?: JsonNullableFilter<"Dashboard">
    createdAt?: DateTimeFilter<"Dashboard"> | Date | string
    updatedAt?: DateTimeFilter<"Dashboard"> | Date | string
    widgets?: WidgetListRelationFilter
  }

  export type DashboardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    allowedUsers?: SortOrder
    allowedRoles?: SortOrder
    layout?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    widgets?: WidgetOrderByRelationAggregateInput
    _relevance?: DashboardOrderByRelevanceInput
  }

  export type DashboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DashboardWhereInput | DashboardWhereInput[]
    OR?: DashboardWhereInput[]
    NOT?: DashboardWhereInput | DashboardWhereInput[]
    name?: StringFilter<"Dashboard"> | string
    ownerId?: UuidFilter<"Dashboard"> | string
    allowedUsers?: StringNullableListFilter<"Dashboard">
    allowedRoles?: StringNullableListFilter<"Dashboard">
    layout?: JsonNullableFilter<"Dashboard">
    createdAt?: DateTimeFilter<"Dashboard"> | Date | string
    updatedAt?: DateTimeFilter<"Dashboard"> | Date | string
    widgets?: WidgetListRelationFilter
  }, "id">

  export type DashboardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    allowedUsers?: SortOrder
    allowedRoles?: SortOrder
    layout?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DashboardCountOrderByAggregateInput
    _max?: DashboardMaxOrderByAggregateInput
    _min?: DashboardMinOrderByAggregateInput
  }

  export type DashboardScalarWhereWithAggregatesInput = {
    AND?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[]
    OR?: DashboardScalarWhereWithAggregatesInput[]
    NOT?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Dashboard"> | string
    name?: StringWithAggregatesFilter<"Dashboard"> | string
    ownerId?: UuidWithAggregatesFilter<"Dashboard"> | string
    allowedUsers?: StringNullableListFilter<"Dashboard">
    allowedRoles?: StringNullableListFilter<"Dashboard">
    layout?: JsonNullableWithAggregatesFilter<"Dashboard">
    createdAt?: DateTimeWithAggregatesFilter<"Dashboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dashboard"> | Date | string
  }

  export type WidgetWhereInput = {
    AND?: WidgetWhereInput | WidgetWhereInput[]
    OR?: WidgetWhereInput[]
    NOT?: WidgetWhereInput | WidgetWhereInput[]
    id?: UuidFilter<"Widget"> | string
    dashboardId?: UuidFilter<"Widget"> | string
    title?: StringFilter<"Widget"> | string
    visualizationType?: StringFilter<"Widget"> | string
    config?: JsonFilter<"Widget">
    order?: IntFilter<"Widget"> | number
    createdAt?: DateTimeFilter<"Widget"> | Date | string
    updatedAt?: DateTimeFilter<"Widget"> | Date | string
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }

  export type WidgetOrderByWithRelationInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    title?: SortOrder
    visualizationType?: SortOrder
    config?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dashboard?: DashboardOrderByWithRelationInput
    _relevance?: WidgetOrderByRelevanceInput
  }

  export type WidgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WidgetWhereInput | WidgetWhereInput[]
    OR?: WidgetWhereInput[]
    NOT?: WidgetWhereInput | WidgetWhereInput[]
    dashboardId?: UuidFilter<"Widget"> | string
    title?: StringFilter<"Widget"> | string
    visualizationType?: StringFilter<"Widget"> | string
    config?: JsonFilter<"Widget">
    order?: IntFilter<"Widget"> | number
    createdAt?: DateTimeFilter<"Widget"> | Date | string
    updatedAt?: DateTimeFilter<"Widget"> | Date | string
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>
  }, "id">

  export type WidgetOrderByWithAggregationInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    title?: SortOrder
    visualizationType?: SortOrder
    config?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WidgetCountOrderByAggregateInput
    _avg?: WidgetAvgOrderByAggregateInput
    _max?: WidgetMaxOrderByAggregateInput
    _min?: WidgetMinOrderByAggregateInput
    _sum?: WidgetSumOrderByAggregateInput
  }

  export type WidgetScalarWhereWithAggregatesInput = {
    AND?: WidgetScalarWhereWithAggregatesInput | WidgetScalarWhereWithAggregatesInput[]
    OR?: WidgetScalarWhereWithAggregatesInput[]
    NOT?: WidgetScalarWhereWithAggregatesInput | WidgetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Widget"> | string
    dashboardId?: UuidWithAggregatesFilter<"Widget"> | string
    title?: StringWithAggregatesFilter<"Widget"> | string
    visualizationType?: StringWithAggregatesFilter<"Widget"> | string
    config?: JsonWithAggregatesFilter<"Widget">
    order?: IntWithAggregatesFilter<"Widget"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Widget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Widget"> | Date | string
  }

  export type QrCodeDocumentWhereInput = {
    AND?: QrCodeDocumentWhereInput | QrCodeDocumentWhereInput[]
    OR?: QrCodeDocumentWhereInput[]
    NOT?: QrCodeDocumentWhereInput | QrCodeDocumentWhereInput[]
    id?: UuidFilter<"QrCodeDocument"> | string
    documentName?: StringFilter<"QrCodeDocument"> | string
    fileName?: StringFilter<"QrCodeDocument"> | string
    qrCodeId?: StringFilter<"QrCodeDocument"> | string
    creatorId?: UuidFilter<"QrCodeDocument"> | string
    createdAt?: DateTimeFilter<"QrCodeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"QrCodeDocument"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QrCodeDocumentOrderByWithRelationInput = {
    id?: SortOrder
    documentName?: SortOrder
    fileName?: SortOrder
    qrCodeId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    _relevance?: QrCodeDocumentOrderByRelevanceInput
  }

  export type QrCodeDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrCodeId?: string
    AND?: QrCodeDocumentWhereInput | QrCodeDocumentWhereInput[]
    OR?: QrCodeDocumentWhereInput[]
    NOT?: QrCodeDocumentWhereInput | QrCodeDocumentWhereInput[]
    documentName?: StringFilter<"QrCodeDocument"> | string
    fileName?: StringFilter<"QrCodeDocument"> | string
    creatorId?: UuidFilter<"QrCodeDocument"> | string
    createdAt?: DateTimeFilter<"QrCodeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"QrCodeDocument"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "qrCodeId">

  export type QrCodeDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    documentName?: SortOrder
    fileName?: SortOrder
    qrCodeId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QrCodeDocumentCountOrderByAggregateInput
    _max?: QrCodeDocumentMaxOrderByAggregateInput
    _min?: QrCodeDocumentMinOrderByAggregateInput
  }

  export type QrCodeDocumentScalarWhereWithAggregatesInput = {
    AND?: QrCodeDocumentScalarWhereWithAggregatesInput | QrCodeDocumentScalarWhereWithAggregatesInput[]
    OR?: QrCodeDocumentScalarWhereWithAggregatesInput[]
    NOT?: QrCodeDocumentScalarWhereWithAggregatesInput | QrCodeDocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QrCodeDocument"> | string
    documentName?: StringWithAggregatesFilter<"QrCodeDocument"> | string
    fileName?: StringWithAggregatesFilter<"QrCodeDocument"> | string
    qrCodeId?: StringWithAggregatesFilter<"QrCodeDocument"> | string
    creatorId?: UuidWithAggregatesFilter<"QrCodeDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QrCodeDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QrCodeDocument"> | Date | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: UuidFilter<"Otp"> | string
    email?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    _relevance?: OtpOrderByRelevanceInput
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    email?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Otp"> | string
    email?: StringWithAggregatesFilter<"Otp"> | string
    otp?: StringWithAggregatesFilter<"Otp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type ManagementWhereInput = {
    AND?: ManagementWhereInput | ManagementWhereInput[]
    OR?: ManagementWhereInput[]
    NOT?: ManagementWhereInput | ManagementWhereInput[]
    id?: UuidFilter<"Management"> | string
    fileName?: StringFilter<"Management"> | string
    fileUrl?: StringNullableFilter<"Management"> | string | null
    type?: EnumManagementTypeFilter<"Management"> | $Enums.ManagementType
    uploadedAt?: DateTimeFilter<"Management"> | Date | string
    updatedAt?: DateTimeFilter<"Management"> | Date | string
  }

  export type ManagementOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ManagementOrderByRelevanceInput
  }

  export type ManagementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManagementWhereInput | ManagementWhereInput[]
    OR?: ManagementWhereInput[]
    NOT?: ManagementWhereInput | ManagementWhereInput[]
    fileName?: StringFilter<"Management"> | string
    fileUrl?: StringNullableFilter<"Management"> | string | null
    type?: EnumManagementTypeFilter<"Management"> | $Enums.ManagementType
    uploadedAt?: DateTimeFilter<"Management"> | Date | string
    updatedAt?: DateTimeFilter<"Management"> | Date | string
  }, "id">

  export type ManagementOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ManagementCountOrderByAggregateInput
    _max?: ManagementMaxOrderByAggregateInput
    _min?: ManagementMinOrderByAggregateInput
  }

  export type ManagementScalarWhereWithAggregatesInput = {
    AND?: ManagementScalarWhereWithAggregatesInput | ManagementScalarWhereWithAggregatesInput[]
    OR?: ManagementScalarWhereWithAggregatesInput[]
    NOT?: ManagementScalarWhereWithAggregatesInput | ManagementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Management"> | string
    fileName?: StringWithAggregatesFilter<"Management"> | string
    fileUrl?: StringNullableWithAggregatesFilter<"Management"> | string | null
    type?: EnumManagementTypeWithAggregatesFilter<"Management"> | $Enums.ManagementType
    uploadedAt?: DateTimeWithAggregatesFilter<"Management"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Management"> | Date | string
  }

  export type AddToDatabaseWhereInput = {
    AND?: AddToDatabaseWhereInput | AddToDatabaseWhereInput[]
    OR?: AddToDatabaseWhereInput[]
    NOT?: AddToDatabaseWhereInput | AddToDatabaseWhereInput[]
    id?: UuidFilter<"AddToDatabase"> | string
    name?: StringFilter<"AddToDatabase"> | string
    status?: EnumAddToDatabaseStatusFilter<"AddToDatabase"> | $Enums.AddToDatabaseStatus
    levels?: JsonFilter<"AddToDatabase">
    createdAt?: DateTimeFilter<"AddToDatabase"> | Date | string
    updatedAt?: DateTimeFilter<"AddToDatabase"> | Date | string
  }

  export type AddToDatabaseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    levels?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: AddToDatabaseOrderByRelevanceInput
  }

  export type AddToDatabaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddToDatabaseWhereInput | AddToDatabaseWhereInput[]
    OR?: AddToDatabaseWhereInput[]
    NOT?: AddToDatabaseWhereInput | AddToDatabaseWhereInput[]
    name?: StringFilter<"AddToDatabase"> | string
    status?: EnumAddToDatabaseStatusFilter<"AddToDatabase"> | $Enums.AddToDatabaseStatus
    levels?: JsonFilter<"AddToDatabase">
    createdAt?: DateTimeFilter<"AddToDatabase"> | Date | string
    updatedAt?: DateTimeFilter<"AddToDatabase"> | Date | string
  }, "id">

  export type AddToDatabaseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    levels?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddToDatabaseCountOrderByAggregateInput
    _max?: AddToDatabaseMaxOrderByAggregateInput
    _min?: AddToDatabaseMinOrderByAggregateInput
  }

  export type AddToDatabaseScalarWhereWithAggregatesInput = {
    AND?: AddToDatabaseScalarWhereWithAggregatesInput | AddToDatabaseScalarWhereWithAggregatesInput[]
    OR?: AddToDatabaseScalarWhereWithAggregatesInput[]
    NOT?: AddToDatabaseScalarWhereWithAggregatesInput | AddToDatabaseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AddToDatabase"> | string
    name?: StringWithAggregatesFilter<"AddToDatabase"> | string
    status?: EnumAddToDatabaseStatusWithAggregatesFilter<"AddToDatabase"> | $Enums.AddToDatabaseStatus
    levels?: JsonWithAggregatesFilter<"AddToDatabase">
    createdAt?: DateTimeWithAggregatesFilter<"AddToDatabase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AddToDatabase"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: UuidFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    title?: StringFilter<"Chat"> | string
    userId?: UuidFilter<"Chat"> | string
    visibility?: StringFilter<"Chat"> | string
    messages?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    visibility?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    _relevance?: ChatOrderByRelevanceInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    title?: StringFilter<"Chat"> | string
    userId?: UuidFilter<"Chat"> | string
    visibility?: StringFilter<"Chat"> | string
    messages?: MessageListRelationFilter
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    visibility?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Chat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    title?: StringWithAggregatesFilter<"Chat"> | string
    userId?: UuidWithAggregatesFilter<"Chat"> | string
    visibility?: StringWithAggregatesFilter<"Chat"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: UuidFilter<"Message"> | string
    chatId?: UuidFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    parts?: JsonFilter<"Message">
    attachments?: JsonFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    votes?: VoteListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    parts?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    votes?: VoteOrderByRelationAggregateInput
    _relevance?: MessageOrderByRelevanceInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    chatId?: UuidFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    parts?: JsonFilter<"Message">
    attachments?: JsonFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    votes?: VoteListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    parts?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Message"> | string
    chatId?: UuidWithAggregatesFilter<"Message"> | string
    role?: StringWithAggregatesFilter<"Message"> | string
    parts?: JsonWithAggregatesFilter<"Message">
    attachments?: JsonWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    chatId?: UuidFilter<"Vote"> | string
    messageId?: UuidFilter<"Vote"> | string
    isUpvoted?: BoolFilter<"Vote"> | boolean
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    chatId?: SortOrder
    messageId?: SortOrder
    isUpvoted?: SortOrder
    message?: MessageOrderByWithRelationInput
    _relevance?: VoteOrderByRelevanceInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    chatId_messageId?: VoteChatIdMessageIdCompoundUniqueInput
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    chatId?: UuidFilter<"Vote"> | string
    messageId?: UuidFilter<"Vote"> | string
    isUpvoted?: BoolFilter<"Vote"> | boolean
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "chatId_messageId">

  export type VoteOrderByWithAggregationInput = {
    chatId?: SortOrder
    messageId?: SortOrder
    isUpvoted?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    chatId?: UuidWithAggregatesFilter<"Vote"> | string
    messageId?: UuidWithAggregatesFilter<"Vote"> | string
    isUpvoted?: BoolWithAggregatesFilter<"Vote"> | boolean
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: UuidFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    title?: StringFilter<"Document"> | string
    content?: StringNullableFilter<"Document"> | string | null
    kind?: StringFilter<"Document"> | string
    userId?: UuidFilter<"Document"> | string
    suggestions?: SuggestionListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    kind?: SortOrder
    userId?: SortOrder
    suggestions?: SuggestionOrderByRelationAggregateInput
    _relevance?: DocumentOrderByRelevanceInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_createdAt?: DocumentIdCreatedAtCompoundUniqueInput
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    createdAt?: DateTimeFilter<"Document"> | Date | string
    title?: StringFilter<"Document"> | string
    content?: StringNullableFilter<"Document"> | string | null
    kind?: StringFilter<"Document"> | string
    userId?: UuidFilter<"Document"> | string
    suggestions?: SuggestionListRelationFilter
  }, "id" | "id_createdAt">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    kind?: SortOrder
    userId?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    title?: StringWithAggregatesFilter<"Document"> | string
    content?: StringNullableWithAggregatesFilter<"Document"> | string | null
    kind?: StringWithAggregatesFilter<"Document"> | string
    userId?: UuidWithAggregatesFilter<"Document"> | string
  }

  export type SuggestionWhereInput = {
    AND?: SuggestionWhereInput | SuggestionWhereInput[]
    OR?: SuggestionWhereInput[]
    NOT?: SuggestionWhereInput | SuggestionWhereInput[]
    id?: UuidFilter<"Suggestion"> | string
    documentId?: UuidFilter<"Suggestion"> | string
    documentCreatedAt?: DateTimeFilter<"Suggestion"> | Date | string
    originalText?: StringFilter<"Suggestion"> | string
    suggestedText?: StringFilter<"Suggestion"> | string
    description?: StringNullableFilter<"Suggestion"> | string | null
    isResolved?: BoolFilter<"Suggestion"> | boolean
    userId?: UuidFilter<"Suggestion"> | string
    createdAt?: DateTimeFilter<"Suggestion"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }

  export type SuggestionOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentCreatedAt?: SortOrder
    originalText?: SortOrder
    suggestedText?: SortOrder
    description?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    _relevance?: SuggestionOrderByRelevanceInput
  }

  export type SuggestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SuggestionWhereInput | SuggestionWhereInput[]
    OR?: SuggestionWhereInput[]
    NOT?: SuggestionWhereInput | SuggestionWhereInput[]
    documentId?: UuidFilter<"Suggestion"> | string
    documentCreatedAt?: DateTimeFilter<"Suggestion"> | Date | string
    originalText?: StringFilter<"Suggestion"> | string
    suggestedText?: StringFilter<"Suggestion"> | string
    description?: StringNullableFilter<"Suggestion"> | string | null
    isResolved?: BoolFilter<"Suggestion"> | boolean
    userId?: UuidFilter<"Suggestion"> | string
    createdAt?: DateTimeFilter<"Suggestion"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }, "id">

  export type SuggestionOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentCreatedAt?: SortOrder
    originalText?: SortOrder
    suggestedText?: SortOrder
    description?: SortOrderInput | SortOrder
    isResolved?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: SuggestionCountOrderByAggregateInput
    _max?: SuggestionMaxOrderByAggregateInput
    _min?: SuggestionMinOrderByAggregateInput
  }

  export type SuggestionScalarWhereWithAggregatesInput = {
    AND?: SuggestionScalarWhereWithAggregatesInput | SuggestionScalarWhereWithAggregatesInput[]
    OR?: SuggestionScalarWhereWithAggregatesInput[]
    NOT?: SuggestionScalarWhereWithAggregatesInput | SuggestionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Suggestion"> | string
    documentId?: UuidWithAggregatesFilter<"Suggestion"> | string
    documentCreatedAt?: DateTimeWithAggregatesFilter<"Suggestion"> | Date | string
    originalText?: StringWithAggregatesFilter<"Suggestion"> | string
    suggestedText?: StringWithAggregatesFilter<"Suggestion"> | string
    description?: StringNullableWithAggregatesFilter<"Suggestion"> | string | null
    isResolved?: BoolWithAggregatesFilter<"Suggestion"> | boolean
    userId?: UuidWithAggregatesFilter<"Suggestion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Suggestion"> | Date | string
  }

  export type ProcessSaveWhereInput = {
    AND?: ProcessSaveWhereInput | ProcessSaveWhereInput[]
    OR?: ProcessSaveWhereInput[]
    NOT?: ProcessSaveWhereInput | ProcessSaveWhereInput[]
    id?: UuidFilter<"ProcessSave"> | string
    chatId?: UuidFilter<"ProcessSave"> | string
    rolesData?: JsonNullableFilter<"ProcessSave">
    processData?: JsonNullableFilter<"ProcessSave">
    stepsData?: JsonNullableFilter<"ProcessSave">
    formsData?: JsonNullableFilter<"ProcessSave">
    isComplete?: BoolFilter<"ProcessSave"> | boolean
    createdAt?: DateTimeFilter<"ProcessSave"> | Date | string
  }

  export type ProcessSaveOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    rolesData?: SortOrderInput | SortOrder
    processData?: SortOrderInput | SortOrder
    stepsData?: SortOrderInput | SortOrder
    formsData?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    _relevance?: ProcessSaveOrderByRelevanceInput
  }

  export type ProcessSaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chatId?: string
    AND?: ProcessSaveWhereInput | ProcessSaveWhereInput[]
    OR?: ProcessSaveWhereInput[]
    NOT?: ProcessSaveWhereInput | ProcessSaveWhereInput[]
    rolesData?: JsonNullableFilter<"ProcessSave">
    processData?: JsonNullableFilter<"ProcessSave">
    stepsData?: JsonNullableFilter<"ProcessSave">
    formsData?: JsonNullableFilter<"ProcessSave">
    isComplete?: BoolFilter<"ProcessSave"> | boolean
    createdAt?: DateTimeFilter<"ProcessSave"> | Date | string
  }, "id" | "chatId">

  export type ProcessSaveOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    rolesData?: SortOrderInput | SortOrder
    processData?: SortOrderInput | SortOrder
    stepsData?: SortOrderInput | SortOrder
    formsData?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    _count?: ProcessSaveCountOrderByAggregateInput
    _max?: ProcessSaveMaxOrderByAggregateInput
    _min?: ProcessSaveMinOrderByAggregateInput
  }

  export type ProcessSaveScalarWhereWithAggregatesInput = {
    AND?: ProcessSaveScalarWhereWithAggregatesInput | ProcessSaveScalarWhereWithAggregatesInput[]
    OR?: ProcessSaveScalarWhereWithAggregatesInput[]
    NOT?: ProcessSaveScalarWhereWithAggregatesInput | ProcessSaveScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProcessSave"> | string
    chatId?: UuidWithAggregatesFilter<"ProcessSave"> | string
    rolesData?: JsonNullableWithAggregatesFilter<"ProcessSave">
    processData?: JsonNullableWithAggregatesFilter<"ProcessSave">
    stepsData?: JsonNullableWithAggregatesFilter<"ProcessSave">
    formsData?: JsonNullableWithAggregatesFilter<"ProcessSave">
    isComplete?: BoolWithAggregatesFilter<"ProcessSave"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProcessSave"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupRoleCreateNestedManyWithoutRoleInput
    processes?: ProcessRoleCreateNestedManyWithoutRoleInput
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupRoleUncheckedCreateNestedManyWithoutRoleInput
    processes?: ProcessRoleUncheckedCreateNestedManyWithoutRoleInput
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupRoleUpdateManyWithoutRoleNestedInput
    processes?: ProcessRoleUpdateManyWithoutRoleNestedInput
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupRoleUncheckedUpdateManyWithoutRoleNestedInput
    processes?: ProcessRoleUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    status?: $Enums.RoleStatus
    role: RoleCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type UserRoleUpdateInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type UserRoleUpdateManyMutationInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type FileCreateInput = {
    id?: string
    fileUrl: string
    thumbnailUrl?: string | null
    size: number
    isPrivate?: boolean
    title: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    fileUrl: string
    thumbnailUrl?: string | null
    size: number
    isPrivate?: boolean
    title: string
    userId: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateManyInput = {
    id?: string
    fileUrl: string
    thumbnailUrl?: string | null
    size: number
    isPrivate?: boolean
    title: string
    userId: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    timestamp?: Date | string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status: string
    errorMessage?: string | null
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status: string
    errorMessage?: string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    timestamp?: Date | string
    userId?: string | null
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status: string
    errorMessage?: string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: GroupRoleCreateNestedManyWithoutGroupInput
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
    processes?: ProcessCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: GroupRoleUncheckedCreateNestedManyWithoutGroupInput
    processes?: ProcessUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: GroupRoleUpdateManyWithoutGroupNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    processes?: ProcessUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: GroupRoleUncheckedUpdateManyWithoutGroupNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupRoleCreateInput = {
    status?: $Enums.RoleStatus
    group: GroupCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutGroupsInput
  }

  export type GroupRoleUncheckedCreateInput = {
    groupId: string
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type GroupRoleUpdateInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    group?: GroupUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type GroupRoleUncheckedUpdateInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type GroupRoleCreateManyInput = {
    groupId: string
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type GroupRoleUpdateManyMutationInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type GroupRoleUncheckedUpdateManyInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type ProcessCreateInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseCreateNestedManyWithoutProcessInput
    forms?: ProcessFormCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleCreateNestedManyWithoutProcessInput
    creator: UserCreateNestedOneWithoutCreatedProcessesInput
    group: GroupCreateNestedOneWithoutProcessesInput
  }

  export type ProcessUncheckedCreateInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutProcessInput
    forms?: ProcessFormUncheckedCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUpdateManyWithoutProcessNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProcessesNestedInput
    group?: GroupUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUncheckedUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessCreateManyInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessRoleCreateInput = {
    status?: $Enums.RoleStatus
    process: ProcessCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutProcessesInput
  }

  export type ProcessRoleUncheckedCreateInput = {
    processId: string
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type ProcessRoleUpdateInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    process?: ProcessUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessRoleUncheckedUpdateInput = {
    processId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type ProcessRoleCreateManyInput = {
    processId: string
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type ProcessRoleUpdateManyMutationInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type ProcessRoleUncheckedUpdateManyInput = {
    processId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type FolderCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedFoldersInput
    forms?: FormCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    forms?: FormUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedFoldersNestedInput
    forms?: FormUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forms?: FormUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormCreateInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseCreateNestedManyWithoutFormInput
    creator: UserCreateNestedOneWithoutCreatedFormsInput
    folder?: FolderCreateNestedOneWithoutFormsInput
    processForms?: ProcessFormCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    creatorId: string
    folderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUncheckedCreateNestedManyWithoutFormInput
    processForms?: ProcessFormUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUpdateManyWithoutFormNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedFormsNestedInput
    folder?: FolderUpdateOneWithoutFormsNestedInput
    processForms?: ProcessFormUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUncheckedUpdateManyWithoutFormNestedInput
    processForms?: ProcessFormUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormCreateManyInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    creatorId: string
    folderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FormResponseCreateInput = {
    id?: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    applicantProcess: ApplicantProcessCreateNestedOneWithoutResponsesInput
    form: FormCreateNestedOneWithoutResponsesInput
    process: ProcessCreateNestedOneWithoutFormResponsesInput
  }

  export type FormResponseUncheckedCreateInput = {
    id?: string
    formId: string
    applicantProcessId: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processId: string
  }

  export type FormResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcess?: ApplicantProcessUpdateOneRequiredWithoutResponsesNestedInput
    form?: FormUpdateOneRequiredWithoutResponsesNestedInput
    process?: ProcessUpdateOneRequiredWithoutFormResponsesNestedInput
  }

  export type FormResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processId?: StringFieldUpdateOperationsInput | string
  }

  export type FormResponseCreateManyInput = {
    id?: string
    formId: string
    applicantProcessId: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processId: string
  }

  export type FormResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processId?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessFormCreateInput = {
    id?: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: FormCreateNestedOneWithoutProcessFormsInput
    process: ProcessCreateNestedOneWithoutFormsInput
  }

  export type ProcessFormUncheckedCreateInput = {
    id?: string
    processId: string
    formId: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutProcessFormsNestedInput
    process?: ProcessUpdateOneRequiredWithoutFormsNestedInput
  }

  export type ProcessFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessFormCreateManyInput = {
    id?: string
    processId: string
    formId: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicantProcessCreateInput = {
    id?: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormCreateNestedManyWithoutApplicantProcessInput
    applicant: UserCreateNestedOneWithoutApplicantProcessesInput
    process: ProcessCreateNestedOneWithoutApplicantProcessesInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessUncheckedCreateInput = {
    id?: string
    applicantId: string
    processId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormUncheckedCreateNestedManyWithoutApplicantProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseUncheckedCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentUncheckedCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUpdateManyWithoutApplicantProcessNestedInput
    applicant?: UserUpdateOneRequiredWithoutApplicantProcessesNestedInput
    process?: ProcessUpdateOneRequiredWithoutApplicantProcessesNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUncheckedUpdateManyWithoutApplicantProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUncheckedUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUncheckedUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessCreateManyInput = {
    id?: string
    applicantId: string
    processId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
  }

  export type ApplicantProcessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicantProcessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationCreateInput = {
    id?: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProcessedApplicationsInput
    process: ProcessCreateNestedOneWithoutProcessedApplicationsInput
    applicantProcess: ApplicantProcessCreateNestedOneWithoutProcessedApplicationsInput
  }

  export type ProcessedApplicationUncheckedCreateInput = {
    id?: string
    userId: string
    processId: string
    applicantProcessId: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessedApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProcessedApplicationsNestedInput
    process?: ProcessUpdateOneRequiredWithoutProcessedApplicationsNestedInput
    applicantProcess?: ApplicantProcessUpdateOneRequiredWithoutProcessedApplicationsNestedInput
  }

  export type ProcessedApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationCreateManyInput = {
    id?: string
    userId: string
    processId: string
    applicantProcessId: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessedApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APCompletedFormCreateInput = {
    id?: string
    formId: string
    reviewerId?: string | null
    nextStaffId?: string | null
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: APCompletedFormCreatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationToId?: string | null
    notificationToRoles?: APCompletedFormCreatenotificationToRolesInput | string[]
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    applicantProcess: ApplicantProcessCreateNestedOneWithoutCompletedFormsInput
  }

  export type APCompletedFormUncheckedCreateInput = {
    id?: string
    applicantProcessId: string
    formId: string
    reviewerId?: string | null
    nextStaffId?: string | null
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: APCompletedFormCreatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationToId?: string | null
    notificationToRoles?: APCompletedFormCreatenotificationToRolesInput | string[]
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
  }

  export type APCompletedFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: APCompletedFormUpdatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToRoles?: APCompletedFormUpdatenotificationToRolesInput | string[]
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcess?: ApplicantProcessUpdateOneRequiredWithoutCompletedFormsNestedInput
  }

  export type APCompletedFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: APCompletedFormUpdatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToRoles?: APCompletedFormUpdatenotificationToRolesInput | string[]
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APCompletedFormCreateManyInput = {
    id?: string
    applicantProcessId: string
    formId: string
    reviewerId?: string | null
    nextStaffId?: string | null
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: APCompletedFormCreatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationToId?: string | null
    notificationToRoles?: APCompletedFormCreatenotificationToRolesInput | string[]
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
  }

  export type APCompletedFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: APCompletedFormUpdatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToRoles?: APCompletedFormUpdatenotificationToRolesInput | string[]
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APCompletedFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: APCompletedFormUpdatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToRoles?: APCompletedFormUpdatenotificationToRolesInput | string[]
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCommentCreateInput = {
    id?: string
    userId: string
    comment: string
    createdAt?: Date | string
    applicantProcess: ApplicantProcessCreateNestedOneWithoutCommentsInput
  }

  export type ProcessCommentUncheckedCreateInput = {
    id?: string
    applicantProcessId: string
    userId: string
    comment: string
    createdAt?: Date | string
  }

  export type ProcessCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcess?: ApplicantProcessUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ProcessCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCommentCreateManyInput = {
    id?: string
    applicantProcessId: string
    userId: string
    comment: string
    createdAt?: Date | string
  }

  export type ProcessCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUserCreateInput = {
    id?: string
    title: string
    superior?: OrganizationUserCreateNestedOneWithoutSubordinatesInput
    subordinates?: OrganizationUserCreateNestedManyWithoutSuperiorInput
    user: UserCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUserUncheckedCreateInput = {
    id?: string
    userId: string
    superiorId?: string | null
    title: string
    subordinates?: OrganizationUserUncheckedCreateNestedManyWithoutSuperiorInput
  }

  export type OrganizationUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    superior?: OrganizationUserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: OrganizationUserUpdateManyWithoutSuperiorNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationNestedInput
  }

  export type OrganizationUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    superiorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    subordinates?: OrganizationUserUncheckedUpdateManyWithoutSuperiorNestedInput
  }

  export type OrganizationUserCreateManyInput = {
    id?: string
    userId: string
    superiorId?: string | null
    title: string
  }

  export type OrganizationUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    superiorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardCreateInput = {
    id?: string
    name: string
    ownerId: string
    allowedUsers?: DashboardCreateallowedUsersInput | string[]
    allowedRoles?: DashboardCreateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    widgets?: WidgetCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUncheckedCreateInput = {
    id?: string
    name: string
    ownerId: string
    allowedUsers?: DashboardCreateallowedUsersInput | string[]
    allowedRoles?: DashboardCreateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    widgets?: WidgetUncheckedCreateNestedManyWithoutDashboardInput
  }

  export type DashboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    allowedUsers?: DashboardUpdateallowedUsersInput | string[]
    allowedRoles?: DashboardUpdateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    widgets?: WidgetUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    allowedUsers?: DashboardUpdateallowedUsersInput | string[]
    allowedRoles?: DashboardUpdateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    widgets?: WidgetUncheckedUpdateManyWithoutDashboardNestedInput
  }

  export type DashboardCreateManyInput = {
    id?: string
    name: string
    ownerId: string
    allowedUsers?: DashboardCreateallowedUsersInput | string[]
    allowedRoles?: DashboardCreateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    allowedUsers?: DashboardUpdateallowedUsersInput | string[]
    allowedRoles?: DashboardUpdateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    allowedUsers?: DashboardUpdateallowedUsersInput | string[]
    allowedRoles?: DashboardUpdateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetCreateInput = {
    id?: string
    title: string
    visualizationType: string
    config: JsonNullValueInput | InputJsonValue
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dashboard: DashboardCreateNestedOneWithoutWidgetsInput
  }

  export type WidgetUncheckedCreateInput = {
    id?: string
    dashboardId: string
    title: string
    visualizationType: string
    config: JsonNullValueInput | InputJsonValue
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WidgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    visualizationType?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dashboard?: DashboardUpdateOneRequiredWithoutWidgetsNestedInput
  }

  export type WidgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dashboardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    visualizationType?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetCreateManyInput = {
    id?: string
    dashboardId: string
    title: string
    visualizationType: string
    config: JsonNullValueInput | InputJsonValue
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WidgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    visualizationType?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dashboardId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    visualizationType?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeDocumentCreateInput = {
    id?: string
    documentName: string
    fileName: string
    qrCodeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutQrCodeDocumentsInput
  }

  export type QrCodeDocumentUncheckedCreateInput = {
    id?: string
    documentName: string
    fileName: string
    qrCodeId: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QrCodeDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    qrCodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutQrCodeDocumentsNestedInput
  }

  export type QrCodeDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    qrCodeId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeDocumentCreateManyInput = {
    id?: string
    documentName: string
    fileName: string
    qrCodeId: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QrCodeDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    qrCodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    qrCodeId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateInput = {
    id?: string
    email: string
    otp: string
    expiresAt: Date | string
  }

  export type OtpUncheckedCreateInput = {
    id?: string
    email: string
    otp: string
    expiresAt: Date | string
  }

  export type OtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateManyInput = {
    id?: string
    email: string
    otp: string
    expiresAt: Date | string
  }

  export type OtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagementCreateInput = {
    id?: string
    fileName: string
    fileUrl?: string | null
    type: $Enums.ManagementType
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagementUncheckedCreateInput = {
    id?: string
    fileName: string
    fileUrl?: string | null
    type: $Enums.ManagementType
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumManagementTypeFieldUpdateOperationsInput | $Enums.ManagementType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumManagementTypeFieldUpdateOperationsInput | $Enums.ManagementType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagementCreateManyInput = {
    id?: string
    fileName: string
    fileUrl?: string | null
    type: $Enums.ManagementType
    uploadedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumManagementTypeFieldUpdateOperationsInput | $Enums.ManagementType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumManagementTypeFieldUpdateOperationsInput | $Enums.ManagementType
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToDatabaseCreateInput = {
    id?: string
    name: string
    status?: $Enums.AddToDatabaseStatus
    levels: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToDatabaseUncheckedCreateInput = {
    id?: string
    name: string
    status?: $Enums.AddToDatabaseStatus
    levels: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToDatabaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAddToDatabaseStatusFieldUpdateOperationsInput | $Enums.AddToDatabaseStatus
    levels?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToDatabaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAddToDatabaseStatusFieldUpdateOperationsInput | $Enums.AddToDatabaseStatus
    levels?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToDatabaseCreateManyInput = {
    id?: string
    name: string
    status?: $Enums.AddToDatabaseStatus
    levels: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddToDatabaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAddToDatabaseStatusFieldUpdateOperationsInput | $Enums.AddToDatabaseStatus
    levels?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddToDatabaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAddToDatabaseStatusFieldUpdateOperationsInput | $Enums.AddToDatabaseStatus
    levels?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    userId: string
    visibility?: string
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    userId: string
    visibility?: string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    createdAt?: Date | string
    title: string
    userId: string
    visibility?: string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id?: string
    role: string
    parts: JsonNullValueInput | InputJsonValue
    attachments: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    votes?: VoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    chatId: string
    role: string
    parts: JsonNullValueInput | InputJsonValue
    attachments: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    votes?: VoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    chatId: string
    role: string
    parts: JsonNullValueInput | InputJsonValue
    attachments: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateInput = {
    chatId: string
    isUpvoted: boolean
    message: MessageCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    chatId: string
    messageId: string
    isUpvoted: boolean
  }

  export type VoteUpdateInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    isUpvoted?: BoolFieldUpdateOperationsInput | boolean
    message?: MessageUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    isUpvoted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoteCreateManyInput = {
    chatId: string
    messageId: string
    isUpvoted: boolean
  }

  export type VoteUpdateManyMutationInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    isUpvoted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoteUncheckedUpdateManyInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    isUpvoted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    kind?: string
    userId: string
    suggestions?: SuggestionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    kind?: string
    userId: string
    suggestions?: SuggestionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestions?: SuggestionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestions?: SuggestionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    kind?: string
    userId: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SuggestionCreateInput = {
    id?: string
    originalText: string
    suggestedText: string
    description?: string | null
    isResolved?: boolean
    userId: string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutSuggestionsInput
  }

  export type SuggestionUncheckedCreateInput = {
    id?: string
    documentId: string
    documentCreatedAt: Date | string
    originalText: string
    suggestedText: string
    description?: string | null
    isResolved?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type SuggestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    suggestedText?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutSuggestionsNestedInput
  }

  export type SuggestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalText?: StringFieldUpdateOperationsInput | string
    suggestedText?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionCreateManyInput = {
    id?: string
    documentId: string
    documentCreatedAt: Date | string
    originalText: string
    suggestedText: string
    description?: string | null
    isResolved?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type SuggestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    suggestedText?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentCreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalText?: StringFieldUpdateOperationsInput | string
    suggestedText?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessSaveCreateInput = {
    id?: string
    chatId: string
    rolesData?: NullableJsonNullValueInput | InputJsonValue
    processData?: NullableJsonNullValueInput | InputJsonValue
    stepsData?: NullableJsonNullValueInput | InputJsonValue
    formsData?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    createdAt?: Date | string
  }

  export type ProcessSaveUncheckedCreateInput = {
    id?: string
    chatId: string
    rolesData?: NullableJsonNullValueInput | InputJsonValue
    processData?: NullableJsonNullValueInput | InputJsonValue
    stepsData?: NullableJsonNullValueInput | InputJsonValue
    formsData?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    createdAt?: Date | string
  }

  export type ProcessSaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    rolesData?: NullableJsonNullValueInput | InputJsonValue
    processData?: NullableJsonNullValueInput | InputJsonValue
    stepsData?: NullableJsonNullValueInput | InputJsonValue
    formsData?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessSaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    rolesData?: NullableJsonNullValueInput | InputJsonValue
    processData?: NullableJsonNullValueInput | InputJsonValue
    stepsData?: NullableJsonNullValueInput | InputJsonValue
    formsData?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessSaveCreateManyInput = {
    id?: string
    chatId: string
    rolesData?: NullableJsonNullValueInput | InputJsonValue
    processData?: NullableJsonNullValueInput | InputJsonValue
    stepsData?: NullableJsonNullValueInput | InputJsonValue
    formsData?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    createdAt?: Date | string
  }

  export type ProcessSaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    rolesData?: NullableJsonNullValueInput | InputJsonValue
    processData?: NullableJsonNullValueInput | InputJsonValue
    stepsData?: NullableJsonNullValueInput | InputJsonValue
    formsData?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessSaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    rolesData?: NullableJsonNullValueInput | InputJsonValue
    processData?: NullableJsonNullValueInput | InputJsonValue
    stepsData?: NullableJsonNullValueInput | InputJsonValue
    formsData?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ApplicantProcessListRelationFilter = {
    every?: ApplicantProcessWhereInput
    some?: ApplicantProcessWhereInput
    none?: ApplicantProcessWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type FormListRelationFilter = {
    every?: FormWhereInput
    some?: FormWhereInput
    none?: FormWhereInput
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput
    some?: FolderWhereInput
    none?: FolderWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type OrganizationUserNullableScalarRelationFilter = {
    is?: OrganizationUserWhereInput | null
    isNot?: OrganizationUserWhereInput | null
  }

  export type ProcessListRelationFilter = {
    every?: ProcessWhereInput
    some?: ProcessWhereInput
    none?: ProcessWhereInput
  }

  export type ProcessedApplicationListRelationFilter = {
    every?: ProcessedApplicationWhereInput
    some?: ProcessedApplicationWhereInput
    none?: ProcessedApplicationWhereInput
  }

  export type QrCodeDocumentListRelationFilter = {
    every?: QrCodeDocumentWhereInput
    some?: QrCodeDocumentWhereInput
    none?: QrCodeDocumentWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ApplicantProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessedApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QrCodeDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photo?: SortOrder
    googleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photo?: SortOrder
    googleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    photo?: SortOrder
    googleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleStatus | EnumRoleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleStatus[] | ListEnumRoleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleStatus[] | ListEnumRoleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleStatusFilter<$PrismaModel> | $Enums.RoleStatus
  }

  export type GroupRoleListRelationFilter = {
    every?: GroupRoleWhereInput
    some?: GroupRoleWhereInput
    none?: GroupRoleWhereInput
  }

  export type ProcessRoleListRelationFilter = {
    every?: ProcessRoleWhereInput
    some?: ProcessRoleWhereInput
    none?: ProcessRoleWhereInput
  }

  export type GroupRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleStatus | EnumRoleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleStatus[] | ListEnumRoleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleStatus[] | ListEnumRoleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleStatusFilter<$PrismaModel>
    _max?: NestedEnumRoleStatusFilter<$PrismaModel>
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRoleOrderByRelevanceInput = {
    fields: UserRoleOrderByRelevanceFieldEnum | UserRoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FileOrderByRelevanceInput = {
    fields: FileOrderByRelevanceFieldEnum | FileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    size?: SortOrder
    isPrivate?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    size?: SortOrder
    isPrivate?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    size?: SortOrder
    isPrivate?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogOrderByRelevanceInput = {
    fields: AuditLogOrderByRelevanceFieldEnum | AuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumGroupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupStatus | EnumGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupStatusFilter<$PrismaModel> | $Enums.GroupStatus
  }

  export type GroupOrderByRelevanceInput = {
    fields: GroupOrderByRelevanceFieldEnum | GroupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGroupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupStatus | EnumGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupStatusWithAggregatesFilter<$PrismaModel> | $Enums.GroupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupStatusFilter<$PrismaModel>
    _max?: NestedEnumGroupStatusFilter<$PrismaModel>
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupRoleOrderByRelevanceInput = {
    fields: GroupRoleOrderByRelevanceFieldEnum | GroupRoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GroupRoleGroupIdRoleIdCompoundUniqueInput = {
    groupId: string
    roleId: string
  }

  export type GroupRoleCountOrderByAggregateInput = {
    groupId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type GroupRoleMaxOrderByAggregateInput = {
    groupId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type GroupRoleMinOrderByAggregateInput = {
    groupId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type EnumProcessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessType | EnumProcessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessTypeFilter<$PrismaModel> | $Enums.ProcessType
  }

  export type EnumProcessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusFilter<$PrismaModel> | $Enums.ProcessStatus
  }

  export type FormResponseListRelationFilter = {
    every?: FormResponseWhereInput
    some?: FormResponseWhereInput
    none?: FormResponseWhereInput
  }

  export type ProcessFormListRelationFilter = {
    every?: ProcessFormWhereInput
    some?: ProcessFormWhereInput
    none?: ProcessFormWhereInput
  }

  export type FormResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessOrderByRelevanceInput = {
    fields: ProcessOrderByRelevanceFieldEnum | ProcessOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProcessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    staffViewForms?: SortOrder
    applicantViewProcessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    staffViewForms?: SortOrder
    applicantViewProcessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    staffViewForms?: SortOrder
    applicantViewProcessLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProcessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessType | EnumProcessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProcessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessTypeFilter<$PrismaModel>
    _max?: NestedEnumProcessTypeFilter<$PrismaModel>
  }

  export type EnumProcessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessStatusFilter<$PrismaModel>
  }

  export type ProcessScalarRelationFilter = {
    is?: ProcessWhereInput
    isNot?: ProcessWhereInput
  }

  export type ProcessRoleOrderByRelevanceInput = {
    fields: ProcessRoleOrderByRelevanceFieldEnum | ProcessRoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProcessRoleProcessIdRoleIdCompoundUniqueInput = {
    processId: string
    roleId: string
  }

  export type ProcessRoleCountOrderByAggregateInput = {
    processId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type ProcessRoleMaxOrderByAggregateInput = {
    processId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type ProcessRoleMinOrderByAggregateInput = {
    processId?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
  }

  export type FolderOrderByRelevanceInput = {
    fields: FolderOrderByRelevanceFieldEnum | FolderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFormTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FormType | EnumFormTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTypeFilter<$PrismaModel> | $Enums.FormType
  }

  export type EnumFormStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FormStatus | EnumFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormStatusFilter<$PrismaModel> | $Enums.FormStatus
  }

  export type FolderNullableScalarRelationFilter = {
    is?: FolderWhereInput | null
    isNot?: FolderWhereInput | null
  }

  export type FormOrderByRelevanceInput = {
    fields: FormOrderByRelevanceFieldEnum | FormOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FormCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    creatorId?: SortOrder
    folderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    design?: SortOrder
  }

  export type FormMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    creatorId?: SortOrder
    folderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    creatorId?: SortOrder
    folderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFormTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormType | EnumFormTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTypeWithAggregatesFilter<$PrismaModel> | $Enums.FormType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormTypeFilter<$PrismaModel>
    _max?: NestedEnumFormTypeFilter<$PrismaModel>
  }

  export type EnumFormStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormStatus | EnumFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormStatusWithAggregatesFilter<$PrismaModel> | $Enums.FormStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormStatusFilter<$PrismaModel>
    _max?: NestedEnumFormStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ApplicantProcessScalarRelationFilter = {
    is?: ApplicantProcessWhereInput
    isNot?: ApplicantProcessWhereInput
  }

  export type FormScalarRelationFilter = {
    is?: FormWhereInput
    isNot?: FormWhereInput
  }

  export type FormResponseOrderByRelevanceInput = {
    fields: FormResponseOrderByRelevanceFieldEnum | FormResponseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FormResponseFormIdApplicantProcessIdCompoundUniqueInput = {
    formId: string
    applicantProcessId: string
  }

  export type FormResponseCountOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    applicantProcessId?: SortOrder
    responses?: SortOrder
    createdAt?: SortOrder
    processId?: SortOrder
  }

  export type FormResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    applicantProcessId?: SortOrder
    createdAt?: SortOrder
    processId?: SortOrder
  }

  export type FormResponseMinOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    applicantProcessId?: SortOrder
    createdAt?: SortOrder
    processId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumNextStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NextStepType | EnumNextStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NextStepType[] | ListEnumNextStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NextStepType[] | ListEnumNextStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNextStepTypeFilter<$PrismaModel> | $Enums.NextStepType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProcessFormOrderByRelevanceInput = {
    fields: ProcessFormOrderByRelevanceFieldEnum | ProcessFormOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProcessFormCountOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    formId?: SortOrder
    order?: SortOrder
    nextStepType?: SortOrder
    nextStepRoles?: SortOrder
    nextStaffId?: SortOrder
    nextStepSpecifiedTo?: SortOrder
    notificationType?: SortOrder
    notificationRoles?: SortOrder
    notificationToId?: SortOrder
    notificationComment?: SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessFormAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProcessFormMaxOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    formId?: SortOrder
    order?: SortOrder
    nextStepType?: SortOrder
    nextStaffId?: SortOrder
    nextStepSpecifiedTo?: SortOrder
    notificationType?: SortOrder
    notificationToId?: SortOrder
    notificationComment?: SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessFormMinOrderByAggregateInput = {
    id?: SortOrder
    processId?: SortOrder
    formId?: SortOrder
    order?: SortOrder
    nextStepType?: SortOrder
    nextStaffId?: SortOrder
    nextStepSpecifiedTo?: SortOrder
    notificationType?: SortOrder
    notificationToId?: SortOrder
    notificationComment?: SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessFormSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumNextStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NextStepType | EnumNextStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NextStepType[] | ListEnumNextStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NextStepType[] | ListEnumNextStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNextStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.NextStepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNextStepTypeFilter<$PrismaModel>
    _max?: NestedEnumNextStepTypeFilter<$PrismaModel>
  }

  export type APCompletedFormListRelationFilter = {
    every?: APCompletedFormWhereInput
    some?: APCompletedFormWhereInput
    none?: APCompletedFormWhereInput
  }

  export type ProcessCommentListRelationFilter = {
    every?: ProcessCommentWhereInput
    some?: ProcessCommentWhereInput
    none?: ProcessCommentWhereInput
  }

  export type APCompletedFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcessCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApplicantProcessOrderByRelevanceInput = {
    fields: ApplicantProcessOrderByRelevanceFieldEnum | ApplicantProcessOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ApplicantProcessCountOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    processId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ApplicantProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    processId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ApplicantProcessMinOrderByAggregateInput = {
    id?: SortOrder
    applicantId?: SortOrder
    processId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProcessedApplicationOrderByRelevanceInput = {
    fields: ProcessedApplicationOrderByRelevanceFieldEnum | ProcessedApplicationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProcessedApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    processId?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    formRoleIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessedApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    processId?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcessedApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    processId?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type APCompletedFormOrderByRelevanceInput = {
    fields: APCompletedFormOrderByRelevanceFieldEnum | APCompletedFormOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type APCompletedFormCountOrderByAggregateInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    reviewerId?: SortOrder
    nextStaffId?: SortOrder
    nextStepType?: SortOrder
    nextStepRoles?: SortOrder
    nextStepSpecifiedTo?: SortOrder
    notificationType?: SortOrder
    notificationToId?: SortOrder
    notificationToRoles?: SortOrder
    notificationComment?: SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
  }

  export type APCompletedFormMaxOrderByAggregateInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    reviewerId?: SortOrder
    nextStaffId?: SortOrder
    nextStepType?: SortOrder
    nextStepSpecifiedTo?: SortOrder
    notificationType?: SortOrder
    notificationToId?: SortOrder
    notificationComment?: SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
  }

  export type APCompletedFormMinOrderByAggregateInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    formId?: SortOrder
    reviewerId?: SortOrder
    nextStaffId?: SortOrder
    nextStepType?: SortOrder
    nextStepSpecifiedTo?: SortOrder
    notificationType?: SortOrder
    notificationToId?: SortOrder
    notificationComment?: SortOrder
    notifyApplicant?: SortOrder
    applicantNotificationContent?: SortOrder
    editApplicationStatus?: SortOrder
    applicantViewFormAfterCompletion?: SortOrder
    createdAt?: SortOrder
  }

  export type ProcessCommentOrderByRelevanceInput = {
    fields: ProcessCommentOrderByRelevanceFieldEnum | ProcessCommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProcessCommentCountOrderByAggregateInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ProcessCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ProcessCommentMinOrderByAggregateInput = {
    id?: SortOrder
    applicantProcessId?: SortOrder
    userId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationUserListRelationFilter = {
    every?: OrganizationUserWhereInput
    some?: OrganizationUserWhereInput
    none?: OrganizationUserWhereInput
  }

  export type OrganizationUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationUserOrderByRelevanceInput = {
    fields: OrganizationUserOrderByRelevanceFieldEnum | OrganizationUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrganizationUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    superiorId?: SortOrder
    title?: SortOrder
  }

  export type OrganizationUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    superiorId?: SortOrder
    title?: SortOrder
  }

  export type OrganizationUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    superiorId?: SortOrder
    title?: SortOrder
  }

  export type WidgetListRelationFilter = {
    every?: WidgetWhereInput
    some?: WidgetWhereInput
    none?: WidgetWhereInput
  }

  export type WidgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DashboardOrderByRelevanceInput = {
    fields: DashboardOrderByRelevanceFieldEnum | DashboardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DashboardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    allowedUsers?: SortOrder
    allowedRoles?: SortOrder
    layout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardScalarRelationFilter = {
    is?: DashboardWhereInput
    isNot?: DashboardWhereInput
  }

  export type WidgetOrderByRelevanceInput = {
    fields: WidgetOrderByRelevanceFieldEnum | WidgetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WidgetCountOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    title?: SortOrder
    visualizationType?: SortOrder
    config?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WidgetAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WidgetMaxOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    title?: SortOrder
    visualizationType?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WidgetMinOrderByAggregateInput = {
    id?: SortOrder
    dashboardId?: SortOrder
    title?: SortOrder
    visualizationType?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WidgetSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type QrCodeDocumentOrderByRelevanceInput = {
    fields: QrCodeDocumentOrderByRelevanceFieldEnum | QrCodeDocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QrCodeDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    documentName?: SortOrder
    fileName?: SortOrder
    qrCodeId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QrCodeDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentName?: SortOrder
    fileName?: SortOrder
    qrCodeId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QrCodeDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    documentName?: SortOrder
    fileName?: SortOrder
    qrCodeId?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OtpOrderByRelevanceInput = {
    fields: OtpOrderByRelevanceFieldEnum | OtpOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumManagementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ManagementType | EnumManagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ManagementType[] | ListEnumManagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ManagementType[] | ListEnumManagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumManagementTypeFilter<$PrismaModel> | $Enums.ManagementType
  }

  export type ManagementOrderByRelevanceInput = {
    fields: ManagementOrderByRelevanceFieldEnum | ManagementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ManagementCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagementMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagementMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    type?: SortOrder
    uploadedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumManagementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ManagementType | EnumManagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ManagementType[] | ListEnumManagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ManagementType[] | ListEnumManagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumManagementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ManagementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumManagementTypeFilter<$PrismaModel>
    _max?: NestedEnumManagementTypeFilter<$PrismaModel>
  }

  export type EnumAddToDatabaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AddToDatabaseStatus | EnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AddToDatabaseStatus[] | ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddToDatabaseStatus[] | ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAddToDatabaseStatusFilter<$PrismaModel> | $Enums.AddToDatabaseStatus
  }

  export type AddToDatabaseOrderByRelevanceInput = {
    fields: AddToDatabaseOrderByRelevanceFieldEnum | AddToDatabaseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AddToDatabaseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    levels?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddToDatabaseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddToDatabaseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAddToDatabaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddToDatabaseStatus | EnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AddToDatabaseStatus[] | ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddToDatabaseStatus[] | ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAddToDatabaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.AddToDatabaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddToDatabaseStatusFilter<$PrismaModel>
    _max?: NestedEnumAddToDatabaseStatusFilter<$PrismaModel>
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelevanceInput = {
    fields: ChatOrderByRelevanceFieldEnum | ChatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    visibility?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    visibility?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    userId?: SortOrder
    visibility?: SortOrder
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelevanceInput = {
    fields: MessageOrderByRelevanceFieldEnum | MessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    parts?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type VoteOrderByRelevanceInput = {
    fields: VoteOrderByRelevanceFieldEnum | VoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VoteChatIdMessageIdCompoundUniqueInput = {
    chatId: string
    messageId: string
  }

  export type VoteCountOrderByAggregateInput = {
    chatId?: SortOrder
    messageId?: SortOrder
    isUpvoted?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    chatId?: SortOrder
    messageId?: SortOrder
    isUpvoted?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    chatId?: SortOrder
    messageId?: SortOrder
    isUpvoted?: SortOrder
  }

  export type SuggestionListRelationFilter = {
    every?: SuggestionWhereInput
    some?: SuggestionWhereInput
    none?: SuggestionWhereInput
  }

  export type SuggestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelevanceInput = {
    fields: DocumentOrderByRelevanceFieldEnum | DocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentIdCreatedAtCompoundUniqueInput = {
    id: string
    createdAt: Date | string
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    kind?: SortOrder
    userId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    kind?: SortOrder
    userId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    kind?: SortOrder
    userId?: SortOrder
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type SuggestionOrderByRelevanceInput = {
    fields: SuggestionOrderByRelevanceFieldEnum | SuggestionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SuggestionCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentCreatedAt?: SortOrder
    originalText?: SortOrder
    suggestedText?: SortOrder
    description?: SortOrder
    isResolved?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestionMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentCreatedAt?: SortOrder
    originalText?: SortOrder
    suggestedText?: SortOrder
    description?: SortOrder
    isResolved?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SuggestionMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    documentCreatedAt?: SortOrder
    originalText?: SortOrder
    suggestedText?: SortOrder
    description?: SortOrder
    isResolved?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProcessSaveOrderByRelevanceInput = {
    fields: ProcessSaveOrderByRelevanceFieldEnum | ProcessSaveOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProcessSaveCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    rolesData?: SortOrder
    processData?: SortOrder
    stepsData?: SortOrder
    formsData?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type ProcessSaveMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type ProcessSaveMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type ApplicantProcessCreateNestedManyWithoutApplicantInput = {
    create?: XOR<ApplicantProcessCreateWithoutApplicantInput, ApplicantProcessUncheckedCreateWithoutApplicantInput> | ApplicantProcessCreateWithoutApplicantInput[] | ApplicantProcessUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutApplicantInput | ApplicantProcessCreateOrConnectWithoutApplicantInput[]
    createMany?: ApplicantProcessCreateManyApplicantInputEnvelope
    connect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutUserInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FormCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FormCreateWithoutCreatorInput, FormUncheckedCreateWithoutCreatorInput> | FormCreateWithoutCreatorInput[] | FormUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FormCreateOrConnectWithoutCreatorInput | FormCreateOrConnectWithoutCreatorInput[]
    createMany?: FormCreateManyCreatorInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type FolderCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FolderCreateWithoutCreatorInput, FolderUncheckedCreateWithoutCreatorInput> | FolderCreateWithoutCreatorInput[] | FolderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutCreatorInput | FolderCreateOrConnectWithoutCreatorInput[]
    createMany?: FolderCreateManyCreatorInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput> | GroupCreateWithoutCreatorInput[] | GroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatorInput | GroupCreateOrConnectWithoutCreatorInput[]
    createMany?: GroupCreateManyCreatorInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type OrganizationUserCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganizationUserCreateWithoutUserInput, OrganizationUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutUserInput
    connect?: OrganizationUserWhereUniqueInput
  }

  export type ProcessCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProcessCreateWithoutCreatorInput, ProcessUncheckedCreateWithoutCreatorInput> | ProcessCreateWithoutCreatorInput[] | ProcessUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutCreatorInput | ProcessCreateOrConnectWithoutCreatorInput[]
    createMany?: ProcessCreateManyCreatorInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type ProcessedApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessedApplicationCreateWithoutUserInput, ProcessedApplicationUncheckedCreateWithoutUserInput> | ProcessedApplicationCreateWithoutUserInput[] | ProcessedApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutUserInput | ProcessedApplicationCreateOrConnectWithoutUserInput[]
    createMany?: ProcessedApplicationCreateManyUserInputEnvelope
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
  }

  export type QrCodeDocumentCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QrCodeDocumentCreateWithoutCreatorInput, QrCodeDocumentUncheckedCreateWithoutCreatorInput> | QrCodeDocumentCreateWithoutCreatorInput[] | QrCodeDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QrCodeDocumentCreateOrConnectWithoutCreatorInput | QrCodeDocumentCreateOrConnectWithoutCreatorInput[]
    createMany?: QrCodeDocumentCreateManyCreatorInputEnvelope
    connect?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<ApplicantProcessCreateWithoutApplicantInput, ApplicantProcessUncheckedCreateWithoutApplicantInput> | ApplicantProcessCreateWithoutApplicantInput[] | ApplicantProcessUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutApplicantInput | ApplicantProcessCreateOrConnectWithoutApplicantInput[]
    createMany?: ApplicantProcessCreateManyApplicantInputEnvelope
    connect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FormUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FormCreateWithoutCreatorInput, FormUncheckedCreateWithoutCreatorInput> | FormCreateWithoutCreatorInput[] | FormUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FormCreateOrConnectWithoutCreatorInput | FormCreateOrConnectWithoutCreatorInput[]
    createMany?: FormCreateManyCreatorInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<FolderCreateWithoutCreatorInput, FolderUncheckedCreateWithoutCreatorInput> | FolderCreateWithoutCreatorInput[] | FolderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutCreatorInput | FolderCreateOrConnectWithoutCreatorInput[]
    createMany?: FolderCreateManyCreatorInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput> | GroupCreateWithoutCreatorInput[] | GroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatorInput | GroupCreateOrConnectWithoutCreatorInput[]
    createMany?: GroupCreateManyCreatorInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type OrganizationUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OrganizationUserCreateWithoutUserInput, OrganizationUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutUserInput
    connect?: OrganizationUserWhereUniqueInput
  }

  export type ProcessUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProcessCreateWithoutCreatorInput, ProcessUncheckedCreateWithoutCreatorInput> | ProcessCreateWithoutCreatorInput[] | ProcessUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutCreatorInput | ProcessCreateOrConnectWithoutCreatorInput[]
    createMany?: ProcessCreateManyCreatorInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProcessedApplicationCreateWithoutUserInput, ProcessedApplicationUncheckedCreateWithoutUserInput> | ProcessedApplicationCreateWithoutUserInput[] | ProcessedApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutUserInput | ProcessedApplicationCreateOrConnectWithoutUserInput[]
    createMany?: ProcessedApplicationCreateManyUserInputEnvelope
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
  }

  export type QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QrCodeDocumentCreateWithoutCreatorInput, QrCodeDocumentUncheckedCreateWithoutCreatorInput> | QrCodeDocumentCreateWithoutCreatorInput[] | QrCodeDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QrCodeDocumentCreateOrConnectWithoutCreatorInput | QrCodeDocumentCreateOrConnectWithoutCreatorInput[]
    createMany?: QrCodeDocumentCreateManyCreatorInputEnvelope
    connect?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ApplicantProcessUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<ApplicantProcessCreateWithoutApplicantInput, ApplicantProcessUncheckedCreateWithoutApplicantInput> | ApplicantProcessCreateWithoutApplicantInput[] | ApplicantProcessUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutApplicantInput | ApplicantProcessCreateOrConnectWithoutApplicantInput[]
    upsert?: ApplicantProcessUpsertWithWhereUniqueWithoutApplicantInput | ApplicantProcessUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: ApplicantProcessCreateManyApplicantInputEnvelope
    set?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    disconnect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    delete?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    connect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    update?: ApplicantProcessUpdateWithWhereUniqueWithoutApplicantInput | ApplicantProcessUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: ApplicantProcessUpdateManyWithWhereWithoutApplicantInput | ApplicantProcessUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: ApplicantProcessScalarWhereInput | ApplicantProcessScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type FileUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUserInput | FileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUserInput | FileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUserInput | FileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FormUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FormCreateWithoutCreatorInput, FormUncheckedCreateWithoutCreatorInput> | FormCreateWithoutCreatorInput[] | FormUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FormCreateOrConnectWithoutCreatorInput | FormCreateOrConnectWithoutCreatorInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutCreatorInput | FormUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FormCreateManyCreatorInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutCreatorInput | FormUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FormUpdateManyWithWhereWithoutCreatorInput | FormUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type FolderUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FolderCreateWithoutCreatorInput, FolderUncheckedCreateWithoutCreatorInput> | FolderCreateWithoutCreatorInput[] | FolderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutCreatorInput | FolderCreateOrConnectWithoutCreatorInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutCreatorInput | FolderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FolderCreateManyCreatorInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutCreatorInput | FolderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutCreatorInput | FolderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput> | GroupCreateWithoutCreatorInput[] | GroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatorInput | GroupCreateOrConnectWithoutCreatorInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutCreatorInput | GroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GroupCreateManyCreatorInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutCreatorInput | GroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutCreatorInput | GroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type OrganizationUserUpdateOneWithoutUserNestedInput = {
    create?: XOR<OrganizationUserCreateWithoutUserInput, OrganizationUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutUserInput
    upsert?: OrganizationUserUpsertWithoutUserInput
    disconnect?: OrganizationUserWhereInput | boolean
    delete?: OrganizationUserWhereInput | boolean
    connect?: OrganizationUserWhereUniqueInput
    update?: XOR<XOR<OrganizationUserUpdateToOneWithWhereWithoutUserInput, OrganizationUserUpdateWithoutUserInput>, OrganizationUserUncheckedUpdateWithoutUserInput>
  }

  export type ProcessUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProcessCreateWithoutCreatorInput, ProcessUncheckedCreateWithoutCreatorInput> | ProcessCreateWithoutCreatorInput[] | ProcessUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutCreatorInput | ProcessCreateOrConnectWithoutCreatorInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutCreatorInput | ProcessUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProcessCreateManyCreatorInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutCreatorInput | ProcessUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutCreatorInput | ProcessUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type ProcessedApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessedApplicationCreateWithoutUserInput, ProcessedApplicationUncheckedCreateWithoutUserInput> | ProcessedApplicationCreateWithoutUserInput[] | ProcessedApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutUserInput | ProcessedApplicationCreateOrConnectWithoutUserInput[]
    upsert?: ProcessedApplicationUpsertWithWhereUniqueWithoutUserInput | ProcessedApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessedApplicationCreateManyUserInputEnvelope
    set?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    disconnect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    delete?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    update?: ProcessedApplicationUpdateWithWhereUniqueWithoutUserInput | ProcessedApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessedApplicationUpdateManyWithWhereWithoutUserInput | ProcessedApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessedApplicationScalarWhereInput | ProcessedApplicationScalarWhereInput[]
  }

  export type QrCodeDocumentUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QrCodeDocumentCreateWithoutCreatorInput, QrCodeDocumentUncheckedCreateWithoutCreatorInput> | QrCodeDocumentCreateWithoutCreatorInput[] | QrCodeDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QrCodeDocumentCreateOrConnectWithoutCreatorInput | QrCodeDocumentCreateOrConnectWithoutCreatorInput[]
    upsert?: QrCodeDocumentUpsertWithWhereUniqueWithoutCreatorInput | QrCodeDocumentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QrCodeDocumentCreateManyCreatorInputEnvelope
    set?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
    disconnect?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
    delete?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
    connect?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
    update?: QrCodeDocumentUpdateWithWhereUniqueWithoutCreatorInput | QrCodeDocumentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QrCodeDocumentUpdateManyWithWhereWithoutCreatorInput | QrCodeDocumentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QrCodeDocumentScalarWhereInput | QrCodeDocumentScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<ApplicantProcessCreateWithoutApplicantInput, ApplicantProcessUncheckedCreateWithoutApplicantInput> | ApplicantProcessCreateWithoutApplicantInput[] | ApplicantProcessUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutApplicantInput | ApplicantProcessCreateOrConnectWithoutApplicantInput[]
    upsert?: ApplicantProcessUpsertWithWhereUniqueWithoutApplicantInput | ApplicantProcessUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: ApplicantProcessCreateManyApplicantInputEnvelope
    set?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    disconnect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    delete?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    connect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    update?: ApplicantProcessUpdateWithWhereUniqueWithoutApplicantInput | ApplicantProcessUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: ApplicantProcessUpdateManyWithWhereWithoutApplicantInput | ApplicantProcessUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: ApplicantProcessScalarWhereInput | ApplicantProcessScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUserInput | FileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUserInput | FileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUserInput | FileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FormUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FormCreateWithoutCreatorInput, FormUncheckedCreateWithoutCreatorInput> | FormCreateWithoutCreatorInput[] | FormUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FormCreateOrConnectWithoutCreatorInput | FormCreateOrConnectWithoutCreatorInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutCreatorInput | FormUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FormCreateManyCreatorInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutCreatorInput | FormUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FormUpdateManyWithWhereWithoutCreatorInput | FormUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<FolderCreateWithoutCreatorInput, FolderUncheckedCreateWithoutCreatorInput> | FolderCreateWithoutCreatorInput[] | FolderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutCreatorInput | FolderCreateOrConnectWithoutCreatorInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutCreatorInput | FolderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: FolderCreateManyCreatorInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutCreatorInput | FolderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutCreatorInput | FolderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput> | GroupCreateWithoutCreatorInput[] | GroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatorInput | GroupCreateOrConnectWithoutCreatorInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutCreatorInput | GroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GroupCreateManyCreatorInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutCreatorInput | GroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutCreatorInput | GroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type OrganizationUserUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OrganizationUserCreateWithoutUserInput, OrganizationUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutUserInput
    upsert?: OrganizationUserUpsertWithoutUserInput
    disconnect?: OrganizationUserWhereInput | boolean
    delete?: OrganizationUserWhereInput | boolean
    connect?: OrganizationUserWhereUniqueInput
    update?: XOR<XOR<OrganizationUserUpdateToOneWithWhereWithoutUserInput, OrganizationUserUpdateWithoutUserInput>, OrganizationUserUncheckedUpdateWithoutUserInput>
  }

  export type ProcessUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProcessCreateWithoutCreatorInput, ProcessUncheckedCreateWithoutCreatorInput> | ProcessCreateWithoutCreatorInput[] | ProcessUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutCreatorInput | ProcessCreateOrConnectWithoutCreatorInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutCreatorInput | ProcessUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProcessCreateManyCreatorInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutCreatorInput | ProcessUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutCreatorInput | ProcessUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProcessedApplicationCreateWithoutUserInput, ProcessedApplicationUncheckedCreateWithoutUserInput> | ProcessedApplicationCreateWithoutUserInput[] | ProcessedApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutUserInput | ProcessedApplicationCreateOrConnectWithoutUserInput[]
    upsert?: ProcessedApplicationUpsertWithWhereUniqueWithoutUserInput | ProcessedApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProcessedApplicationCreateManyUserInputEnvelope
    set?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    disconnect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    delete?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    update?: ProcessedApplicationUpdateWithWhereUniqueWithoutUserInput | ProcessedApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProcessedApplicationUpdateManyWithWhereWithoutUserInput | ProcessedApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProcessedApplicationScalarWhereInput | ProcessedApplicationScalarWhereInput[]
  }

  export type QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QrCodeDocumentCreateWithoutCreatorInput, QrCodeDocumentUncheckedCreateWithoutCreatorInput> | QrCodeDocumentCreateWithoutCreatorInput[] | QrCodeDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QrCodeDocumentCreateOrConnectWithoutCreatorInput | QrCodeDocumentCreateOrConnectWithoutCreatorInput[]
    upsert?: QrCodeDocumentUpsertWithWhereUniqueWithoutCreatorInput | QrCodeDocumentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QrCodeDocumentCreateManyCreatorInputEnvelope
    set?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
    disconnect?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
    delete?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
    connect?: QrCodeDocumentWhereUniqueInput | QrCodeDocumentWhereUniqueInput[]
    update?: QrCodeDocumentUpdateWithWhereUniqueWithoutCreatorInput | QrCodeDocumentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QrCodeDocumentUpdateManyWithWhereWithoutCreatorInput | QrCodeDocumentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QrCodeDocumentScalarWhereInput | QrCodeDocumentScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type GroupRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<GroupRoleCreateWithoutRoleInput, GroupRoleUncheckedCreateWithoutRoleInput> | GroupRoleCreateWithoutRoleInput[] | GroupRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: GroupRoleCreateOrConnectWithoutRoleInput | GroupRoleCreateOrConnectWithoutRoleInput[]
    createMany?: GroupRoleCreateManyRoleInputEnvelope
    connect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
  }

  export type ProcessRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<ProcessRoleCreateWithoutRoleInput, ProcessRoleUncheckedCreateWithoutRoleInput> | ProcessRoleCreateWithoutRoleInput[] | ProcessRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: ProcessRoleCreateOrConnectWithoutRoleInput | ProcessRoleCreateOrConnectWithoutRoleInput[]
    createMany?: ProcessRoleCreateManyRoleInputEnvelope
    connect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type GroupRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<GroupRoleCreateWithoutRoleInput, GroupRoleUncheckedCreateWithoutRoleInput> | GroupRoleCreateWithoutRoleInput[] | GroupRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: GroupRoleCreateOrConnectWithoutRoleInput | GroupRoleCreateOrConnectWithoutRoleInput[]
    createMany?: GroupRoleCreateManyRoleInputEnvelope
    connect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
  }

  export type ProcessRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<ProcessRoleCreateWithoutRoleInput, ProcessRoleUncheckedCreateWithoutRoleInput> | ProcessRoleCreateWithoutRoleInput[] | ProcessRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: ProcessRoleCreateOrConnectWithoutRoleInput | ProcessRoleCreateOrConnectWithoutRoleInput[]
    createMany?: ProcessRoleCreateManyRoleInputEnvelope
    connect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type EnumRoleStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoleStatus
  }

  export type GroupRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<GroupRoleCreateWithoutRoleInput, GroupRoleUncheckedCreateWithoutRoleInput> | GroupRoleCreateWithoutRoleInput[] | GroupRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: GroupRoleCreateOrConnectWithoutRoleInput | GroupRoleCreateOrConnectWithoutRoleInput[]
    upsert?: GroupRoleUpsertWithWhereUniqueWithoutRoleInput | GroupRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: GroupRoleCreateManyRoleInputEnvelope
    set?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    disconnect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    delete?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    connect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    update?: GroupRoleUpdateWithWhereUniqueWithoutRoleInput | GroupRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: GroupRoleUpdateManyWithWhereWithoutRoleInput | GroupRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: GroupRoleScalarWhereInput | GroupRoleScalarWhereInput[]
  }

  export type ProcessRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<ProcessRoleCreateWithoutRoleInput, ProcessRoleUncheckedCreateWithoutRoleInput> | ProcessRoleCreateWithoutRoleInput[] | ProcessRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: ProcessRoleCreateOrConnectWithoutRoleInput | ProcessRoleCreateOrConnectWithoutRoleInput[]
    upsert?: ProcessRoleUpsertWithWhereUniqueWithoutRoleInput | ProcessRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: ProcessRoleCreateManyRoleInputEnvelope
    set?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    disconnect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    delete?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    connect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    update?: ProcessRoleUpdateWithWhereUniqueWithoutRoleInput | ProcessRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: ProcessRoleUpdateManyWithWhereWithoutRoleInput | ProcessRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: ProcessRoleScalarWhereInput | ProcessRoleScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type GroupRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<GroupRoleCreateWithoutRoleInput, GroupRoleUncheckedCreateWithoutRoleInput> | GroupRoleCreateWithoutRoleInput[] | GroupRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: GroupRoleCreateOrConnectWithoutRoleInput | GroupRoleCreateOrConnectWithoutRoleInput[]
    upsert?: GroupRoleUpsertWithWhereUniqueWithoutRoleInput | GroupRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: GroupRoleCreateManyRoleInputEnvelope
    set?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    disconnect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    delete?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    connect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    update?: GroupRoleUpdateWithWhereUniqueWithoutRoleInput | GroupRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: GroupRoleUpdateManyWithWhereWithoutRoleInput | GroupRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: GroupRoleScalarWhereInput | GroupRoleScalarWhereInput[]
  }

  export type ProcessRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<ProcessRoleCreateWithoutRoleInput, ProcessRoleUncheckedCreateWithoutRoleInput> | ProcessRoleCreateWithoutRoleInput[] | ProcessRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: ProcessRoleCreateOrConnectWithoutRoleInput | ProcessRoleCreateOrConnectWithoutRoleInput[]
    upsert?: ProcessRoleUpsertWithWhereUniqueWithoutRoleInput | ProcessRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: ProcessRoleCreateManyRoleInputEnvelope
    set?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    disconnect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    delete?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    connect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    update?: ProcessRoleUpdateWithWhereUniqueWithoutRoleInput | ProcessRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: ProcessRoleUpdateManyWithWhereWithoutRoleInput | ProcessRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: ProcessRoleScalarWhereInput | ProcessRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserCreateNestedOneWithoutFilesInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    upsert?: UserUpsertWithoutFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFilesInput, UserUpdateWithoutFilesInput>, UserUncheckedUpdateWithoutFilesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type GroupRoleCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupRoleCreateWithoutGroupInput, GroupRoleUncheckedCreateWithoutGroupInput> | GroupRoleCreateWithoutGroupInput[] | GroupRoleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupRoleCreateOrConnectWithoutGroupInput | GroupRoleCreateOrConnectWithoutGroupInput[]
    createMany?: GroupRoleCreateManyGroupInputEnvelope
    connect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedGroupsInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type ProcessCreateNestedManyWithoutGroupInput = {
    create?: XOR<ProcessCreateWithoutGroupInput, ProcessUncheckedCreateWithoutGroupInput> | ProcessCreateWithoutGroupInput[] | ProcessUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGroupInput | ProcessCreateOrConnectWithoutGroupInput[]
    createMany?: ProcessCreateManyGroupInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type GroupRoleUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupRoleCreateWithoutGroupInput, GroupRoleUncheckedCreateWithoutGroupInput> | GroupRoleCreateWithoutGroupInput[] | GroupRoleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupRoleCreateOrConnectWithoutGroupInput | GroupRoleCreateOrConnectWithoutGroupInput[]
    createMany?: GroupRoleCreateManyGroupInputEnvelope
    connect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
  }

  export type ProcessUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ProcessCreateWithoutGroupInput, ProcessUncheckedCreateWithoutGroupInput> | ProcessCreateWithoutGroupInput[] | ProcessUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGroupInput | ProcessCreateOrConnectWithoutGroupInput[]
    createMany?: ProcessCreateManyGroupInputEnvelope
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
  }

  export type EnumGroupStatusFieldUpdateOperationsInput = {
    set?: $Enums.GroupStatus
  }

  export type GroupRoleUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupRoleCreateWithoutGroupInput, GroupRoleUncheckedCreateWithoutGroupInput> | GroupRoleCreateWithoutGroupInput[] | GroupRoleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupRoleCreateOrConnectWithoutGroupInput | GroupRoleCreateOrConnectWithoutGroupInput[]
    upsert?: GroupRoleUpsertWithWhereUniqueWithoutGroupInput | GroupRoleUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupRoleCreateManyGroupInputEnvelope
    set?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    disconnect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    delete?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    connect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    update?: GroupRoleUpdateWithWhereUniqueWithoutGroupInput | GroupRoleUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupRoleUpdateManyWithWhereWithoutGroupInput | GroupRoleUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupRoleScalarWhereInput | GroupRoleScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedGroupsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    upsert?: UserUpsertWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedGroupsInput, UserUpdateWithoutCreatedGroupsInput>, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type ProcessUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ProcessCreateWithoutGroupInput, ProcessUncheckedCreateWithoutGroupInput> | ProcessCreateWithoutGroupInput[] | ProcessUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGroupInput | ProcessCreateOrConnectWithoutGroupInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutGroupInput | ProcessUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ProcessCreateManyGroupInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutGroupInput | ProcessUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutGroupInput | ProcessUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type GroupRoleUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupRoleCreateWithoutGroupInput, GroupRoleUncheckedCreateWithoutGroupInput> | GroupRoleCreateWithoutGroupInput[] | GroupRoleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupRoleCreateOrConnectWithoutGroupInput | GroupRoleCreateOrConnectWithoutGroupInput[]
    upsert?: GroupRoleUpsertWithWhereUniqueWithoutGroupInput | GroupRoleUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupRoleCreateManyGroupInputEnvelope
    set?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    disconnect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    delete?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    connect?: GroupRoleWhereUniqueInput | GroupRoleWhereUniqueInput[]
    update?: GroupRoleUpdateWithWhereUniqueWithoutGroupInput | GroupRoleUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupRoleUpdateManyWithWhereWithoutGroupInput | GroupRoleUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupRoleScalarWhereInput | GroupRoleScalarWhereInput[]
  }

  export type ProcessUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ProcessCreateWithoutGroupInput, ProcessUncheckedCreateWithoutGroupInput> | ProcessCreateWithoutGroupInput[] | ProcessUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ProcessCreateOrConnectWithoutGroupInput | ProcessCreateOrConnectWithoutGroupInput[]
    upsert?: ProcessUpsertWithWhereUniqueWithoutGroupInput | ProcessUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ProcessCreateManyGroupInputEnvelope
    set?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    disconnect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    delete?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    connect?: ProcessWhereUniqueInput | ProcessWhereUniqueInput[]
    update?: ProcessUpdateWithWhereUniqueWithoutGroupInput | ProcessUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ProcessUpdateManyWithWhereWithoutGroupInput | ProcessUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutRolesInput = {
    create?: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutRolesInput
    connect?: GroupWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutGroupsInput = {
    create?: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutGroupsInput
    connect?: RoleWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutRolesInput
    upsert?: GroupUpsertWithoutRolesInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutRolesInput, GroupUpdateWithoutRolesInput>, GroupUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutGroupsInput
    upsert?: RoleUpsertWithoutGroupsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutGroupsInput, RoleUpdateWithoutGroupsInput>, RoleUncheckedUpdateWithoutGroupsInput>
  }

  export type ApplicantProcessCreateNestedManyWithoutProcessInput = {
    create?: XOR<ApplicantProcessCreateWithoutProcessInput, ApplicantProcessUncheckedCreateWithoutProcessInput> | ApplicantProcessCreateWithoutProcessInput[] | ApplicantProcessUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutProcessInput | ApplicantProcessCreateOrConnectWithoutProcessInput[]
    createMany?: ApplicantProcessCreateManyProcessInputEnvelope
    connect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
  }

  export type FormResponseCreateNestedManyWithoutProcessInput = {
    create?: XOR<FormResponseCreateWithoutProcessInput, FormResponseUncheckedCreateWithoutProcessInput> | FormResponseCreateWithoutProcessInput[] | FormResponseUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutProcessInput | FormResponseCreateOrConnectWithoutProcessInput[]
    createMany?: FormResponseCreateManyProcessInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type ProcessFormCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessFormCreateWithoutProcessInput, ProcessFormUncheckedCreateWithoutProcessInput> | ProcessFormCreateWithoutProcessInput[] | ProcessFormUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessFormCreateOrConnectWithoutProcessInput | ProcessFormCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessFormCreateManyProcessInputEnvelope
    connect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
  }

  export type ProcessedApplicationCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessedApplicationCreateWithoutProcessInput, ProcessedApplicationUncheckedCreateWithoutProcessInput> | ProcessedApplicationCreateWithoutProcessInput[] | ProcessedApplicationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutProcessInput | ProcessedApplicationCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessedApplicationCreateManyProcessInputEnvelope
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
  }

  export type ProcessRoleCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessRoleCreateWithoutProcessInput, ProcessRoleUncheckedCreateWithoutProcessInput> | ProcessRoleCreateWithoutProcessInput[] | ProcessRoleUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessRoleCreateOrConnectWithoutProcessInput | ProcessRoleCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessRoleCreateManyProcessInputEnvelope
    connect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedProcessesInput = {
    create?: XOR<UserCreateWithoutCreatedProcessesInput, UserUncheckedCreateWithoutCreatedProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProcessesInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutProcessesInput = {
    create?: XOR<GroupCreateWithoutProcessesInput, GroupUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutProcessesInput
    connect?: GroupWhereUniqueInput
  }

  export type ApplicantProcessUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<ApplicantProcessCreateWithoutProcessInput, ApplicantProcessUncheckedCreateWithoutProcessInput> | ApplicantProcessCreateWithoutProcessInput[] | ApplicantProcessUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutProcessInput | ApplicantProcessCreateOrConnectWithoutProcessInput[]
    createMany?: ApplicantProcessCreateManyProcessInputEnvelope
    connect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
  }

  export type FormResponseUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<FormResponseCreateWithoutProcessInput, FormResponseUncheckedCreateWithoutProcessInput> | FormResponseCreateWithoutProcessInput[] | FormResponseUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutProcessInput | FormResponseCreateOrConnectWithoutProcessInput[]
    createMany?: FormResponseCreateManyProcessInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type ProcessFormUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessFormCreateWithoutProcessInput, ProcessFormUncheckedCreateWithoutProcessInput> | ProcessFormCreateWithoutProcessInput[] | ProcessFormUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessFormCreateOrConnectWithoutProcessInput | ProcessFormCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessFormCreateManyProcessInputEnvelope
    connect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
  }

  export type ProcessedApplicationUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessedApplicationCreateWithoutProcessInput, ProcessedApplicationUncheckedCreateWithoutProcessInput> | ProcessedApplicationCreateWithoutProcessInput[] | ProcessedApplicationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutProcessInput | ProcessedApplicationCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessedApplicationCreateManyProcessInputEnvelope
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
  }

  export type ProcessRoleUncheckedCreateNestedManyWithoutProcessInput = {
    create?: XOR<ProcessRoleCreateWithoutProcessInput, ProcessRoleUncheckedCreateWithoutProcessInput> | ProcessRoleCreateWithoutProcessInput[] | ProcessRoleUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessRoleCreateOrConnectWithoutProcessInput | ProcessRoleCreateOrConnectWithoutProcessInput[]
    createMany?: ProcessRoleCreateManyProcessInputEnvelope
    connect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
  }

  export type EnumProcessTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProcessType
  }

  export type EnumProcessStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessStatus
  }

  export type ApplicantProcessUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ApplicantProcessCreateWithoutProcessInput, ApplicantProcessUncheckedCreateWithoutProcessInput> | ApplicantProcessCreateWithoutProcessInput[] | ApplicantProcessUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutProcessInput | ApplicantProcessCreateOrConnectWithoutProcessInput[]
    upsert?: ApplicantProcessUpsertWithWhereUniqueWithoutProcessInput | ApplicantProcessUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ApplicantProcessCreateManyProcessInputEnvelope
    set?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    disconnect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    delete?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    connect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    update?: ApplicantProcessUpdateWithWhereUniqueWithoutProcessInput | ApplicantProcessUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ApplicantProcessUpdateManyWithWhereWithoutProcessInput | ApplicantProcessUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ApplicantProcessScalarWhereInput | ApplicantProcessScalarWhereInput[]
  }

  export type FormResponseUpdateManyWithoutProcessNestedInput = {
    create?: XOR<FormResponseCreateWithoutProcessInput, FormResponseUncheckedCreateWithoutProcessInput> | FormResponseCreateWithoutProcessInput[] | FormResponseUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutProcessInput | FormResponseCreateOrConnectWithoutProcessInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutProcessInput | FormResponseUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: FormResponseCreateManyProcessInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutProcessInput | FormResponseUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutProcessInput | FormResponseUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type ProcessFormUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessFormCreateWithoutProcessInput, ProcessFormUncheckedCreateWithoutProcessInput> | ProcessFormCreateWithoutProcessInput[] | ProcessFormUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessFormCreateOrConnectWithoutProcessInput | ProcessFormCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessFormUpsertWithWhereUniqueWithoutProcessInput | ProcessFormUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessFormCreateManyProcessInputEnvelope
    set?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    disconnect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    delete?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    connect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    update?: ProcessFormUpdateWithWhereUniqueWithoutProcessInput | ProcessFormUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessFormUpdateManyWithWhereWithoutProcessInput | ProcessFormUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessFormScalarWhereInput | ProcessFormScalarWhereInput[]
  }

  export type ProcessedApplicationUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessedApplicationCreateWithoutProcessInput, ProcessedApplicationUncheckedCreateWithoutProcessInput> | ProcessedApplicationCreateWithoutProcessInput[] | ProcessedApplicationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutProcessInput | ProcessedApplicationCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessedApplicationUpsertWithWhereUniqueWithoutProcessInput | ProcessedApplicationUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessedApplicationCreateManyProcessInputEnvelope
    set?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    disconnect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    delete?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    update?: ProcessedApplicationUpdateWithWhereUniqueWithoutProcessInput | ProcessedApplicationUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessedApplicationUpdateManyWithWhereWithoutProcessInput | ProcessedApplicationUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessedApplicationScalarWhereInput | ProcessedApplicationScalarWhereInput[]
  }

  export type ProcessRoleUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessRoleCreateWithoutProcessInput, ProcessRoleUncheckedCreateWithoutProcessInput> | ProcessRoleCreateWithoutProcessInput[] | ProcessRoleUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessRoleCreateOrConnectWithoutProcessInput | ProcessRoleCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessRoleUpsertWithWhereUniqueWithoutProcessInput | ProcessRoleUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessRoleCreateManyProcessInputEnvelope
    set?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    disconnect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    delete?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    connect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    update?: ProcessRoleUpdateWithWhereUniqueWithoutProcessInput | ProcessRoleUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessRoleUpdateManyWithWhereWithoutProcessInput | ProcessRoleUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessRoleScalarWhereInput | ProcessRoleScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedProcessesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProcessesInput, UserUncheckedCreateWithoutCreatedProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProcessesInput
    upsert?: UserUpsertWithoutCreatedProcessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProcessesInput, UserUpdateWithoutCreatedProcessesInput>, UserUncheckedUpdateWithoutCreatedProcessesInput>
  }

  export type GroupUpdateOneRequiredWithoutProcessesNestedInput = {
    create?: XOR<GroupCreateWithoutProcessesInput, GroupUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutProcessesInput
    upsert?: GroupUpsertWithoutProcessesInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutProcessesInput, GroupUpdateWithoutProcessesInput>, GroupUncheckedUpdateWithoutProcessesInput>
  }

  export type ApplicantProcessUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ApplicantProcessCreateWithoutProcessInput, ApplicantProcessUncheckedCreateWithoutProcessInput> | ApplicantProcessCreateWithoutProcessInput[] | ApplicantProcessUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutProcessInput | ApplicantProcessCreateOrConnectWithoutProcessInput[]
    upsert?: ApplicantProcessUpsertWithWhereUniqueWithoutProcessInput | ApplicantProcessUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ApplicantProcessCreateManyProcessInputEnvelope
    set?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    disconnect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    delete?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    connect?: ApplicantProcessWhereUniqueInput | ApplicantProcessWhereUniqueInput[]
    update?: ApplicantProcessUpdateWithWhereUniqueWithoutProcessInput | ApplicantProcessUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ApplicantProcessUpdateManyWithWhereWithoutProcessInput | ApplicantProcessUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ApplicantProcessScalarWhereInput | ApplicantProcessScalarWhereInput[]
  }

  export type FormResponseUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<FormResponseCreateWithoutProcessInput, FormResponseUncheckedCreateWithoutProcessInput> | FormResponseCreateWithoutProcessInput[] | FormResponseUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutProcessInput | FormResponseCreateOrConnectWithoutProcessInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutProcessInput | FormResponseUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: FormResponseCreateManyProcessInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutProcessInput | FormResponseUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutProcessInput | FormResponseUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type ProcessFormUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessFormCreateWithoutProcessInput, ProcessFormUncheckedCreateWithoutProcessInput> | ProcessFormCreateWithoutProcessInput[] | ProcessFormUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessFormCreateOrConnectWithoutProcessInput | ProcessFormCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessFormUpsertWithWhereUniqueWithoutProcessInput | ProcessFormUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessFormCreateManyProcessInputEnvelope
    set?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    disconnect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    delete?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    connect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    update?: ProcessFormUpdateWithWhereUniqueWithoutProcessInput | ProcessFormUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessFormUpdateManyWithWhereWithoutProcessInput | ProcessFormUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessFormScalarWhereInput | ProcessFormScalarWhereInput[]
  }

  export type ProcessedApplicationUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessedApplicationCreateWithoutProcessInput, ProcessedApplicationUncheckedCreateWithoutProcessInput> | ProcessedApplicationCreateWithoutProcessInput[] | ProcessedApplicationUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutProcessInput | ProcessedApplicationCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessedApplicationUpsertWithWhereUniqueWithoutProcessInput | ProcessedApplicationUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessedApplicationCreateManyProcessInputEnvelope
    set?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    disconnect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    delete?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    update?: ProcessedApplicationUpdateWithWhereUniqueWithoutProcessInput | ProcessedApplicationUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessedApplicationUpdateManyWithWhereWithoutProcessInput | ProcessedApplicationUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessedApplicationScalarWhereInput | ProcessedApplicationScalarWhereInput[]
  }

  export type ProcessRoleUncheckedUpdateManyWithoutProcessNestedInput = {
    create?: XOR<ProcessRoleCreateWithoutProcessInput, ProcessRoleUncheckedCreateWithoutProcessInput> | ProcessRoleCreateWithoutProcessInput[] | ProcessRoleUncheckedCreateWithoutProcessInput[]
    connectOrCreate?: ProcessRoleCreateOrConnectWithoutProcessInput | ProcessRoleCreateOrConnectWithoutProcessInput[]
    upsert?: ProcessRoleUpsertWithWhereUniqueWithoutProcessInput | ProcessRoleUpsertWithWhereUniqueWithoutProcessInput[]
    createMany?: ProcessRoleCreateManyProcessInputEnvelope
    set?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    disconnect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    delete?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    connect?: ProcessRoleWhereUniqueInput | ProcessRoleWhereUniqueInput[]
    update?: ProcessRoleUpdateWithWhereUniqueWithoutProcessInput | ProcessRoleUpdateWithWhereUniqueWithoutProcessInput[]
    updateMany?: ProcessRoleUpdateManyWithWhereWithoutProcessInput | ProcessRoleUpdateManyWithWhereWithoutProcessInput[]
    deleteMany?: ProcessRoleScalarWhereInput | ProcessRoleScalarWhereInput[]
  }

  export type ProcessCreateNestedOneWithoutRolesInput = {
    create?: XOR<ProcessCreateWithoutRolesInput, ProcessUncheckedCreateWithoutRolesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutRolesInput
    connect?: ProcessWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutProcessesInput = {
    create?: XOR<RoleCreateWithoutProcessesInput, RoleUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutProcessesInput
    connect?: RoleWhereUniqueInput
  }

  export type ProcessUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<ProcessCreateWithoutRolesInput, ProcessUncheckedCreateWithoutRolesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutRolesInput
    upsert?: ProcessUpsertWithoutRolesInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutRolesInput, ProcessUpdateWithoutRolesInput>, ProcessUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutProcessesNestedInput = {
    create?: XOR<RoleCreateWithoutProcessesInput, RoleUncheckedCreateWithoutProcessesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutProcessesInput
    upsert?: RoleUpsertWithoutProcessesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutProcessesInput, RoleUpdateWithoutProcessesInput>, RoleUncheckedUpdateWithoutProcessesInput>
  }

  export type UserCreateNestedOneWithoutCreatedFoldersInput = {
    create?: XOR<UserCreateWithoutCreatedFoldersInput, UserUncheckedCreateWithoutCreatedFoldersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFoldersInput
    connect?: UserWhereUniqueInput
  }

  export type FormCreateNestedManyWithoutFolderInput = {
    create?: XOR<FormCreateWithoutFolderInput, FormUncheckedCreateWithoutFolderInput> | FormCreateWithoutFolderInput[] | FormUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FormCreateOrConnectWithoutFolderInput | FormCreateOrConnectWithoutFolderInput[]
    createMany?: FormCreateManyFolderInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type FormUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FormCreateWithoutFolderInput, FormUncheckedCreateWithoutFolderInput> | FormCreateWithoutFolderInput[] | FormUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FormCreateOrConnectWithoutFolderInput | FormCreateOrConnectWithoutFolderInput[]
    createMany?: FormCreateManyFolderInputEnvelope
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedFoldersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedFoldersInput, UserUncheckedCreateWithoutCreatedFoldersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFoldersInput
    upsert?: UserUpsertWithoutCreatedFoldersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedFoldersInput, UserUpdateWithoutCreatedFoldersInput>, UserUncheckedUpdateWithoutCreatedFoldersInput>
  }

  export type FormUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FormCreateWithoutFolderInput, FormUncheckedCreateWithoutFolderInput> | FormCreateWithoutFolderInput[] | FormUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FormCreateOrConnectWithoutFolderInput | FormCreateOrConnectWithoutFolderInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutFolderInput | FormUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FormCreateManyFolderInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutFolderInput | FormUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FormUpdateManyWithWhereWithoutFolderInput | FormUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type FormUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FormCreateWithoutFolderInput, FormUncheckedCreateWithoutFolderInput> | FormCreateWithoutFolderInput[] | FormUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FormCreateOrConnectWithoutFolderInput | FormCreateOrConnectWithoutFolderInput[]
    upsert?: FormUpsertWithWhereUniqueWithoutFolderInput | FormUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FormCreateManyFolderInputEnvelope
    set?: FormWhereUniqueInput | FormWhereUniqueInput[]
    disconnect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    delete?: FormWhereUniqueInput | FormWhereUniqueInput[]
    connect?: FormWhereUniqueInput | FormWhereUniqueInput[]
    update?: FormUpdateWithWhereUniqueWithoutFolderInput | FormUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FormUpdateManyWithWhereWithoutFolderInput | FormUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FormScalarWhereInput | FormScalarWhereInput[]
  }

  export type FormResponseCreateNestedManyWithoutFormInput = {
    create?: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput> | FormResponseCreateWithoutFormInput[] | FormResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutFormInput | FormResponseCreateOrConnectWithoutFormInput[]
    createMany?: FormResponseCreateManyFormInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedFormsInput = {
    create?: XOR<UserCreateWithoutCreatedFormsInput, UserUncheckedCreateWithoutCreatedFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFormsInput
    connect?: UserWhereUniqueInput
  }

  export type FolderCreateNestedOneWithoutFormsInput = {
    create?: XOR<FolderCreateWithoutFormsInput, FolderUncheckedCreateWithoutFormsInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFormsInput
    connect?: FolderWhereUniqueInput
  }

  export type ProcessFormCreateNestedManyWithoutFormInput = {
    create?: XOR<ProcessFormCreateWithoutFormInput, ProcessFormUncheckedCreateWithoutFormInput> | ProcessFormCreateWithoutFormInput[] | ProcessFormUncheckedCreateWithoutFormInput[]
    connectOrCreate?: ProcessFormCreateOrConnectWithoutFormInput | ProcessFormCreateOrConnectWithoutFormInput[]
    createMany?: ProcessFormCreateManyFormInputEnvelope
    connect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
  }

  export type FormResponseUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput> | FormResponseCreateWithoutFormInput[] | FormResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutFormInput | FormResponseCreateOrConnectWithoutFormInput[]
    createMany?: FormResponseCreateManyFormInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type ProcessFormUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<ProcessFormCreateWithoutFormInput, ProcessFormUncheckedCreateWithoutFormInput> | ProcessFormCreateWithoutFormInput[] | ProcessFormUncheckedCreateWithoutFormInput[]
    connectOrCreate?: ProcessFormCreateOrConnectWithoutFormInput | ProcessFormCreateOrConnectWithoutFormInput[]
    createMany?: ProcessFormCreateManyFormInputEnvelope
    connect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
  }

  export type EnumFormTypeFieldUpdateOperationsInput = {
    set?: $Enums.FormType
  }

  export type EnumFormStatusFieldUpdateOperationsInput = {
    set?: $Enums.FormStatus
  }

  export type FormResponseUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput> | FormResponseCreateWithoutFormInput[] | FormResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutFormInput | FormResponseCreateOrConnectWithoutFormInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutFormInput | FormResponseUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormResponseCreateManyFormInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutFormInput | FormResponseUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutFormInput | FormResponseUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedFormsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedFormsInput, UserUncheckedCreateWithoutCreatedFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFormsInput
    upsert?: UserUpsertWithoutCreatedFormsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedFormsInput, UserUpdateWithoutCreatedFormsInput>, UserUncheckedUpdateWithoutCreatedFormsInput>
  }

  export type FolderUpdateOneWithoutFormsNestedInput = {
    create?: XOR<FolderCreateWithoutFormsInput, FolderUncheckedCreateWithoutFormsInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFormsInput
    upsert?: FolderUpsertWithoutFormsInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutFormsInput, FolderUpdateWithoutFormsInput>, FolderUncheckedUpdateWithoutFormsInput>
  }

  export type ProcessFormUpdateManyWithoutFormNestedInput = {
    create?: XOR<ProcessFormCreateWithoutFormInput, ProcessFormUncheckedCreateWithoutFormInput> | ProcessFormCreateWithoutFormInput[] | ProcessFormUncheckedCreateWithoutFormInput[]
    connectOrCreate?: ProcessFormCreateOrConnectWithoutFormInput | ProcessFormCreateOrConnectWithoutFormInput[]
    upsert?: ProcessFormUpsertWithWhereUniqueWithoutFormInput | ProcessFormUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: ProcessFormCreateManyFormInputEnvelope
    set?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    disconnect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    delete?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    connect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    update?: ProcessFormUpdateWithWhereUniqueWithoutFormInput | ProcessFormUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: ProcessFormUpdateManyWithWhereWithoutFormInput | ProcessFormUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: ProcessFormScalarWhereInput | ProcessFormScalarWhereInput[]
  }

  export type FormResponseUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput> | FormResponseCreateWithoutFormInput[] | FormResponseUncheckedCreateWithoutFormInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutFormInput | FormResponseCreateOrConnectWithoutFormInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutFormInput | FormResponseUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: FormResponseCreateManyFormInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutFormInput | FormResponseUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutFormInput | FormResponseUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type ProcessFormUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<ProcessFormCreateWithoutFormInput, ProcessFormUncheckedCreateWithoutFormInput> | ProcessFormCreateWithoutFormInput[] | ProcessFormUncheckedCreateWithoutFormInput[]
    connectOrCreate?: ProcessFormCreateOrConnectWithoutFormInput | ProcessFormCreateOrConnectWithoutFormInput[]
    upsert?: ProcessFormUpsertWithWhereUniqueWithoutFormInput | ProcessFormUpsertWithWhereUniqueWithoutFormInput[]
    createMany?: ProcessFormCreateManyFormInputEnvelope
    set?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    disconnect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    delete?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    connect?: ProcessFormWhereUniqueInput | ProcessFormWhereUniqueInput[]
    update?: ProcessFormUpdateWithWhereUniqueWithoutFormInput | ProcessFormUpdateWithWhereUniqueWithoutFormInput[]
    updateMany?: ProcessFormUpdateManyWithWhereWithoutFormInput | ProcessFormUpdateManyWithWhereWithoutFormInput[]
    deleteMany?: ProcessFormScalarWhereInput | ProcessFormScalarWhereInput[]
  }

  export type ApplicantProcessCreateNestedOneWithoutResponsesInput = {
    create?: XOR<ApplicantProcessCreateWithoutResponsesInput, ApplicantProcessUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutResponsesInput
    connect?: ApplicantProcessWhereUniqueInput
  }

  export type FormCreateNestedOneWithoutResponsesInput = {
    create?: XOR<FormCreateWithoutResponsesInput, FormUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: FormCreateOrConnectWithoutResponsesInput
    connect?: FormWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutFormResponsesInput = {
    create?: XOR<ProcessCreateWithoutFormResponsesInput, ProcessUncheckedCreateWithoutFormResponsesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutFormResponsesInput
    connect?: ProcessWhereUniqueInput
  }

  export type ApplicantProcessUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<ApplicantProcessCreateWithoutResponsesInput, ApplicantProcessUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutResponsesInput
    upsert?: ApplicantProcessUpsertWithoutResponsesInput
    connect?: ApplicantProcessWhereUniqueInput
    update?: XOR<XOR<ApplicantProcessUpdateToOneWithWhereWithoutResponsesInput, ApplicantProcessUpdateWithoutResponsesInput>, ApplicantProcessUncheckedUpdateWithoutResponsesInput>
  }

  export type FormUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<FormCreateWithoutResponsesInput, FormUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: FormCreateOrConnectWithoutResponsesInput
    upsert?: FormUpsertWithoutResponsesInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutResponsesInput, FormUpdateWithoutResponsesInput>, FormUncheckedUpdateWithoutResponsesInput>
  }

  export type ProcessUpdateOneRequiredWithoutFormResponsesNestedInput = {
    create?: XOR<ProcessCreateWithoutFormResponsesInput, ProcessUncheckedCreateWithoutFormResponsesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutFormResponsesInput
    upsert?: ProcessUpsertWithoutFormResponsesInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutFormResponsesInput, ProcessUpdateWithoutFormResponsesInput>, ProcessUncheckedUpdateWithoutFormResponsesInput>
  }

  export type ProcessFormCreatenextStepRolesInput = {
    set: string[]
  }

  export type ProcessFormCreatenotificationRolesInput = {
    set: string[]
  }

  export type FormCreateNestedOneWithoutProcessFormsInput = {
    create?: XOR<FormCreateWithoutProcessFormsInput, FormUncheckedCreateWithoutProcessFormsInput>
    connectOrCreate?: FormCreateOrConnectWithoutProcessFormsInput
    connect?: FormWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutFormsInput = {
    create?: XOR<ProcessCreateWithoutFormsInput, ProcessUncheckedCreateWithoutFormsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutFormsInput
    connect?: ProcessWhereUniqueInput
  }

  export type EnumNextStepTypeFieldUpdateOperationsInput = {
    set?: $Enums.NextStepType
  }

  export type ProcessFormUpdatenextStepRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProcessFormUpdatenotificationRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FormUpdateOneRequiredWithoutProcessFormsNestedInput = {
    create?: XOR<FormCreateWithoutProcessFormsInput, FormUncheckedCreateWithoutProcessFormsInput>
    connectOrCreate?: FormCreateOrConnectWithoutProcessFormsInput
    upsert?: FormUpsertWithoutProcessFormsInput
    connect?: FormWhereUniqueInput
    update?: XOR<XOR<FormUpdateToOneWithWhereWithoutProcessFormsInput, FormUpdateWithoutProcessFormsInput>, FormUncheckedUpdateWithoutProcessFormsInput>
  }

  export type ProcessUpdateOneRequiredWithoutFormsNestedInput = {
    create?: XOR<ProcessCreateWithoutFormsInput, ProcessUncheckedCreateWithoutFormsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutFormsInput
    upsert?: ProcessUpsertWithoutFormsInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutFormsInput, ProcessUpdateWithoutFormsInput>, ProcessUncheckedUpdateWithoutFormsInput>
  }

  export type APCompletedFormCreateNestedManyWithoutApplicantProcessInput = {
    create?: XOR<APCompletedFormCreateWithoutApplicantProcessInput, APCompletedFormUncheckedCreateWithoutApplicantProcessInput> | APCompletedFormCreateWithoutApplicantProcessInput[] | APCompletedFormUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: APCompletedFormCreateOrConnectWithoutApplicantProcessInput | APCompletedFormCreateOrConnectWithoutApplicantProcessInput[]
    createMany?: APCompletedFormCreateManyApplicantProcessInputEnvelope
    connect?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutApplicantProcessesInput = {
    create?: XOR<UserCreateWithoutApplicantProcessesInput, UserUncheckedCreateWithoutApplicantProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicantProcessesInput
    connect?: UserWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutApplicantProcessesInput = {
    create?: XOR<ProcessCreateWithoutApplicantProcessesInput, ProcessUncheckedCreateWithoutApplicantProcessesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutApplicantProcessesInput
    connect?: ProcessWhereUniqueInput
  }

  export type ProcessedApplicationCreateNestedManyWithoutApplicantProcessInput = {
    create?: XOR<ProcessedApplicationCreateWithoutApplicantProcessInput, ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput> | ProcessedApplicationCreateWithoutApplicantProcessInput[] | ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput | ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput[]
    createMany?: ProcessedApplicationCreateManyApplicantProcessInputEnvelope
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
  }

  export type FormResponseCreateNestedManyWithoutApplicantProcessInput = {
    create?: XOR<FormResponseCreateWithoutApplicantProcessInput, FormResponseUncheckedCreateWithoutApplicantProcessInput> | FormResponseCreateWithoutApplicantProcessInput[] | FormResponseUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutApplicantProcessInput | FormResponseCreateOrConnectWithoutApplicantProcessInput[]
    createMany?: FormResponseCreateManyApplicantProcessInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type ProcessCommentCreateNestedManyWithoutApplicantProcessInput = {
    create?: XOR<ProcessCommentCreateWithoutApplicantProcessInput, ProcessCommentUncheckedCreateWithoutApplicantProcessInput> | ProcessCommentCreateWithoutApplicantProcessInput[] | ProcessCommentUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: ProcessCommentCreateOrConnectWithoutApplicantProcessInput | ProcessCommentCreateOrConnectWithoutApplicantProcessInput[]
    createMany?: ProcessCommentCreateManyApplicantProcessInputEnvelope
    connect?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
  }

  export type APCompletedFormUncheckedCreateNestedManyWithoutApplicantProcessInput = {
    create?: XOR<APCompletedFormCreateWithoutApplicantProcessInput, APCompletedFormUncheckedCreateWithoutApplicantProcessInput> | APCompletedFormCreateWithoutApplicantProcessInput[] | APCompletedFormUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: APCompletedFormCreateOrConnectWithoutApplicantProcessInput | APCompletedFormCreateOrConnectWithoutApplicantProcessInput[]
    createMany?: APCompletedFormCreateManyApplicantProcessInputEnvelope
    connect?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
  }

  export type ProcessedApplicationUncheckedCreateNestedManyWithoutApplicantProcessInput = {
    create?: XOR<ProcessedApplicationCreateWithoutApplicantProcessInput, ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput> | ProcessedApplicationCreateWithoutApplicantProcessInput[] | ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput | ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput[]
    createMany?: ProcessedApplicationCreateManyApplicantProcessInputEnvelope
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
  }

  export type FormResponseUncheckedCreateNestedManyWithoutApplicantProcessInput = {
    create?: XOR<FormResponseCreateWithoutApplicantProcessInput, FormResponseUncheckedCreateWithoutApplicantProcessInput> | FormResponseCreateWithoutApplicantProcessInput[] | FormResponseUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutApplicantProcessInput | FormResponseCreateOrConnectWithoutApplicantProcessInput[]
    createMany?: FormResponseCreateManyApplicantProcessInputEnvelope
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
  }

  export type ProcessCommentUncheckedCreateNestedManyWithoutApplicantProcessInput = {
    create?: XOR<ProcessCommentCreateWithoutApplicantProcessInput, ProcessCommentUncheckedCreateWithoutApplicantProcessInput> | ProcessCommentCreateWithoutApplicantProcessInput[] | ProcessCommentUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: ProcessCommentCreateOrConnectWithoutApplicantProcessInput | ProcessCommentCreateOrConnectWithoutApplicantProcessInput[]
    createMany?: ProcessCommentCreateManyApplicantProcessInputEnvelope
    connect?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
  }

  export type APCompletedFormUpdateManyWithoutApplicantProcessNestedInput = {
    create?: XOR<APCompletedFormCreateWithoutApplicantProcessInput, APCompletedFormUncheckedCreateWithoutApplicantProcessInput> | APCompletedFormCreateWithoutApplicantProcessInput[] | APCompletedFormUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: APCompletedFormCreateOrConnectWithoutApplicantProcessInput | APCompletedFormCreateOrConnectWithoutApplicantProcessInput[]
    upsert?: APCompletedFormUpsertWithWhereUniqueWithoutApplicantProcessInput | APCompletedFormUpsertWithWhereUniqueWithoutApplicantProcessInput[]
    createMany?: APCompletedFormCreateManyApplicantProcessInputEnvelope
    set?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
    disconnect?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
    delete?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
    connect?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
    update?: APCompletedFormUpdateWithWhereUniqueWithoutApplicantProcessInput | APCompletedFormUpdateWithWhereUniqueWithoutApplicantProcessInput[]
    updateMany?: APCompletedFormUpdateManyWithWhereWithoutApplicantProcessInput | APCompletedFormUpdateManyWithWhereWithoutApplicantProcessInput[]
    deleteMany?: APCompletedFormScalarWhereInput | APCompletedFormScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutApplicantProcessesNestedInput = {
    create?: XOR<UserCreateWithoutApplicantProcessesInput, UserUncheckedCreateWithoutApplicantProcessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicantProcessesInput
    upsert?: UserUpsertWithoutApplicantProcessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicantProcessesInput, UserUpdateWithoutApplicantProcessesInput>, UserUncheckedUpdateWithoutApplicantProcessesInput>
  }

  export type ProcessUpdateOneRequiredWithoutApplicantProcessesNestedInput = {
    create?: XOR<ProcessCreateWithoutApplicantProcessesInput, ProcessUncheckedCreateWithoutApplicantProcessesInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutApplicantProcessesInput
    upsert?: ProcessUpsertWithoutApplicantProcessesInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutApplicantProcessesInput, ProcessUpdateWithoutApplicantProcessesInput>, ProcessUncheckedUpdateWithoutApplicantProcessesInput>
  }

  export type ProcessedApplicationUpdateManyWithoutApplicantProcessNestedInput = {
    create?: XOR<ProcessedApplicationCreateWithoutApplicantProcessInput, ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput> | ProcessedApplicationCreateWithoutApplicantProcessInput[] | ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput | ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput[]
    upsert?: ProcessedApplicationUpsertWithWhereUniqueWithoutApplicantProcessInput | ProcessedApplicationUpsertWithWhereUniqueWithoutApplicantProcessInput[]
    createMany?: ProcessedApplicationCreateManyApplicantProcessInputEnvelope
    set?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    disconnect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    delete?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    update?: ProcessedApplicationUpdateWithWhereUniqueWithoutApplicantProcessInput | ProcessedApplicationUpdateWithWhereUniqueWithoutApplicantProcessInput[]
    updateMany?: ProcessedApplicationUpdateManyWithWhereWithoutApplicantProcessInput | ProcessedApplicationUpdateManyWithWhereWithoutApplicantProcessInput[]
    deleteMany?: ProcessedApplicationScalarWhereInput | ProcessedApplicationScalarWhereInput[]
  }

  export type FormResponseUpdateManyWithoutApplicantProcessNestedInput = {
    create?: XOR<FormResponseCreateWithoutApplicantProcessInput, FormResponseUncheckedCreateWithoutApplicantProcessInput> | FormResponseCreateWithoutApplicantProcessInput[] | FormResponseUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutApplicantProcessInput | FormResponseCreateOrConnectWithoutApplicantProcessInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutApplicantProcessInput | FormResponseUpsertWithWhereUniqueWithoutApplicantProcessInput[]
    createMany?: FormResponseCreateManyApplicantProcessInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutApplicantProcessInput | FormResponseUpdateWithWhereUniqueWithoutApplicantProcessInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutApplicantProcessInput | FormResponseUpdateManyWithWhereWithoutApplicantProcessInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type ProcessCommentUpdateManyWithoutApplicantProcessNestedInput = {
    create?: XOR<ProcessCommentCreateWithoutApplicantProcessInput, ProcessCommentUncheckedCreateWithoutApplicantProcessInput> | ProcessCommentCreateWithoutApplicantProcessInput[] | ProcessCommentUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: ProcessCommentCreateOrConnectWithoutApplicantProcessInput | ProcessCommentCreateOrConnectWithoutApplicantProcessInput[]
    upsert?: ProcessCommentUpsertWithWhereUniqueWithoutApplicantProcessInput | ProcessCommentUpsertWithWhereUniqueWithoutApplicantProcessInput[]
    createMany?: ProcessCommentCreateManyApplicantProcessInputEnvelope
    set?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
    disconnect?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
    delete?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
    connect?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
    update?: ProcessCommentUpdateWithWhereUniqueWithoutApplicantProcessInput | ProcessCommentUpdateWithWhereUniqueWithoutApplicantProcessInput[]
    updateMany?: ProcessCommentUpdateManyWithWhereWithoutApplicantProcessInput | ProcessCommentUpdateManyWithWhereWithoutApplicantProcessInput[]
    deleteMany?: ProcessCommentScalarWhereInput | ProcessCommentScalarWhereInput[]
  }

  export type APCompletedFormUncheckedUpdateManyWithoutApplicantProcessNestedInput = {
    create?: XOR<APCompletedFormCreateWithoutApplicantProcessInput, APCompletedFormUncheckedCreateWithoutApplicantProcessInput> | APCompletedFormCreateWithoutApplicantProcessInput[] | APCompletedFormUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: APCompletedFormCreateOrConnectWithoutApplicantProcessInput | APCompletedFormCreateOrConnectWithoutApplicantProcessInput[]
    upsert?: APCompletedFormUpsertWithWhereUniqueWithoutApplicantProcessInput | APCompletedFormUpsertWithWhereUniqueWithoutApplicantProcessInput[]
    createMany?: APCompletedFormCreateManyApplicantProcessInputEnvelope
    set?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
    disconnect?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
    delete?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
    connect?: APCompletedFormWhereUniqueInput | APCompletedFormWhereUniqueInput[]
    update?: APCompletedFormUpdateWithWhereUniqueWithoutApplicantProcessInput | APCompletedFormUpdateWithWhereUniqueWithoutApplicantProcessInput[]
    updateMany?: APCompletedFormUpdateManyWithWhereWithoutApplicantProcessInput | APCompletedFormUpdateManyWithWhereWithoutApplicantProcessInput[]
    deleteMany?: APCompletedFormScalarWhereInput | APCompletedFormScalarWhereInput[]
  }

  export type ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessNestedInput = {
    create?: XOR<ProcessedApplicationCreateWithoutApplicantProcessInput, ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput> | ProcessedApplicationCreateWithoutApplicantProcessInput[] | ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput | ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput[]
    upsert?: ProcessedApplicationUpsertWithWhereUniqueWithoutApplicantProcessInput | ProcessedApplicationUpsertWithWhereUniqueWithoutApplicantProcessInput[]
    createMany?: ProcessedApplicationCreateManyApplicantProcessInputEnvelope
    set?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    disconnect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    delete?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    connect?: ProcessedApplicationWhereUniqueInput | ProcessedApplicationWhereUniqueInput[]
    update?: ProcessedApplicationUpdateWithWhereUniqueWithoutApplicantProcessInput | ProcessedApplicationUpdateWithWhereUniqueWithoutApplicantProcessInput[]
    updateMany?: ProcessedApplicationUpdateManyWithWhereWithoutApplicantProcessInput | ProcessedApplicationUpdateManyWithWhereWithoutApplicantProcessInput[]
    deleteMany?: ProcessedApplicationScalarWhereInput | ProcessedApplicationScalarWhereInput[]
  }

  export type FormResponseUncheckedUpdateManyWithoutApplicantProcessNestedInput = {
    create?: XOR<FormResponseCreateWithoutApplicantProcessInput, FormResponseUncheckedCreateWithoutApplicantProcessInput> | FormResponseCreateWithoutApplicantProcessInput[] | FormResponseUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: FormResponseCreateOrConnectWithoutApplicantProcessInput | FormResponseCreateOrConnectWithoutApplicantProcessInput[]
    upsert?: FormResponseUpsertWithWhereUniqueWithoutApplicantProcessInput | FormResponseUpsertWithWhereUniqueWithoutApplicantProcessInput[]
    createMany?: FormResponseCreateManyApplicantProcessInputEnvelope
    set?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    disconnect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    delete?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    connect?: FormResponseWhereUniqueInput | FormResponseWhereUniqueInput[]
    update?: FormResponseUpdateWithWhereUniqueWithoutApplicantProcessInput | FormResponseUpdateWithWhereUniqueWithoutApplicantProcessInput[]
    updateMany?: FormResponseUpdateManyWithWhereWithoutApplicantProcessInput | FormResponseUpdateManyWithWhereWithoutApplicantProcessInput[]
    deleteMany?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
  }

  export type ProcessCommentUncheckedUpdateManyWithoutApplicantProcessNestedInput = {
    create?: XOR<ProcessCommentCreateWithoutApplicantProcessInput, ProcessCommentUncheckedCreateWithoutApplicantProcessInput> | ProcessCommentCreateWithoutApplicantProcessInput[] | ProcessCommentUncheckedCreateWithoutApplicantProcessInput[]
    connectOrCreate?: ProcessCommentCreateOrConnectWithoutApplicantProcessInput | ProcessCommentCreateOrConnectWithoutApplicantProcessInput[]
    upsert?: ProcessCommentUpsertWithWhereUniqueWithoutApplicantProcessInput | ProcessCommentUpsertWithWhereUniqueWithoutApplicantProcessInput[]
    createMany?: ProcessCommentCreateManyApplicantProcessInputEnvelope
    set?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
    disconnect?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
    delete?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
    connect?: ProcessCommentWhereUniqueInput | ProcessCommentWhereUniqueInput[]
    update?: ProcessCommentUpdateWithWhereUniqueWithoutApplicantProcessInput | ProcessCommentUpdateWithWhereUniqueWithoutApplicantProcessInput[]
    updateMany?: ProcessCommentUpdateManyWithWhereWithoutApplicantProcessInput | ProcessCommentUpdateManyWithWhereWithoutApplicantProcessInput[]
    deleteMany?: ProcessCommentScalarWhereInput | ProcessCommentScalarWhereInput[]
  }

  export type ProcessedApplicationCreateformRoleIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProcessedApplicationsInput = {
    create?: XOR<UserCreateWithoutProcessedApplicationsInput, UserUncheckedCreateWithoutProcessedApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProcessCreateNestedOneWithoutProcessedApplicationsInput = {
    create?: XOR<ProcessCreateWithoutProcessedApplicationsInput, ProcessUncheckedCreateWithoutProcessedApplicationsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutProcessedApplicationsInput
    connect?: ProcessWhereUniqueInput
  }

  export type ApplicantProcessCreateNestedOneWithoutProcessedApplicationsInput = {
    create?: XOR<ApplicantProcessCreateWithoutProcessedApplicationsInput, ApplicantProcessUncheckedCreateWithoutProcessedApplicationsInput>
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutProcessedApplicationsInput
    connect?: ApplicantProcessWhereUniqueInput
  }

  export type ProcessedApplicationUpdateformRoleIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProcessedApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutProcessedApplicationsInput, UserUncheckedCreateWithoutProcessedApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedApplicationsInput
    upsert?: UserUpsertWithoutProcessedApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessedApplicationsInput, UserUpdateWithoutProcessedApplicationsInput>, UserUncheckedUpdateWithoutProcessedApplicationsInput>
  }

  export type ProcessUpdateOneRequiredWithoutProcessedApplicationsNestedInput = {
    create?: XOR<ProcessCreateWithoutProcessedApplicationsInput, ProcessUncheckedCreateWithoutProcessedApplicationsInput>
    connectOrCreate?: ProcessCreateOrConnectWithoutProcessedApplicationsInput
    upsert?: ProcessUpsertWithoutProcessedApplicationsInput
    connect?: ProcessWhereUniqueInput
    update?: XOR<XOR<ProcessUpdateToOneWithWhereWithoutProcessedApplicationsInput, ProcessUpdateWithoutProcessedApplicationsInput>, ProcessUncheckedUpdateWithoutProcessedApplicationsInput>
  }

  export type ApplicantProcessUpdateOneRequiredWithoutProcessedApplicationsNestedInput = {
    create?: XOR<ApplicantProcessCreateWithoutProcessedApplicationsInput, ApplicantProcessUncheckedCreateWithoutProcessedApplicationsInput>
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutProcessedApplicationsInput
    upsert?: ApplicantProcessUpsertWithoutProcessedApplicationsInput
    connect?: ApplicantProcessWhereUniqueInput
    update?: XOR<XOR<ApplicantProcessUpdateToOneWithWhereWithoutProcessedApplicationsInput, ApplicantProcessUpdateWithoutProcessedApplicationsInput>, ApplicantProcessUncheckedUpdateWithoutProcessedApplicationsInput>
  }

  export type APCompletedFormCreatenextStepRolesInput = {
    set: string[]
  }

  export type APCompletedFormCreatenotificationToRolesInput = {
    set: string[]
  }

  export type ApplicantProcessCreateNestedOneWithoutCompletedFormsInput = {
    create?: XOR<ApplicantProcessCreateWithoutCompletedFormsInput, ApplicantProcessUncheckedCreateWithoutCompletedFormsInput>
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutCompletedFormsInput
    connect?: ApplicantProcessWhereUniqueInput
  }

  export type APCompletedFormUpdatenextStepRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type APCompletedFormUpdatenotificationToRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ApplicantProcessUpdateOneRequiredWithoutCompletedFormsNestedInput = {
    create?: XOR<ApplicantProcessCreateWithoutCompletedFormsInput, ApplicantProcessUncheckedCreateWithoutCompletedFormsInput>
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutCompletedFormsInput
    upsert?: ApplicantProcessUpsertWithoutCompletedFormsInput
    connect?: ApplicantProcessWhereUniqueInput
    update?: XOR<XOR<ApplicantProcessUpdateToOneWithWhereWithoutCompletedFormsInput, ApplicantProcessUpdateWithoutCompletedFormsInput>, ApplicantProcessUncheckedUpdateWithoutCompletedFormsInput>
  }

  export type ApplicantProcessCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ApplicantProcessCreateWithoutCommentsInput, ApplicantProcessUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutCommentsInput
    connect?: ApplicantProcessWhereUniqueInput
  }

  export type ApplicantProcessUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ApplicantProcessCreateWithoutCommentsInput, ApplicantProcessUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ApplicantProcessCreateOrConnectWithoutCommentsInput
    upsert?: ApplicantProcessUpsertWithoutCommentsInput
    connect?: ApplicantProcessWhereUniqueInput
    update?: XOR<XOR<ApplicantProcessUpdateToOneWithWhereWithoutCommentsInput, ApplicantProcessUpdateWithoutCommentsInput>, ApplicantProcessUncheckedUpdateWithoutCommentsInput>
  }

  export type OrganizationUserCreateNestedOneWithoutSubordinatesInput = {
    create?: XOR<OrganizationUserCreateWithoutSubordinatesInput, OrganizationUserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutSubordinatesInput
    connect?: OrganizationUserWhereUniqueInput
  }

  export type OrganizationUserCreateNestedManyWithoutSuperiorInput = {
    create?: XOR<OrganizationUserCreateWithoutSuperiorInput, OrganizationUserUncheckedCreateWithoutSuperiorInput> | OrganizationUserCreateWithoutSuperiorInput[] | OrganizationUserUncheckedCreateWithoutSuperiorInput[]
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutSuperiorInput | OrganizationUserCreateOrConnectWithoutSuperiorInput[]
    createMany?: OrganizationUserCreateManySuperiorInputEnvelope
    connect?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUserUncheckedCreateNestedManyWithoutSuperiorInput = {
    create?: XOR<OrganizationUserCreateWithoutSuperiorInput, OrganizationUserUncheckedCreateWithoutSuperiorInput> | OrganizationUserCreateWithoutSuperiorInput[] | OrganizationUserUncheckedCreateWithoutSuperiorInput[]
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutSuperiorInput | OrganizationUserCreateOrConnectWithoutSuperiorInput[]
    createMany?: OrganizationUserCreateManySuperiorInputEnvelope
    connect?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
  }

  export type OrganizationUserUpdateOneWithoutSubordinatesNestedInput = {
    create?: XOR<OrganizationUserCreateWithoutSubordinatesInput, OrganizationUserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutSubordinatesInput
    upsert?: OrganizationUserUpsertWithoutSubordinatesInput
    disconnect?: OrganizationUserWhereInput | boolean
    delete?: OrganizationUserWhereInput | boolean
    connect?: OrganizationUserWhereUniqueInput
    update?: XOR<XOR<OrganizationUserUpdateToOneWithWhereWithoutSubordinatesInput, OrganizationUserUpdateWithoutSubordinatesInput>, OrganizationUserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type OrganizationUserUpdateManyWithoutSuperiorNestedInput = {
    create?: XOR<OrganizationUserCreateWithoutSuperiorInput, OrganizationUserUncheckedCreateWithoutSuperiorInput> | OrganizationUserCreateWithoutSuperiorInput[] | OrganizationUserUncheckedCreateWithoutSuperiorInput[]
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutSuperiorInput | OrganizationUserCreateOrConnectWithoutSuperiorInput[]
    upsert?: OrganizationUserUpsertWithWhereUniqueWithoutSuperiorInput | OrganizationUserUpsertWithWhereUniqueWithoutSuperiorInput[]
    createMany?: OrganizationUserCreateManySuperiorInputEnvelope
    set?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
    disconnect?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
    delete?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
    connect?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
    update?: OrganizationUserUpdateWithWhereUniqueWithoutSuperiorInput | OrganizationUserUpdateWithWhereUniqueWithoutSuperiorInput[]
    updateMany?: OrganizationUserUpdateManyWithWhereWithoutSuperiorInput | OrganizationUserUpdateManyWithWhereWithoutSuperiorInput[]
    deleteMany?: OrganizationUserScalarWhereInput | OrganizationUserScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput
    upsert?: UserUpsertWithoutOrganizationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationInput, UserUpdateWithoutOrganizationInput>, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationUserUncheckedUpdateManyWithoutSuperiorNestedInput = {
    create?: XOR<OrganizationUserCreateWithoutSuperiorInput, OrganizationUserUncheckedCreateWithoutSuperiorInput> | OrganizationUserCreateWithoutSuperiorInput[] | OrganizationUserUncheckedCreateWithoutSuperiorInput[]
    connectOrCreate?: OrganizationUserCreateOrConnectWithoutSuperiorInput | OrganizationUserCreateOrConnectWithoutSuperiorInput[]
    upsert?: OrganizationUserUpsertWithWhereUniqueWithoutSuperiorInput | OrganizationUserUpsertWithWhereUniqueWithoutSuperiorInput[]
    createMany?: OrganizationUserCreateManySuperiorInputEnvelope
    set?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
    disconnect?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
    delete?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
    connect?: OrganizationUserWhereUniqueInput | OrganizationUserWhereUniqueInput[]
    update?: OrganizationUserUpdateWithWhereUniqueWithoutSuperiorInput | OrganizationUserUpdateWithWhereUniqueWithoutSuperiorInput[]
    updateMany?: OrganizationUserUpdateManyWithWhereWithoutSuperiorInput | OrganizationUserUpdateManyWithWhereWithoutSuperiorInput[]
    deleteMany?: OrganizationUserScalarWhereInput | OrganizationUserScalarWhereInput[]
  }

  export type DashboardCreateallowedUsersInput = {
    set: string[]
  }

  export type DashboardCreateallowedRolesInput = {
    set: string[]
  }

  export type WidgetCreateNestedManyWithoutDashboardInput = {
    create?: XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput> | WidgetCreateWithoutDashboardInput[] | WidgetUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: WidgetCreateOrConnectWithoutDashboardInput | WidgetCreateOrConnectWithoutDashboardInput[]
    createMany?: WidgetCreateManyDashboardInputEnvelope
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
  }

  export type WidgetUncheckedCreateNestedManyWithoutDashboardInput = {
    create?: XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput> | WidgetCreateWithoutDashboardInput[] | WidgetUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: WidgetCreateOrConnectWithoutDashboardInput | WidgetCreateOrConnectWithoutDashboardInput[]
    createMany?: WidgetCreateManyDashboardInputEnvelope
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
  }

  export type DashboardUpdateallowedUsersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DashboardUpdateallowedRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WidgetUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput> | WidgetCreateWithoutDashboardInput[] | WidgetUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: WidgetCreateOrConnectWithoutDashboardInput | WidgetCreateOrConnectWithoutDashboardInput[]
    upsert?: WidgetUpsertWithWhereUniqueWithoutDashboardInput | WidgetUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: WidgetCreateManyDashboardInputEnvelope
    set?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
    disconnect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
    delete?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
    update?: WidgetUpdateWithWhereUniqueWithoutDashboardInput | WidgetUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: WidgetUpdateManyWithWhereWithoutDashboardInput | WidgetUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: WidgetScalarWhereInput | WidgetScalarWhereInput[]
  }

  export type WidgetUncheckedUpdateManyWithoutDashboardNestedInput = {
    create?: XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput> | WidgetCreateWithoutDashboardInput[] | WidgetUncheckedCreateWithoutDashboardInput[]
    connectOrCreate?: WidgetCreateOrConnectWithoutDashboardInput | WidgetCreateOrConnectWithoutDashboardInput[]
    upsert?: WidgetUpsertWithWhereUniqueWithoutDashboardInput | WidgetUpsertWithWhereUniqueWithoutDashboardInput[]
    createMany?: WidgetCreateManyDashboardInputEnvelope
    set?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
    disconnect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
    delete?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[]
    update?: WidgetUpdateWithWhereUniqueWithoutDashboardInput | WidgetUpdateWithWhereUniqueWithoutDashboardInput[]
    updateMany?: WidgetUpdateManyWithWhereWithoutDashboardInput | WidgetUpdateManyWithWhereWithoutDashboardInput[]
    deleteMany?: WidgetScalarWhereInput | WidgetScalarWhereInput[]
  }

  export type DashboardCreateNestedOneWithoutWidgetsInput = {
    create?: XOR<DashboardCreateWithoutWidgetsInput, DashboardUncheckedCreateWithoutWidgetsInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutWidgetsInput
    connect?: DashboardWhereUniqueInput
  }

  export type DashboardUpdateOneRequiredWithoutWidgetsNestedInput = {
    create?: XOR<DashboardCreateWithoutWidgetsInput, DashboardUncheckedCreateWithoutWidgetsInput>
    connectOrCreate?: DashboardCreateOrConnectWithoutWidgetsInput
    upsert?: DashboardUpsertWithoutWidgetsInput
    connect?: DashboardWhereUniqueInput
    update?: XOR<XOR<DashboardUpdateToOneWithWhereWithoutWidgetsInput, DashboardUpdateWithoutWidgetsInput>, DashboardUncheckedUpdateWithoutWidgetsInput>
  }

  export type UserCreateNestedOneWithoutQrCodeDocumentsInput = {
    create?: XOR<UserCreateWithoutQrCodeDocumentsInput, UserUncheckedCreateWithoutQrCodeDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQrCodeDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutQrCodeDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutQrCodeDocumentsInput, UserUncheckedCreateWithoutQrCodeDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQrCodeDocumentsInput
    upsert?: UserUpsertWithoutQrCodeDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQrCodeDocumentsInput, UserUpdateWithoutQrCodeDocumentsInput>, UserUncheckedUpdateWithoutQrCodeDocumentsInput>
  }

  export type EnumManagementTypeFieldUpdateOperationsInput = {
    set?: $Enums.ManagementType
  }

  export type EnumAddToDatabaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.AddToDatabaseStatus
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type VoteCreateNestedManyWithoutMessageInput = {
    create?: XOR<VoteCreateWithoutMessageInput, VoteUncheckedCreateWithoutMessageInput> | VoteCreateWithoutMessageInput[] | VoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutMessageInput | VoteCreateOrConnectWithoutMessageInput[]
    createMany?: VoteCreateManyMessageInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<VoteCreateWithoutMessageInput, VoteUncheckedCreateWithoutMessageInput> | VoteCreateWithoutMessageInput[] | VoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutMessageInput | VoteCreateOrConnectWithoutMessageInput[]
    createMany?: VoteCreateManyMessageInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type VoteUpdateManyWithoutMessageNestedInput = {
    create?: XOR<VoteCreateWithoutMessageInput, VoteUncheckedCreateWithoutMessageInput> | VoteCreateWithoutMessageInput[] | VoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutMessageInput | VoteCreateOrConnectWithoutMessageInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutMessageInput | VoteUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: VoteCreateManyMessageInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutMessageInput | VoteUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutMessageInput | VoteUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<VoteCreateWithoutMessageInput, VoteUncheckedCreateWithoutMessageInput> | VoteCreateWithoutMessageInput[] | VoteUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutMessageInput | VoteCreateOrConnectWithoutMessageInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutMessageInput | VoteUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: VoteCreateManyMessageInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutMessageInput | VoteUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutMessageInput | VoteUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutVotesInput = {
    create?: XOR<MessageCreateWithoutVotesInput, MessageUncheckedCreateWithoutVotesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutVotesInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<MessageCreateWithoutVotesInput, MessageUncheckedCreateWithoutVotesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutVotesInput
    upsert?: MessageUpsertWithoutVotesInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutVotesInput, MessageUpdateWithoutVotesInput>, MessageUncheckedUpdateWithoutVotesInput>
  }

  export type SuggestionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SuggestionCreateWithoutDocumentInput, SuggestionUncheckedCreateWithoutDocumentInput> | SuggestionCreateWithoutDocumentInput[] | SuggestionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SuggestionCreateOrConnectWithoutDocumentInput | SuggestionCreateOrConnectWithoutDocumentInput[]
    createMany?: SuggestionCreateManyDocumentInputEnvelope
    connect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
  }

  export type SuggestionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<SuggestionCreateWithoutDocumentInput, SuggestionUncheckedCreateWithoutDocumentInput> | SuggestionCreateWithoutDocumentInput[] | SuggestionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SuggestionCreateOrConnectWithoutDocumentInput | SuggestionCreateOrConnectWithoutDocumentInput[]
    createMany?: SuggestionCreateManyDocumentInputEnvelope
    connect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
  }

  export type SuggestionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SuggestionCreateWithoutDocumentInput, SuggestionUncheckedCreateWithoutDocumentInput> | SuggestionCreateWithoutDocumentInput[] | SuggestionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SuggestionCreateOrConnectWithoutDocumentInput | SuggestionCreateOrConnectWithoutDocumentInput[]
    upsert?: SuggestionUpsertWithWhereUniqueWithoutDocumentInput | SuggestionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SuggestionCreateManyDocumentInputEnvelope
    set?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    disconnect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    delete?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    connect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    update?: SuggestionUpdateWithWhereUniqueWithoutDocumentInput | SuggestionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SuggestionUpdateManyWithWhereWithoutDocumentInput | SuggestionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SuggestionScalarWhereInput | SuggestionScalarWhereInput[]
  }

  export type SuggestionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<SuggestionCreateWithoutDocumentInput, SuggestionUncheckedCreateWithoutDocumentInput> | SuggestionCreateWithoutDocumentInput[] | SuggestionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: SuggestionCreateOrConnectWithoutDocumentInput | SuggestionCreateOrConnectWithoutDocumentInput[]
    upsert?: SuggestionUpsertWithWhereUniqueWithoutDocumentInput | SuggestionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: SuggestionCreateManyDocumentInputEnvelope
    set?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    disconnect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    delete?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    connect?: SuggestionWhereUniqueInput | SuggestionWhereUniqueInput[]
    update?: SuggestionUpdateWithWhereUniqueWithoutDocumentInput | SuggestionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: SuggestionUpdateManyWithWhereWithoutDocumentInput | SuggestionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: SuggestionScalarWhereInput | SuggestionScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutSuggestionsInput = {
    create?: XOR<DocumentCreateWithoutSuggestionsInput, DocumentUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSuggestionsInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutSuggestionsNestedInput = {
    create?: XOR<DocumentCreateWithoutSuggestionsInput, DocumentUncheckedCreateWithoutSuggestionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutSuggestionsInput
    upsert?: DocumentUpsertWithoutSuggestionsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutSuggestionsInput, DocumentUpdateWithoutSuggestionsInput>, DocumentUncheckedUpdateWithoutSuggestionsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleStatus | EnumRoleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleStatus[] | ListEnumRoleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleStatus[] | ListEnumRoleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleStatusFilter<$PrismaModel> | $Enums.RoleStatus
  }

  export type NestedEnumRoleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleStatus | EnumRoleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleStatus[] | ListEnumRoleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleStatus[] | ListEnumRoleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleStatusFilter<$PrismaModel>
    _max?: NestedEnumRoleStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumGroupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupStatus | EnumGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupStatusFilter<$PrismaModel> | $Enums.GroupStatus
  }

  export type NestedEnumGroupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupStatus | EnumGroupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupStatus[] | ListEnumGroupStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupStatusWithAggregatesFilter<$PrismaModel> | $Enums.GroupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupStatusFilter<$PrismaModel>
    _max?: NestedEnumGroupStatusFilter<$PrismaModel>
  }

  export type NestedEnumProcessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessType | EnumProcessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessTypeFilter<$PrismaModel> | $Enums.ProcessType
  }

  export type NestedEnumProcessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusFilter<$PrismaModel> | $Enums.ProcessStatus
  }

  export type NestedEnumProcessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessType | EnumProcessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessType[] | ListEnumProcessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProcessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessTypeFilter<$PrismaModel>
    _max?: NestedEnumProcessTypeFilter<$PrismaModel>
  }

  export type NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessStatus | EnumProcessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessStatus[] | ListEnumProcessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessStatusFilter<$PrismaModel>
  }

  export type NestedEnumFormTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FormType | EnumFormTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTypeFilter<$PrismaModel> | $Enums.FormType
  }

  export type NestedEnumFormStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FormStatus | EnumFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormStatusFilter<$PrismaModel> | $Enums.FormStatus
  }

  export type NestedEnumFormTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormType | EnumFormTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormType[] | ListEnumFormTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTypeWithAggregatesFilter<$PrismaModel> | $Enums.FormType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormTypeFilter<$PrismaModel>
    _max?: NestedEnumFormTypeFilter<$PrismaModel>
  }

  export type NestedEnumFormStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormStatus | EnumFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormStatusWithAggregatesFilter<$PrismaModel> | $Enums.FormStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormStatusFilter<$PrismaModel>
    _max?: NestedEnumFormStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNextStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NextStepType | EnumNextStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NextStepType[] | ListEnumNextStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NextStepType[] | ListEnumNextStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNextStepTypeFilter<$PrismaModel> | $Enums.NextStepType
  }

  export type NestedEnumNextStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NextStepType | EnumNextStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NextStepType[] | ListEnumNextStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NextStepType[] | ListEnumNextStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNextStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.NextStepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNextStepTypeFilter<$PrismaModel>
    _max?: NestedEnumNextStepTypeFilter<$PrismaModel>
  }

  export type NestedEnumManagementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ManagementType | EnumManagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ManagementType[] | ListEnumManagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ManagementType[] | ListEnumManagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumManagementTypeFilter<$PrismaModel> | $Enums.ManagementType
  }

  export type NestedEnumManagementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ManagementType | EnumManagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ManagementType[] | ListEnumManagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ManagementType[] | ListEnumManagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumManagementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ManagementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumManagementTypeFilter<$PrismaModel>
    _max?: NestedEnumManagementTypeFilter<$PrismaModel>
  }

  export type NestedEnumAddToDatabaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AddToDatabaseStatus | EnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AddToDatabaseStatus[] | ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddToDatabaseStatus[] | ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAddToDatabaseStatusFilter<$PrismaModel> | $Enums.AddToDatabaseStatus
  }

  export type NestedEnumAddToDatabaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddToDatabaseStatus | EnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AddToDatabaseStatus[] | ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddToDatabaseStatus[] | ListEnumAddToDatabaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAddToDatabaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.AddToDatabaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddToDatabaseStatusFilter<$PrismaModel>
    _max?: NestedEnumAddToDatabaseStatusFilter<$PrismaModel>
  }

  export type ApplicantProcessCreateWithoutApplicantInput = {
    id?: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormCreateNestedManyWithoutApplicantProcessInput
    process: ProcessCreateNestedOneWithoutApplicantProcessesInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessUncheckedCreateWithoutApplicantInput = {
    id?: string
    processId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormUncheckedCreateNestedManyWithoutApplicantProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseUncheckedCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentUncheckedCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessCreateOrConnectWithoutApplicantInput = {
    where: ApplicantProcessWhereUniqueInput
    create: XOR<ApplicantProcessCreateWithoutApplicantInput, ApplicantProcessUncheckedCreateWithoutApplicantInput>
  }

  export type ApplicantProcessCreateManyApplicantInputEnvelope = {
    data: ApplicantProcessCreateManyApplicantInput | ApplicantProcessCreateManyApplicantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status: string
    errorMessage?: string | null
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    timestamp?: Date | string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status: string
    errorMessage?: string | null
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutUserInput = {
    id?: string
    fileUrl: string
    thumbnailUrl?: string | null
    size: number
    isPrivate?: boolean
    title: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUncheckedCreateWithoutUserInput = {
    id?: string
    fileUrl: string
    thumbnailUrl?: string | null
    size: number
    isPrivate?: boolean
    title: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateOrConnectWithoutUserInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput>
  }

  export type FileCreateManyUserInputEnvelope = {
    data: FileCreateManyUserInput | FileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FormCreateWithoutCreatorInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseCreateNestedManyWithoutFormInput
    folder?: FolderCreateNestedOneWithoutFormsInput
    processForms?: ProcessFormCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    folderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUncheckedCreateNestedManyWithoutFormInput
    processForms?: ProcessFormUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutCreatorInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutCreatorInput, FormUncheckedCreateWithoutCreatorInput>
  }

  export type FormCreateManyCreatorInputEnvelope = {
    data: FormCreateManyCreatorInput | FormCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type FolderCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    forms?: FormCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    forms?: FormUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutCreatorInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutCreatorInput, FolderUncheckedCreateWithoutCreatorInput>
  }

  export type FolderCreateManyCreatorInputEnvelope = {
    data: FolderCreateManyCreatorInput | FolderCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutCreatorInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: GroupRoleCreateNestedManyWithoutGroupInput
    processes?: ProcessCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: GroupRoleUncheckedCreateNestedManyWithoutGroupInput
    processes?: ProcessUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput>
  }

  export type GroupCreateManyCreatorInputEnvelope = {
    data: GroupCreateManyCreatorInput | GroupCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUserCreateWithoutUserInput = {
    id?: string
    title: string
    superior?: OrganizationUserCreateNestedOneWithoutSubordinatesInput
    subordinates?: OrganizationUserCreateNestedManyWithoutSuperiorInput
  }

  export type OrganizationUserUncheckedCreateWithoutUserInput = {
    id?: string
    superiorId?: string | null
    title: string
    subordinates?: OrganizationUserUncheckedCreateNestedManyWithoutSuperiorInput
  }

  export type OrganizationUserCreateOrConnectWithoutUserInput = {
    where: OrganizationUserWhereUniqueInput
    create: XOR<OrganizationUserCreateWithoutUserInput, OrganizationUserUncheckedCreateWithoutUserInput>
  }

  export type ProcessCreateWithoutCreatorInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseCreateNestedManyWithoutProcessInput
    forms?: ProcessFormCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleCreateNestedManyWithoutProcessInput
    group: GroupCreateNestedOneWithoutProcessesInput
  }

  export type ProcessUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutProcessInput
    forms?: ProcessFormUncheckedCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutCreatorInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutCreatorInput, ProcessUncheckedCreateWithoutCreatorInput>
  }

  export type ProcessCreateManyCreatorInputEnvelope = {
    data: ProcessCreateManyCreatorInput | ProcessCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProcessedApplicationCreateWithoutUserInput = {
    id?: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutProcessedApplicationsInput
    applicantProcess: ApplicantProcessCreateNestedOneWithoutProcessedApplicationsInput
  }

  export type ProcessedApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    processId: string
    applicantProcessId: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessedApplicationCreateOrConnectWithoutUserInput = {
    where: ProcessedApplicationWhereUniqueInput
    create: XOR<ProcessedApplicationCreateWithoutUserInput, ProcessedApplicationUncheckedCreateWithoutUserInput>
  }

  export type ProcessedApplicationCreateManyUserInputEnvelope = {
    data: ProcessedApplicationCreateManyUserInput | ProcessedApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QrCodeDocumentCreateWithoutCreatorInput = {
    id?: string
    documentName: string
    fileName: string
    qrCodeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QrCodeDocumentUncheckedCreateWithoutCreatorInput = {
    id?: string
    documentName: string
    fileName: string
    qrCodeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QrCodeDocumentCreateOrConnectWithoutCreatorInput = {
    where: QrCodeDocumentWhereUniqueInput
    create: XOR<QrCodeDocumentCreateWithoutCreatorInput, QrCodeDocumentUncheckedCreateWithoutCreatorInput>
  }

  export type QrCodeDocumentCreateManyCreatorInputEnvelope = {
    data: QrCodeDocumentCreateManyCreatorInput | QrCodeDocumentCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    status?: $Enums.RoleStatus
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApplicantProcessUpsertWithWhereUniqueWithoutApplicantInput = {
    where: ApplicantProcessWhereUniqueInput
    update: XOR<ApplicantProcessUpdateWithoutApplicantInput, ApplicantProcessUncheckedUpdateWithoutApplicantInput>
    create: XOR<ApplicantProcessCreateWithoutApplicantInput, ApplicantProcessUncheckedCreateWithoutApplicantInput>
  }

  export type ApplicantProcessUpdateWithWhereUniqueWithoutApplicantInput = {
    where: ApplicantProcessWhereUniqueInput
    data: XOR<ApplicantProcessUpdateWithoutApplicantInput, ApplicantProcessUncheckedUpdateWithoutApplicantInput>
  }

  export type ApplicantProcessUpdateManyWithWhereWithoutApplicantInput = {
    where: ApplicantProcessScalarWhereInput
    data: XOR<ApplicantProcessUpdateManyMutationInput, ApplicantProcessUncheckedUpdateManyWithoutApplicantInput>
  }

  export type ApplicantProcessScalarWhereInput = {
    AND?: ApplicantProcessScalarWhereInput | ApplicantProcessScalarWhereInput[]
    OR?: ApplicantProcessScalarWhereInput[]
    NOT?: ApplicantProcessScalarWhereInput | ApplicantProcessScalarWhereInput[]
    id?: UuidFilter<"ApplicantProcess"> | string
    applicantId?: UuidFilter<"ApplicantProcess"> | string
    processId?: UuidFilter<"ApplicantProcess"> | string
    status?: EnumProcessStatusFilter<"ApplicantProcess"> | $Enums.ProcessStatus
    createdAt?: DateTimeFilter<"ApplicantProcess"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringNullableFilter<"AuditLog"> | string | null
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    status?: StringFilter<"AuditLog"> | string
    errorMessage?: StringNullableFilter<"AuditLog"> | string | null
  }

  export type FileUpsertWithWhereUniqueWithoutUserInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUserInput, FileUncheckedUpdateWithoutUserInput>
    create: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUserInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUserInput, FileUncheckedUpdateWithoutUserInput>
  }

  export type FileUpdateManyWithWhereWithoutUserInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUserInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: UuidFilter<"File"> | string
    fileUrl?: StringFilter<"File"> | string
    thumbnailUrl?: StringNullableFilter<"File"> | string | null
    size?: IntFilter<"File"> | number
    isPrivate?: BoolFilter<"File"> | boolean
    title?: StringFilter<"File"> | string
    userId?: UuidFilter<"File"> | string
    fileType?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
  }

  export type FormUpsertWithWhereUniqueWithoutCreatorInput = {
    where: FormWhereUniqueInput
    update: XOR<FormUpdateWithoutCreatorInput, FormUncheckedUpdateWithoutCreatorInput>
    create: XOR<FormCreateWithoutCreatorInput, FormUncheckedCreateWithoutCreatorInput>
  }

  export type FormUpdateWithWhereUniqueWithoutCreatorInput = {
    where: FormWhereUniqueInput
    data: XOR<FormUpdateWithoutCreatorInput, FormUncheckedUpdateWithoutCreatorInput>
  }

  export type FormUpdateManyWithWhereWithoutCreatorInput = {
    where: FormScalarWhereInput
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyWithoutCreatorInput>
  }

  export type FormScalarWhereInput = {
    AND?: FormScalarWhereInput | FormScalarWhereInput[]
    OR?: FormScalarWhereInput[]
    NOT?: FormScalarWhereInput | FormScalarWhereInput[]
    id?: UuidFilter<"Form"> | string
    name?: StringFilter<"Form"> | string
    type?: EnumFormTypeFilter<"Form"> | $Enums.FormType
    status?: EnumFormStatusFilter<"Form"> | $Enums.FormStatus
    archived?: BoolFilter<"Form"> | boolean
    creatorId?: UuidFilter<"Form"> | string
    folderId?: UuidNullableFilter<"Form"> | string | null
    createdAt?: DateTimeFilter<"Form"> | Date | string
    updatedAt?: DateTimeFilter<"Form"> | Date | string
    design?: JsonNullableFilter<"Form">
  }

  export type FolderUpsertWithWhereUniqueWithoutCreatorInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutCreatorInput, FolderUncheckedUpdateWithoutCreatorInput>
    create: XOR<FolderCreateWithoutCreatorInput, FolderUncheckedCreateWithoutCreatorInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutCreatorInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutCreatorInput, FolderUncheckedUpdateWithoutCreatorInput>
  }

  export type FolderUpdateManyWithWhereWithoutCreatorInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutCreatorInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[]
    OR?: FolderScalarWhereInput[]
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[]
    id?: UuidFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    description?: StringNullableFilter<"Folder"> | string | null
    creatorId?: UuidFilter<"Folder"> | string
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutCreatorInput, GroupUncheckedUpdateWithoutCreatorInput>
    create: XOR<GroupCreateWithoutCreatorInput, GroupUncheckedCreateWithoutCreatorInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutCreatorInput, GroupUncheckedUpdateWithoutCreatorInput>
  }

  export type GroupUpdateManyWithWhereWithoutCreatorInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutCreatorInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: UuidFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    status?: EnumGroupStatusFilter<"Group"> | $Enums.GroupStatus
    creatorId?: UuidFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type OrganizationUserUpsertWithoutUserInput = {
    update: XOR<OrganizationUserUpdateWithoutUserInput, OrganizationUserUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationUserCreateWithoutUserInput, OrganizationUserUncheckedCreateWithoutUserInput>
    where?: OrganizationUserWhereInput
  }

  export type OrganizationUserUpdateToOneWithWhereWithoutUserInput = {
    where?: OrganizationUserWhereInput
    data: XOR<OrganizationUserUpdateWithoutUserInput, OrganizationUserUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    superior?: OrganizationUserUpdateOneWithoutSubordinatesNestedInput
    subordinates?: OrganizationUserUpdateManyWithoutSuperiorNestedInput
  }

  export type OrganizationUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    superiorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    subordinates?: OrganizationUserUncheckedUpdateManyWithoutSuperiorNestedInput
  }

  export type ProcessUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutCreatorInput, ProcessUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProcessCreateWithoutCreatorInput, ProcessUncheckedCreateWithoutCreatorInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutCreatorInput, ProcessUncheckedUpdateWithoutCreatorInput>
  }

  export type ProcessUpdateManyWithWhereWithoutCreatorInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProcessScalarWhereInput = {
    AND?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    OR?: ProcessScalarWhereInput[]
    NOT?: ProcessScalarWhereInput | ProcessScalarWhereInput[]
    id?: UuidFilter<"Process"> | string
    name?: StringFilter<"Process"> | string
    type?: EnumProcessTypeFilter<"Process"> | $Enums.ProcessType
    groupId?: UuidFilter<"Process"> | string
    creatorId?: UuidFilter<"Process"> | string
    status?: EnumProcessStatusFilter<"Process"> | $Enums.ProcessStatus
    archived?: BoolFilter<"Process"> | boolean
    staffViewForms?: BoolFilter<"Process"> | boolean
    applicantViewProcessLevel?: BoolFilter<"Process"> | boolean
    createdAt?: DateTimeFilter<"Process"> | Date | string
    updatedAt?: DateTimeFilter<"Process"> | Date | string
  }

  export type ProcessedApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: ProcessedApplicationWhereUniqueInput
    update: XOR<ProcessedApplicationUpdateWithoutUserInput, ProcessedApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<ProcessedApplicationCreateWithoutUserInput, ProcessedApplicationUncheckedCreateWithoutUserInput>
  }

  export type ProcessedApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: ProcessedApplicationWhereUniqueInput
    data: XOR<ProcessedApplicationUpdateWithoutUserInput, ProcessedApplicationUncheckedUpdateWithoutUserInput>
  }

  export type ProcessedApplicationUpdateManyWithWhereWithoutUserInput = {
    where: ProcessedApplicationScalarWhereInput
    data: XOR<ProcessedApplicationUpdateManyMutationInput, ProcessedApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type ProcessedApplicationScalarWhereInput = {
    AND?: ProcessedApplicationScalarWhereInput | ProcessedApplicationScalarWhereInput[]
    OR?: ProcessedApplicationScalarWhereInput[]
    NOT?: ProcessedApplicationScalarWhereInput | ProcessedApplicationScalarWhereInput[]
    id?: UuidFilter<"ProcessedApplication"> | string
    userId?: UuidFilter<"ProcessedApplication"> | string
    processId?: UuidFilter<"ProcessedApplication"> | string
    applicantProcessId?: UuidFilter<"ProcessedApplication"> | string
    formId?: UuidFilter<"ProcessedApplication"> | string
    formRoleIds?: StringNullableListFilter<"ProcessedApplication">
    createdAt?: DateTimeFilter<"ProcessedApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessedApplication"> | Date | string
  }

  export type QrCodeDocumentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: QrCodeDocumentWhereUniqueInput
    update: XOR<QrCodeDocumentUpdateWithoutCreatorInput, QrCodeDocumentUncheckedUpdateWithoutCreatorInput>
    create: XOR<QrCodeDocumentCreateWithoutCreatorInput, QrCodeDocumentUncheckedCreateWithoutCreatorInput>
  }

  export type QrCodeDocumentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: QrCodeDocumentWhereUniqueInput
    data: XOR<QrCodeDocumentUpdateWithoutCreatorInput, QrCodeDocumentUncheckedUpdateWithoutCreatorInput>
  }

  export type QrCodeDocumentUpdateManyWithWhereWithoutCreatorInput = {
    where: QrCodeDocumentScalarWhereInput
    data: XOR<QrCodeDocumentUpdateManyMutationInput, QrCodeDocumentUncheckedUpdateManyWithoutCreatorInput>
  }

  export type QrCodeDocumentScalarWhereInput = {
    AND?: QrCodeDocumentScalarWhereInput | QrCodeDocumentScalarWhereInput[]
    OR?: QrCodeDocumentScalarWhereInput[]
    NOT?: QrCodeDocumentScalarWhereInput | QrCodeDocumentScalarWhereInput[]
    id?: UuidFilter<"QrCodeDocument"> | string
    documentName?: StringFilter<"QrCodeDocument"> | string
    fileName?: StringFilter<"QrCodeDocument"> | string
    qrCodeId?: StringFilter<"QrCodeDocument"> | string
    creatorId?: UuidFilter<"QrCodeDocument"> | string
    createdAt?: DateTimeFilter<"QrCodeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"QrCodeDocument"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    status?: EnumRoleStatusFilter<"UserRole"> | $Enums.RoleStatus
  }

  export type GroupRoleCreateWithoutRoleInput = {
    status?: $Enums.RoleStatus
    group: GroupCreateNestedOneWithoutRolesInput
  }

  export type GroupRoleUncheckedCreateWithoutRoleInput = {
    groupId: string
    status?: $Enums.RoleStatus
  }

  export type GroupRoleCreateOrConnectWithoutRoleInput = {
    where: GroupRoleWhereUniqueInput
    create: XOR<GroupRoleCreateWithoutRoleInput, GroupRoleUncheckedCreateWithoutRoleInput>
  }

  export type GroupRoleCreateManyRoleInputEnvelope = {
    data: GroupRoleCreateManyRoleInput | GroupRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type ProcessRoleCreateWithoutRoleInput = {
    status?: $Enums.RoleStatus
    process: ProcessCreateNestedOneWithoutRolesInput
  }

  export type ProcessRoleUncheckedCreateWithoutRoleInput = {
    processId: string
    status?: $Enums.RoleStatus
  }

  export type ProcessRoleCreateOrConnectWithoutRoleInput = {
    where: ProcessRoleWhereUniqueInput
    create: XOR<ProcessRoleCreateWithoutRoleInput, ProcessRoleUncheckedCreateWithoutRoleInput>
  }

  export type ProcessRoleCreateManyRoleInputEnvelope = {
    data: ProcessRoleCreateManyRoleInput | ProcessRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutRoleInput = {
    status?: $Enums.RoleStatus
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
    status?: $Enums.RoleStatus
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type GroupRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: GroupRoleWhereUniqueInput
    update: XOR<GroupRoleUpdateWithoutRoleInput, GroupRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<GroupRoleCreateWithoutRoleInput, GroupRoleUncheckedCreateWithoutRoleInput>
  }

  export type GroupRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: GroupRoleWhereUniqueInput
    data: XOR<GroupRoleUpdateWithoutRoleInput, GroupRoleUncheckedUpdateWithoutRoleInput>
  }

  export type GroupRoleUpdateManyWithWhereWithoutRoleInput = {
    where: GroupRoleScalarWhereInput
    data: XOR<GroupRoleUpdateManyMutationInput, GroupRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type GroupRoleScalarWhereInput = {
    AND?: GroupRoleScalarWhereInput | GroupRoleScalarWhereInput[]
    OR?: GroupRoleScalarWhereInput[]
    NOT?: GroupRoleScalarWhereInput | GroupRoleScalarWhereInput[]
    groupId?: UuidFilter<"GroupRole"> | string
    roleId?: UuidFilter<"GroupRole"> | string
    status?: EnumRoleStatusFilter<"GroupRole"> | $Enums.RoleStatus
  }

  export type ProcessRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: ProcessRoleWhereUniqueInput
    update: XOR<ProcessRoleUpdateWithoutRoleInput, ProcessRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<ProcessRoleCreateWithoutRoleInput, ProcessRoleUncheckedCreateWithoutRoleInput>
  }

  export type ProcessRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: ProcessRoleWhereUniqueInput
    data: XOR<ProcessRoleUpdateWithoutRoleInput, ProcessRoleUncheckedUpdateWithoutRoleInput>
  }

  export type ProcessRoleUpdateManyWithWhereWithoutRoleInput = {
    where: ProcessRoleScalarWhereInput
    data: XOR<ProcessRoleUpdateManyMutationInput, ProcessRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type ProcessRoleScalarWhereInput = {
    AND?: ProcessRoleScalarWhereInput | ProcessRoleScalarWhereInput[]
    OR?: ProcessRoleScalarWhereInput[]
    NOT?: ProcessRoleScalarWhereInput | ProcessRoleScalarWhereInput[]
    processId?: UuidFilter<"ProcessRole"> | string
    roleId?: UuidFilter<"ProcessRole"> | string
    status?: EnumRoleStatusFilter<"ProcessRole"> | $Enums.RoleStatus
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupRoleCreateNestedManyWithoutRoleInput
    processes?: ProcessRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupRoleUncheckedCreateNestedManyWithoutRoleInput
    processes?: ProcessRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupRoleUpdateManyWithoutRoleNestedInput
    processes?: ProcessRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupRoleUncheckedUpdateManyWithoutRoleNestedInput
    processes?: ProcessRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutFilesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFilesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
  }

  export type UserUpsertWithoutFilesInput = {
    update: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupRoleCreateWithoutGroupInput = {
    status?: $Enums.RoleStatus
    role: RoleCreateNestedOneWithoutGroupsInput
  }

  export type GroupRoleUncheckedCreateWithoutGroupInput = {
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type GroupRoleCreateOrConnectWithoutGroupInput = {
    where: GroupRoleWhereUniqueInput
    create: XOR<GroupRoleCreateWithoutGroupInput, GroupRoleUncheckedCreateWithoutGroupInput>
  }

  export type GroupRoleCreateManyGroupInputEnvelope = {
    data: GroupRoleCreateManyGroupInput | GroupRoleCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedGroupsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedGroupsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
  }

  export type ProcessCreateWithoutGroupInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseCreateNestedManyWithoutProcessInput
    forms?: ProcessFormCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleCreateNestedManyWithoutProcessInput
    creator: UserCreateNestedOneWithoutCreatedProcessesInput
  }

  export type ProcessUncheckedCreateWithoutGroupInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutProcessInput
    forms?: ProcessFormUncheckedCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutGroupInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutGroupInput, ProcessUncheckedCreateWithoutGroupInput>
  }

  export type ProcessCreateManyGroupInputEnvelope = {
    data: ProcessCreateManyGroupInput | ProcessCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupRoleUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupRoleWhereUniqueInput
    update: XOR<GroupRoleUpdateWithoutGroupInput, GroupRoleUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupRoleCreateWithoutGroupInput, GroupRoleUncheckedCreateWithoutGroupInput>
  }

  export type GroupRoleUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupRoleWhereUniqueInput
    data: XOR<GroupRoleUpdateWithoutGroupInput, GroupRoleUncheckedUpdateWithoutGroupInput>
  }

  export type GroupRoleUpdateManyWithWhereWithoutGroupInput = {
    where: GroupRoleScalarWhereInput
    data: XOR<GroupRoleUpdateManyMutationInput, GroupRoleUncheckedUpdateManyWithoutGroupInput>
  }

  export type UserUpsertWithoutCreatedGroupsInput = {
    update: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type UserUpdateWithoutCreatedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProcessUpsertWithWhereUniqueWithoutGroupInput = {
    where: ProcessWhereUniqueInput
    update: XOR<ProcessUpdateWithoutGroupInput, ProcessUncheckedUpdateWithoutGroupInput>
    create: XOR<ProcessCreateWithoutGroupInput, ProcessUncheckedCreateWithoutGroupInput>
  }

  export type ProcessUpdateWithWhereUniqueWithoutGroupInput = {
    where: ProcessWhereUniqueInput
    data: XOR<ProcessUpdateWithoutGroupInput, ProcessUncheckedUpdateWithoutGroupInput>
  }

  export type ProcessUpdateManyWithWhereWithoutGroupInput = {
    where: ProcessScalarWhereInput
    data: XOR<ProcessUpdateManyMutationInput, ProcessUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupCreateWithoutRolesInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
    processes?: ProcessCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processes?: ProcessUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutRolesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutGroupsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    processes?: ProcessRoleCreateNestedManyWithoutRoleInput
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutGroupsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    processes?: ProcessRoleUncheckedCreateNestedManyWithoutRoleInput
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutGroupsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput>
  }

  export type GroupUpsertWithoutRolesInput = {
    update: XOR<GroupUpdateWithoutRolesInput, GroupUncheckedUpdateWithoutRolesInput>
    create: XOR<GroupCreateWithoutRolesInput, GroupUncheckedCreateWithoutRolesInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutRolesInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutRolesInput, GroupUncheckedUpdateWithoutRolesInput>
  }

  export type GroupUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    processes?: ProcessUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processes?: ProcessUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type RoleUpsertWithoutGroupsInput = {
    update: XOR<RoleUpdateWithoutGroupsInput, RoleUncheckedUpdateWithoutGroupsInput>
    create: XOR<RoleCreateWithoutGroupsInput, RoleUncheckedCreateWithoutGroupsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutGroupsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutGroupsInput, RoleUncheckedUpdateWithoutGroupsInput>
  }

  export type RoleUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processes?: ProcessRoleUpdateManyWithoutRoleNestedInput
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processes?: ProcessRoleUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type ApplicantProcessCreateWithoutProcessInput = {
    id?: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormCreateNestedManyWithoutApplicantProcessInput
    applicant: UserCreateNestedOneWithoutApplicantProcessesInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessUncheckedCreateWithoutProcessInput = {
    id?: string
    applicantId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormUncheckedCreateNestedManyWithoutApplicantProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseUncheckedCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentUncheckedCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessCreateOrConnectWithoutProcessInput = {
    where: ApplicantProcessWhereUniqueInput
    create: XOR<ApplicantProcessCreateWithoutProcessInput, ApplicantProcessUncheckedCreateWithoutProcessInput>
  }

  export type ApplicantProcessCreateManyProcessInputEnvelope = {
    data: ApplicantProcessCreateManyProcessInput | ApplicantProcessCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type FormResponseCreateWithoutProcessInput = {
    id?: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    applicantProcess: ApplicantProcessCreateNestedOneWithoutResponsesInput
    form: FormCreateNestedOneWithoutResponsesInput
  }

  export type FormResponseUncheckedCreateWithoutProcessInput = {
    id?: string
    formId: string
    applicantProcessId: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FormResponseCreateOrConnectWithoutProcessInput = {
    where: FormResponseWhereUniqueInput
    create: XOR<FormResponseCreateWithoutProcessInput, FormResponseUncheckedCreateWithoutProcessInput>
  }

  export type FormResponseCreateManyProcessInputEnvelope = {
    data: FormResponseCreateManyProcessInput | FormResponseCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type ProcessFormCreateWithoutProcessInput = {
    id?: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: FormCreateNestedOneWithoutProcessFormsInput
  }

  export type ProcessFormUncheckedCreateWithoutProcessInput = {
    id?: string
    formId: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessFormCreateOrConnectWithoutProcessInput = {
    where: ProcessFormWhereUniqueInput
    create: XOR<ProcessFormCreateWithoutProcessInput, ProcessFormUncheckedCreateWithoutProcessInput>
  }

  export type ProcessFormCreateManyProcessInputEnvelope = {
    data: ProcessFormCreateManyProcessInput | ProcessFormCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type ProcessedApplicationCreateWithoutProcessInput = {
    id?: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProcessedApplicationsInput
    applicantProcess: ApplicantProcessCreateNestedOneWithoutProcessedApplicationsInput
  }

  export type ProcessedApplicationUncheckedCreateWithoutProcessInput = {
    id?: string
    userId: string
    applicantProcessId: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessedApplicationCreateOrConnectWithoutProcessInput = {
    where: ProcessedApplicationWhereUniqueInput
    create: XOR<ProcessedApplicationCreateWithoutProcessInput, ProcessedApplicationUncheckedCreateWithoutProcessInput>
  }

  export type ProcessedApplicationCreateManyProcessInputEnvelope = {
    data: ProcessedApplicationCreateManyProcessInput | ProcessedApplicationCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type ProcessRoleCreateWithoutProcessInput = {
    status?: $Enums.RoleStatus
    role: RoleCreateNestedOneWithoutProcessesInput
  }

  export type ProcessRoleUncheckedCreateWithoutProcessInput = {
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type ProcessRoleCreateOrConnectWithoutProcessInput = {
    where: ProcessRoleWhereUniqueInput
    create: XOR<ProcessRoleCreateWithoutProcessInput, ProcessRoleUncheckedCreateWithoutProcessInput>
  }

  export type ProcessRoleCreateManyProcessInputEnvelope = {
    data: ProcessRoleCreateManyProcessInput | ProcessRoleCreateManyProcessInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedProcessesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedProcessesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedProcessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProcessesInput, UserUncheckedCreateWithoutCreatedProcessesInput>
  }

  export type GroupCreateWithoutProcessesInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: GroupRoleCreateNestedManyWithoutGroupInput
    creator: UserCreateNestedOneWithoutCreatedGroupsInput
  }

  export type GroupUncheckedCreateWithoutProcessesInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: GroupRoleUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutProcessesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutProcessesInput, GroupUncheckedCreateWithoutProcessesInput>
  }

  export type ApplicantProcessUpsertWithWhereUniqueWithoutProcessInput = {
    where: ApplicantProcessWhereUniqueInput
    update: XOR<ApplicantProcessUpdateWithoutProcessInput, ApplicantProcessUncheckedUpdateWithoutProcessInput>
    create: XOR<ApplicantProcessCreateWithoutProcessInput, ApplicantProcessUncheckedCreateWithoutProcessInput>
  }

  export type ApplicantProcessUpdateWithWhereUniqueWithoutProcessInput = {
    where: ApplicantProcessWhereUniqueInput
    data: XOR<ApplicantProcessUpdateWithoutProcessInput, ApplicantProcessUncheckedUpdateWithoutProcessInput>
  }

  export type ApplicantProcessUpdateManyWithWhereWithoutProcessInput = {
    where: ApplicantProcessScalarWhereInput
    data: XOR<ApplicantProcessUpdateManyMutationInput, ApplicantProcessUncheckedUpdateManyWithoutProcessInput>
  }

  export type FormResponseUpsertWithWhereUniqueWithoutProcessInput = {
    where: FormResponseWhereUniqueInput
    update: XOR<FormResponseUpdateWithoutProcessInput, FormResponseUncheckedUpdateWithoutProcessInput>
    create: XOR<FormResponseCreateWithoutProcessInput, FormResponseUncheckedCreateWithoutProcessInput>
  }

  export type FormResponseUpdateWithWhereUniqueWithoutProcessInput = {
    where: FormResponseWhereUniqueInput
    data: XOR<FormResponseUpdateWithoutProcessInput, FormResponseUncheckedUpdateWithoutProcessInput>
  }

  export type FormResponseUpdateManyWithWhereWithoutProcessInput = {
    where: FormResponseScalarWhereInput
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyWithoutProcessInput>
  }

  export type FormResponseScalarWhereInput = {
    AND?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
    OR?: FormResponseScalarWhereInput[]
    NOT?: FormResponseScalarWhereInput | FormResponseScalarWhereInput[]
    id?: UuidFilter<"FormResponse"> | string
    formId?: UuidFilter<"FormResponse"> | string
    applicantProcessId?: UuidFilter<"FormResponse"> | string
    responses?: JsonFilter<"FormResponse">
    createdAt?: DateTimeFilter<"FormResponse"> | Date | string
    processId?: UuidFilter<"FormResponse"> | string
  }

  export type ProcessFormUpsertWithWhereUniqueWithoutProcessInput = {
    where: ProcessFormWhereUniqueInput
    update: XOR<ProcessFormUpdateWithoutProcessInput, ProcessFormUncheckedUpdateWithoutProcessInput>
    create: XOR<ProcessFormCreateWithoutProcessInput, ProcessFormUncheckedCreateWithoutProcessInput>
  }

  export type ProcessFormUpdateWithWhereUniqueWithoutProcessInput = {
    where: ProcessFormWhereUniqueInput
    data: XOR<ProcessFormUpdateWithoutProcessInput, ProcessFormUncheckedUpdateWithoutProcessInput>
  }

  export type ProcessFormUpdateManyWithWhereWithoutProcessInput = {
    where: ProcessFormScalarWhereInput
    data: XOR<ProcessFormUpdateManyMutationInput, ProcessFormUncheckedUpdateManyWithoutProcessInput>
  }

  export type ProcessFormScalarWhereInput = {
    AND?: ProcessFormScalarWhereInput | ProcessFormScalarWhereInput[]
    OR?: ProcessFormScalarWhereInput[]
    NOT?: ProcessFormScalarWhereInput | ProcessFormScalarWhereInput[]
    id?: UuidFilter<"ProcessForm"> | string
    processId?: UuidFilter<"ProcessForm"> | string
    formId?: UuidFilter<"ProcessForm"> | string
    order?: IntFilter<"ProcessForm"> | number
    nextStepType?: EnumNextStepTypeFilter<"ProcessForm"> | $Enums.NextStepType
    nextStepRoles?: StringNullableListFilter<"ProcessForm">
    nextStaffId?: UuidNullableFilter<"ProcessForm"> | string | null
    nextStepSpecifiedTo?: StringNullableFilter<"ProcessForm"> | string | null
    notificationType?: EnumNextStepTypeFilter<"ProcessForm"> | $Enums.NextStepType
    notificationRoles?: StringNullableListFilter<"ProcessForm">
    notificationToId?: UuidNullableFilter<"ProcessForm"> | string | null
    notificationComment?: StringNullableFilter<"ProcessForm"> | string | null
    notifyApplicant?: BoolFilter<"ProcessForm"> | boolean
    applicantNotificationContent?: StringNullableFilter<"ProcessForm"> | string | null
    editApplicationStatus?: BoolFilter<"ProcessForm"> | boolean
    applicantViewFormAfterCompletion?: BoolFilter<"ProcessForm"> | boolean
    createdAt?: DateTimeFilter<"ProcessForm"> | Date | string
    updatedAt?: DateTimeFilter<"ProcessForm"> | Date | string
  }

  export type ProcessedApplicationUpsertWithWhereUniqueWithoutProcessInput = {
    where: ProcessedApplicationWhereUniqueInput
    update: XOR<ProcessedApplicationUpdateWithoutProcessInput, ProcessedApplicationUncheckedUpdateWithoutProcessInput>
    create: XOR<ProcessedApplicationCreateWithoutProcessInput, ProcessedApplicationUncheckedCreateWithoutProcessInput>
  }

  export type ProcessedApplicationUpdateWithWhereUniqueWithoutProcessInput = {
    where: ProcessedApplicationWhereUniqueInput
    data: XOR<ProcessedApplicationUpdateWithoutProcessInput, ProcessedApplicationUncheckedUpdateWithoutProcessInput>
  }

  export type ProcessedApplicationUpdateManyWithWhereWithoutProcessInput = {
    where: ProcessedApplicationScalarWhereInput
    data: XOR<ProcessedApplicationUpdateManyMutationInput, ProcessedApplicationUncheckedUpdateManyWithoutProcessInput>
  }

  export type ProcessRoleUpsertWithWhereUniqueWithoutProcessInput = {
    where: ProcessRoleWhereUniqueInput
    update: XOR<ProcessRoleUpdateWithoutProcessInput, ProcessRoleUncheckedUpdateWithoutProcessInput>
    create: XOR<ProcessRoleCreateWithoutProcessInput, ProcessRoleUncheckedCreateWithoutProcessInput>
  }

  export type ProcessRoleUpdateWithWhereUniqueWithoutProcessInput = {
    where: ProcessRoleWhereUniqueInput
    data: XOR<ProcessRoleUpdateWithoutProcessInput, ProcessRoleUncheckedUpdateWithoutProcessInput>
  }

  export type ProcessRoleUpdateManyWithWhereWithoutProcessInput = {
    where: ProcessRoleScalarWhereInput
    data: XOR<ProcessRoleUpdateManyMutationInput, ProcessRoleUncheckedUpdateManyWithoutProcessInput>
  }

  export type UserUpsertWithoutCreatedProcessesInput = {
    update: XOR<UserUpdateWithoutCreatedProcessesInput, UserUncheckedUpdateWithoutCreatedProcessesInput>
    create: XOR<UserCreateWithoutCreatedProcessesInput, UserUncheckedCreateWithoutCreatedProcessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProcessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProcessesInput, UserUncheckedUpdateWithoutCreatedProcessesInput>
  }

  export type UserUpdateWithoutCreatedProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupUpsertWithoutProcessesInput = {
    update: XOR<GroupUpdateWithoutProcessesInput, GroupUncheckedUpdateWithoutProcessesInput>
    create: XOR<GroupCreateWithoutProcessesInput, GroupUncheckedCreateWithoutProcessesInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutProcessesInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutProcessesInput, GroupUncheckedUpdateWithoutProcessesInput>
  }

  export type GroupUpdateWithoutProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: GroupRoleUpdateManyWithoutGroupNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: GroupRoleUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type ProcessCreateWithoutRolesInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseCreateNestedManyWithoutProcessInput
    forms?: ProcessFormCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutProcessInput
    creator: UserCreateNestedOneWithoutCreatedProcessesInput
    group: GroupCreateNestedOneWithoutProcessesInput
  }

  export type ProcessUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutProcessInput
    forms?: ProcessFormUncheckedCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutRolesInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutRolesInput, ProcessUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutProcessesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupRoleCreateNestedManyWithoutRoleInput
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutProcessesInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.RoleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupRoleUncheckedCreateNestedManyWithoutRoleInput
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutProcessesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutProcessesInput, RoleUncheckedCreateWithoutProcessesInput>
  }

  export type ProcessUpsertWithoutRolesInput = {
    update: XOR<ProcessUpdateWithoutRolesInput, ProcessUncheckedUpdateWithoutRolesInput>
    create: XOR<ProcessCreateWithoutRolesInput, ProcessUncheckedCreateWithoutRolesInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutRolesInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutRolesInput, ProcessUncheckedUpdateWithoutRolesInput>
  }

  export type ProcessUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutProcessNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProcessesNestedInput
    group?: GroupUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUncheckedUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type RoleUpsertWithoutProcessesInput = {
    update: XOR<RoleUpdateWithoutProcessesInput, RoleUncheckedUpdateWithoutProcessesInput>
    create: XOR<RoleCreateWithoutProcessesInput, RoleUncheckedCreateWithoutProcessesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutProcessesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutProcessesInput, RoleUncheckedUpdateWithoutProcessesInput>
  }

  export type RoleUpdateWithoutProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupRoleUpdateManyWithoutRoleNestedInput
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupRoleUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserCreateWithoutCreatedFoldersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedFoldersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedFoldersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedFoldersInput, UserUncheckedCreateWithoutCreatedFoldersInput>
  }

  export type FormCreateWithoutFolderInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseCreateNestedManyWithoutFormInput
    creator: UserCreateNestedOneWithoutCreatedFormsInput
    processForms?: ProcessFormCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutFolderInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUncheckedCreateNestedManyWithoutFormInput
    processForms?: ProcessFormUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutFolderInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutFolderInput, FormUncheckedCreateWithoutFolderInput>
  }

  export type FormCreateManyFolderInputEnvelope = {
    data: FormCreateManyFolderInput | FormCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedFoldersInput = {
    update: XOR<UserUpdateWithoutCreatedFoldersInput, UserUncheckedUpdateWithoutCreatedFoldersInput>
    create: XOR<UserCreateWithoutCreatedFoldersInput, UserUncheckedCreateWithoutCreatedFoldersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedFoldersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedFoldersInput, UserUncheckedUpdateWithoutCreatedFoldersInput>
  }

  export type UserUpdateWithoutCreatedFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FormUpsertWithWhereUniqueWithoutFolderInput = {
    where: FormWhereUniqueInput
    update: XOR<FormUpdateWithoutFolderInput, FormUncheckedUpdateWithoutFolderInput>
    create: XOR<FormCreateWithoutFolderInput, FormUncheckedCreateWithoutFolderInput>
  }

  export type FormUpdateWithWhereUniqueWithoutFolderInput = {
    where: FormWhereUniqueInput
    data: XOR<FormUpdateWithoutFolderInput, FormUncheckedUpdateWithoutFolderInput>
  }

  export type FormUpdateManyWithWhereWithoutFolderInput = {
    where: FormScalarWhereInput
    data: XOR<FormUpdateManyMutationInput, FormUncheckedUpdateManyWithoutFolderInput>
  }

  export type FormResponseCreateWithoutFormInput = {
    id?: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    applicantProcess: ApplicantProcessCreateNestedOneWithoutResponsesInput
    process: ProcessCreateNestedOneWithoutFormResponsesInput
  }

  export type FormResponseUncheckedCreateWithoutFormInput = {
    id?: string
    applicantProcessId: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processId: string
  }

  export type FormResponseCreateOrConnectWithoutFormInput = {
    where: FormResponseWhereUniqueInput
    create: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput>
  }

  export type FormResponseCreateManyFormInputEnvelope = {
    data: FormResponseCreateManyFormInput | FormResponseCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedFormsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedFormsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedFormsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedFormsInput, UserUncheckedCreateWithoutCreatedFormsInput>
  }

  export type FolderCreateWithoutFormsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedFoldersInput
  }

  export type FolderUncheckedCreateWithoutFormsInput = {
    id?: string
    name: string
    description?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderCreateOrConnectWithoutFormsInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutFormsInput, FolderUncheckedCreateWithoutFormsInput>
  }

  export type ProcessFormCreateWithoutFormInput = {
    id?: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    process: ProcessCreateNestedOneWithoutFormsInput
  }

  export type ProcessFormUncheckedCreateWithoutFormInput = {
    id?: string
    processId: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessFormCreateOrConnectWithoutFormInput = {
    where: ProcessFormWhereUniqueInput
    create: XOR<ProcessFormCreateWithoutFormInput, ProcessFormUncheckedCreateWithoutFormInput>
  }

  export type ProcessFormCreateManyFormInputEnvelope = {
    data: ProcessFormCreateManyFormInput | ProcessFormCreateManyFormInput[]
    skipDuplicates?: boolean
  }

  export type FormResponseUpsertWithWhereUniqueWithoutFormInput = {
    where: FormResponseWhereUniqueInput
    update: XOR<FormResponseUpdateWithoutFormInput, FormResponseUncheckedUpdateWithoutFormInput>
    create: XOR<FormResponseCreateWithoutFormInput, FormResponseUncheckedCreateWithoutFormInput>
  }

  export type FormResponseUpdateWithWhereUniqueWithoutFormInput = {
    where: FormResponseWhereUniqueInput
    data: XOR<FormResponseUpdateWithoutFormInput, FormResponseUncheckedUpdateWithoutFormInput>
  }

  export type FormResponseUpdateManyWithWhereWithoutFormInput = {
    where: FormResponseScalarWhereInput
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyWithoutFormInput>
  }

  export type UserUpsertWithoutCreatedFormsInput = {
    update: XOR<UserUpdateWithoutCreatedFormsInput, UserUncheckedUpdateWithoutCreatedFormsInput>
    create: XOR<UserCreateWithoutCreatedFormsInput, UserUncheckedCreateWithoutCreatedFormsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedFormsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedFormsInput, UserUncheckedUpdateWithoutCreatedFormsInput>
  }

  export type UserUpdateWithoutCreatedFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FolderUpsertWithoutFormsInput = {
    update: XOR<FolderUpdateWithoutFormsInput, FolderUncheckedUpdateWithoutFormsInput>
    create: XOR<FolderCreateWithoutFormsInput, FolderUncheckedCreateWithoutFormsInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutFormsInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutFormsInput, FolderUncheckedUpdateWithoutFormsInput>
  }

  export type FolderUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedFoldersNestedInput
  }

  export type FolderUncheckedUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessFormUpsertWithWhereUniqueWithoutFormInput = {
    where: ProcessFormWhereUniqueInput
    update: XOR<ProcessFormUpdateWithoutFormInput, ProcessFormUncheckedUpdateWithoutFormInput>
    create: XOR<ProcessFormCreateWithoutFormInput, ProcessFormUncheckedCreateWithoutFormInput>
  }

  export type ProcessFormUpdateWithWhereUniqueWithoutFormInput = {
    where: ProcessFormWhereUniqueInput
    data: XOR<ProcessFormUpdateWithoutFormInput, ProcessFormUncheckedUpdateWithoutFormInput>
  }

  export type ProcessFormUpdateManyWithWhereWithoutFormInput = {
    where: ProcessFormScalarWhereInput
    data: XOR<ProcessFormUpdateManyMutationInput, ProcessFormUncheckedUpdateManyWithoutFormInput>
  }

  export type ApplicantProcessCreateWithoutResponsesInput = {
    id?: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormCreateNestedManyWithoutApplicantProcessInput
    applicant: UserCreateNestedOneWithoutApplicantProcessesInput
    process: ProcessCreateNestedOneWithoutApplicantProcessesInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessUncheckedCreateWithoutResponsesInput = {
    id?: string
    applicantId: string
    processId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormUncheckedCreateNestedManyWithoutApplicantProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentUncheckedCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessCreateOrConnectWithoutResponsesInput = {
    where: ApplicantProcessWhereUniqueInput
    create: XOR<ApplicantProcessCreateWithoutResponsesInput, ApplicantProcessUncheckedCreateWithoutResponsesInput>
  }

  export type FormCreateWithoutResponsesInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedFormsInput
    folder?: FolderCreateNestedOneWithoutFormsInput
    processForms?: ProcessFormCreateNestedManyWithoutFormInput
  }

  export type FormUncheckedCreateWithoutResponsesInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    creatorId: string
    folderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    processForms?: ProcessFormUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutResponsesInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutResponsesInput, FormUncheckedCreateWithoutResponsesInput>
  }

  export type ProcessCreateWithoutFormResponsesInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutProcessInput
    forms?: ProcessFormCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleCreateNestedManyWithoutProcessInput
    creator: UserCreateNestedOneWithoutCreatedProcessesInput
    group: GroupCreateNestedOneWithoutProcessesInput
  }

  export type ProcessUncheckedCreateWithoutFormResponsesInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutProcessInput
    forms?: ProcessFormUncheckedCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutFormResponsesInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutFormResponsesInput, ProcessUncheckedCreateWithoutFormResponsesInput>
  }

  export type ApplicantProcessUpsertWithoutResponsesInput = {
    update: XOR<ApplicantProcessUpdateWithoutResponsesInput, ApplicantProcessUncheckedUpdateWithoutResponsesInput>
    create: XOR<ApplicantProcessCreateWithoutResponsesInput, ApplicantProcessUncheckedCreateWithoutResponsesInput>
    where?: ApplicantProcessWhereInput
  }

  export type ApplicantProcessUpdateToOneWithWhereWithoutResponsesInput = {
    where?: ApplicantProcessWhereInput
    data: XOR<ApplicantProcessUpdateWithoutResponsesInput, ApplicantProcessUncheckedUpdateWithoutResponsesInput>
  }

  export type ApplicantProcessUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUpdateManyWithoutApplicantProcessNestedInput
    applicant?: UserUpdateOneRequiredWithoutApplicantProcessesNestedInput
    process?: ProcessUpdateOneRequiredWithoutApplicantProcessesNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUncheckedUpdateManyWithoutApplicantProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUncheckedUpdateManyWithoutApplicantProcessNestedInput
  }

  export type FormUpsertWithoutResponsesInput = {
    update: XOR<FormUpdateWithoutResponsesInput, FormUncheckedUpdateWithoutResponsesInput>
    create: XOR<FormCreateWithoutResponsesInput, FormUncheckedCreateWithoutResponsesInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutResponsesInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutResponsesInput, FormUncheckedUpdateWithoutResponsesInput>
  }

  export type FormUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedFormsNestedInput
    folder?: FolderUpdateOneWithoutFormsNestedInput
    processForms?: ProcessFormUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    processForms?: ProcessFormUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ProcessUpsertWithoutFormResponsesInput = {
    update: XOR<ProcessUpdateWithoutFormResponsesInput, ProcessUncheckedUpdateWithoutFormResponsesInput>
    create: XOR<ProcessCreateWithoutFormResponsesInput, ProcessUncheckedCreateWithoutFormResponsesInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutFormResponsesInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutFormResponsesInput, ProcessUncheckedUpdateWithoutFormResponsesInput>
  }

  export type ProcessUpdateWithoutFormResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUpdateManyWithoutProcessNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProcessesNestedInput
    group?: GroupUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessUncheckedUpdateWithoutFormResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUncheckedUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type FormCreateWithoutProcessFormsInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseCreateNestedManyWithoutFormInput
    creator: UserCreateNestedOneWithoutCreatedFormsInput
    folder?: FolderCreateNestedOneWithoutFormsInput
  }

  export type FormUncheckedCreateWithoutProcessFormsInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    creatorId: string
    folderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUncheckedCreateNestedManyWithoutFormInput
  }

  export type FormCreateOrConnectWithoutProcessFormsInput = {
    where: FormWhereUniqueInput
    create: XOR<FormCreateWithoutProcessFormsInput, FormUncheckedCreateWithoutProcessFormsInput>
  }

  export type ProcessCreateWithoutFormsInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleCreateNestedManyWithoutProcessInput
    creator: UserCreateNestedOneWithoutCreatedProcessesInput
    group: GroupCreateNestedOneWithoutProcessesInput
  }

  export type ProcessUncheckedCreateWithoutFormsInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutFormsInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutFormsInput, ProcessUncheckedCreateWithoutFormsInput>
  }

  export type FormUpsertWithoutProcessFormsInput = {
    update: XOR<FormUpdateWithoutProcessFormsInput, FormUncheckedUpdateWithoutProcessFormsInput>
    create: XOR<FormCreateWithoutProcessFormsInput, FormUncheckedCreateWithoutProcessFormsInput>
    where?: FormWhereInput
  }

  export type FormUpdateToOneWithWhereWithoutProcessFormsInput = {
    where?: FormWhereInput
    data: XOR<FormUpdateWithoutProcessFormsInput, FormUncheckedUpdateWithoutProcessFormsInput>
  }

  export type FormUpdateWithoutProcessFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUpdateManyWithoutFormNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedFormsNestedInput
    folder?: FolderUpdateOneWithoutFormsNestedInput
  }

  export type FormUncheckedUpdateWithoutProcessFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUncheckedUpdateManyWithoutFormNestedInput
  }

  export type ProcessUpsertWithoutFormsInput = {
    update: XOR<ProcessUpdateWithoutFormsInput, ProcessUncheckedUpdateWithoutFormsInput>
    create: XOR<ProcessCreateWithoutFormsInput, ProcessUncheckedCreateWithoutFormsInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutFormsInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutFormsInput, ProcessUncheckedUpdateWithoutFormsInput>
  }

  export type ProcessUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUpdateManyWithoutProcessNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProcessesNestedInput
    group?: GroupUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessUncheckedUpdateWithoutFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type APCompletedFormCreateWithoutApplicantProcessInput = {
    id?: string
    formId: string
    reviewerId?: string | null
    nextStaffId?: string | null
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: APCompletedFormCreatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationToId?: string | null
    notificationToRoles?: APCompletedFormCreatenotificationToRolesInput | string[]
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
  }

  export type APCompletedFormUncheckedCreateWithoutApplicantProcessInput = {
    id?: string
    formId: string
    reviewerId?: string | null
    nextStaffId?: string | null
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: APCompletedFormCreatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationToId?: string | null
    notificationToRoles?: APCompletedFormCreatenotificationToRolesInput | string[]
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
  }

  export type APCompletedFormCreateOrConnectWithoutApplicantProcessInput = {
    where: APCompletedFormWhereUniqueInput
    create: XOR<APCompletedFormCreateWithoutApplicantProcessInput, APCompletedFormUncheckedCreateWithoutApplicantProcessInput>
  }

  export type APCompletedFormCreateManyApplicantProcessInputEnvelope = {
    data: APCompletedFormCreateManyApplicantProcessInput | APCompletedFormCreateManyApplicantProcessInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutApplicantProcessesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApplicantProcessesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApplicantProcessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicantProcessesInput, UserUncheckedCreateWithoutApplicantProcessesInput>
  }

  export type ProcessCreateWithoutApplicantProcessesInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    formResponses?: FormResponseCreateNestedManyWithoutProcessInput
    forms?: ProcessFormCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleCreateNestedManyWithoutProcessInput
    creator: UserCreateNestedOneWithoutCreatedProcessesInput
    group: GroupCreateNestedOneWithoutProcessesInput
  }

  export type ProcessUncheckedCreateWithoutApplicantProcessesInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutProcessInput
    forms?: ProcessFormUncheckedCreateNestedManyWithoutProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutApplicantProcessesInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutApplicantProcessesInput, ProcessUncheckedCreateWithoutApplicantProcessesInput>
  }

  export type ProcessedApplicationCreateWithoutApplicantProcessInput = {
    id?: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProcessedApplicationsInput
    process: ProcessCreateNestedOneWithoutProcessedApplicationsInput
  }

  export type ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput = {
    id?: string
    userId: string
    processId: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessedApplicationCreateOrConnectWithoutApplicantProcessInput = {
    where: ProcessedApplicationWhereUniqueInput
    create: XOR<ProcessedApplicationCreateWithoutApplicantProcessInput, ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput>
  }

  export type ProcessedApplicationCreateManyApplicantProcessInputEnvelope = {
    data: ProcessedApplicationCreateManyApplicantProcessInput | ProcessedApplicationCreateManyApplicantProcessInput[]
    skipDuplicates?: boolean
  }

  export type FormResponseCreateWithoutApplicantProcessInput = {
    id?: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    form: FormCreateNestedOneWithoutResponsesInput
    process: ProcessCreateNestedOneWithoutFormResponsesInput
  }

  export type FormResponseUncheckedCreateWithoutApplicantProcessInput = {
    id?: string
    formId: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processId: string
  }

  export type FormResponseCreateOrConnectWithoutApplicantProcessInput = {
    where: FormResponseWhereUniqueInput
    create: XOR<FormResponseCreateWithoutApplicantProcessInput, FormResponseUncheckedCreateWithoutApplicantProcessInput>
  }

  export type FormResponseCreateManyApplicantProcessInputEnvelope = {
    data: FormResponseCreateManyApplicantProcessInput | FormResponseCreateManyApplicantProcessInput[]
    skipDuplicates?: boolean
  }

  export type ProcessCommentCreateWithoutApplicantProcessInput = {
    id?: string
    userId: string
    comment: string
    createdAt?: Date | string
  }

  export type ProcessCommentUncheckedCreateWithoutApplicantProcessInput = {
    id?: string
    userId: string
    comment: string
    createdAt?: Date | string
  }

  export type ProcessCommentCreateOrConnectWithoutApplicantProcessInput = {
    where: ProcessCommentWhereUniqueInput
    create: XOR<ProcessCommentCreateWithoutApplicantProcessInput, ProcessCommentUncheckedCreateWithoutApplicantProcessInput>
  }

  export type ProcessCommentCreateManyApplicantProcessInputEnvelope = {
    data: ProcessCommentCreateManyApplicantProcessInput | ProcessCommentCreateManyApplicantProcessInput[]
    skipDuplicates?: boolean
  }

  export type APCompletedFormUpsertWithWhereUniqueWithoutApplicantProcessInput = {
    where: APCompletedFormWhereUniqueInput
    update: XOR<APCompletedFormUpdateWithoutApplicantProcessInput, APCompletedFormUncheckedUpdateWithoutApplicantProcessInput>
    create: XOR<APCompletedFormCreateWithoutApplicantProcessInput, APCompletedFormUncheckedCreateWithoutApplicantProcessInput>
  }

  export type APCompletedFormUpdateWithWhereUniqueWithoutApplicantProcessInput = {
    where: APCompletedFormWhereUniqueInput
    data: XOR<APCompletedFormUpdateWithoutApplicantProcessInput, APCompletedFormUncheckedUpdateWithoutApplicantProcessInput>
  }

  export type APCompletedFormUpdateManyWithWhereWithoutApplicantProcessInput = {
    where: APCompletedFormScalarWhereInput
    data: XOR<APCompletedFormUpdateManyMutationInput, APCompletedFormUncheckedUpdateManyWithoutApplicantProcessInput>
  }

  export type APCompletedFormScalarWhereInput = {
    AND?: APCompletedFormScalarWhereInput | APCompletedFormScalarWhereInput[]
    OR?: APCompletedFormScalarWhereInput[]
    NOT?: APCompletedFormScalarWhereInput | APCompletedFormScalarWhereInput[]
    id?: UuidFilter<"APCompletedForm"> | string
    applicantProcessId?: UuidFilter<"APCompletedForm"> | string
    formId?: UuidFilter<"APCompletedForm"> | string
    reviewerId?: UuidNullableFilter<"APCompletedForm"> | string | null
    nextStaffId?: UuidNullableFilter<"APCompletedForm"> | string | null
    nextStepType?: EnumNextStepTypeFilter<"APCompletedForm"> | $Enums.NextStepType
    nextStepRoles?: StringNullableListFilter<"APCompletedForm">
    nextStepSpecifiedTo?: StringNullableFilter<"APCompletedForm"> | string | null
    notificationType?: EnumNextStepTypeFilter<"APCompletedForm"> | $Enums.NextStepType
    notificationToId?: UuidNullableFilter<"APCompletedForm"> | string | null
    notificationToRoles?: StringNullableListFilter<"APCompletedForm">
    notificationComment?: StringNullableFilter<"APCompletedForm"> | string | null
    notifyApplicant?: BoolFilter<"APCompletedForm"> | boolean
    applicantNotificationContent?: StringNullableFilter<"APCompletedForm"> | string | null
    editApplicationStatus?: BoolFilter<"APCompletedForm"> | boolean
    applicantViewFormAfterCompletion?: BoolFilter<"APCompletedForm"> | boolean
    createdAt?: DateTimeFilter<"APCompletedForm"> | Date | string
  }

  export type UserUpsertWithoutApplicantProcessesInput = {
    update: XOR<UserUpdateWithoutApplicantProcessesInput, UserUncheckedUpdateWithoutApplicantProcessesInput>
    create: XOR<UserCreateWithoutApplicantProcessesInput, UserUncheckedCreateWithoutApplicantProcessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicantProcessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicantProcessesInput, UserUncheckedUpdateWithoutApplicantProcessesInput>
  }

  export type UserUpdateWithoutApplicantProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicantProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProcessUpsertWithoutApplicantProcessesInput = {
    update: XOR<ProcessUpdateWithoutApplicantProcessesInput, ProcessUncheckedUpdateWithoutApplicantProcessesInput>
    create: XOR<ProcessCreateWithoutApplicantProcessesInput, ProcessUncheckedCreateWithoutApplicantProcessesInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutApplicantProcessesInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutApplicantProcessesInput, ProcessUncheckedUpdateWithoutApplicantProcessesInput>
  }

  export type ProcessUpdateWithoutApplicantProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formResponses?: FormResponseUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUpdateManyWithoutProcessNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProcessesNestedInput
    group?: GroupUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessUncheckedUpdateWithoutApplicantProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formResponses?: FormResponseUncheckedUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUncheckedUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessedApplicationUpsertWithWhereUniqueWithoutApplicantProcessInput = {
    where: ProcessedApplicationWhereUniqueInput
    update: XOR<ProcessedApplicationUpdateWithoutApplicantProcessInput, ProcessedApplicationUncheckedUpdateWithoutApplicantProcessInput>
    create: XOR<ProcessedApplicationCreateWithoutApplicantProcessInput, ProcessedApplicationUncheckedCreateWithoutApplicantProcessInput>
  }

  export type ProcessedApplicationUpdateWithWhereUniqueWithoutApplicantProcessInput = {
    where: ProcessedApplicationWhereUniqueInput
    data: XOR<ProcessedApplicationUpdateWithoutApplicantProcessInput, ProcessedApplicationUncheckedUpdateWithoutApplicantProcessInput>
  }

  export type ProcessedApplicationUpdateManyWithWhereWithoutApplicantProcessInput = {
    where: ProcessedApplicationScalarWhereInput
    data: XOR<ProcessedApplicationUpdateManyMutationInput, ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessInput>
  }

  export type FormResponseUpsertWithWhereUniqueWithoutApplicantProcessInput = {
    where: FormResponseWhereUniqueInput
    update: XOR<FormResponseUpdateWithoutApplicantProcessInput, FormResponseUncheckedUpdateWithoutApplicantProcessInput>
    create: XOR<FormResponseCreateWithoutApplicantProcessInput, FormResponseUncheckedCreateWithoutApplicantProcessInput>
  }

  export type FormResponseUpdateWithWhereUniqueWithoutApplicantProcessInput = {
    where: FormResponseWhereUniqueInput
    data: XOR<FormResponseUpdateWithoutApplicantProcessInput, FormResponseUncheckedUpdateWithoutApplicantProcessInput>
  }

  export type FormResponseUpdateManyWithWhereWithoutApplicantProcessInput = {
    where: FormResponseScalarWhereInput
    data: XOR<FormResponseUpdateManyMutationInput, FormResponseUncheckedUpdateManyWithoutApplicantProcessInput>
  }

  export type ProcessCommentUpsertWithWhereUniqueWithoutApplicantProcessInput = {
    where: ProcessCommentWhereUniqueInput
    update: XOR<ProcessCommentUpdateWithoutApplicantProcessInput, ProcessCommentUncheckedUpdateWithoutApplicantProcessInput>
    create: XOR<ProcessCommentCreateWithoutApplicantProcessInput, ProcessCommentUncheckedCreateWithoutApplicantProcessInput>
  }

  export type ProcessCommentUpdateWithWhereUniqueWithoutApplicantProcessInput = {
    where: ProcessCommentWhereUniqueInput
    data: XOR<ProcessCommentUpdateWithoutApplicantProcessInput, ProcessCommentUncheckedUpdateWithoutApplicantProcessInput>
  }

  export type ProcessCommentUpdateManyWithWhereWithoutApplicantProcessInput = {
    where: ProcessCommentScalarWhereInput
    data: XOR<ProcessCommentUpdateManyMutationInput, ProcessCommentUncheckedUpdateManyWithoutApplicantProcessInput>
  }

  export type ProcessCommentScalarWhereInput = {
    AND?: ProcessCommentScalarWhereInput | ProcessCommentScalarWhereInput[]
    OR?: ProcessCommentScalarWhereInput[]
    NOT?: ProcessCommentScalarWhereInput | ProcessCommentScalarWhereInput[]
    id?: UuidFilter<"ProcessComment"> | string
    applicantProcessId?: UuidFilter<"ProcessComment"> | string
    userId?: UuidFilter<"ProcessComment"> | string
    comment?: StringFilter<"ProcessComment"> | string
    createdAt?: DateTimeFilter<"ProcessComment"> | Date | string
  }

  export type UserCreateWithoutProcessedApplicationsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessedApplicationsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessedApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessedApplicationsInput, UserUncheckedCreateWithoutProcessedApplicationsInput>
  }

  export type ProcessCreateWithoutProcessedApplicationsInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseCreateNestedManyWithoutProcessInput
    forms?: ProcessFormCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleCreateNestedManyWithoutProcessInput
    creator: UserCreateNestedOneWithoutCreatedProcessesInput
    group: GroupCreateNestedOneWithoutProcessesInput
  }

  export type ProcessUncheckedCreateWithoutProcessedApplicationsInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutProcessInput
    formResponses?: FormResponseUncheckedCreateNestedManyWithoutProcessInput
    forms?: ProcessFormUncheckedCreateNestedManyWithoutProcessInput
    roles?: ProcessRoleUncheckedCreateNestedManyWithoutProcessInput
  }

  export type ProcessCreateOrConnectWithoutProcessedApplicationsInput = {
    where: ProcessWhereUniqueInput
    create: XOR<ProcessCreateWithoutProcessedApplicationsInput, ProcessUncheckedCreateWithoutProcessedApplicationsInput>
  }

  export type ApplicantProcessCreateWithoutProcessedApplicationsInput = {
    id?: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormCreateNestedManyWithoutApplicantProcessInput
    applicant: UserCreateNestedOneWithoutApplicantProcessesInput
    process: ProcessCreateNestedOneWithoutApplicantProcessesInput
    responses?: FormResponseCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessUncheckedCreateWithoutProcessedApplicationsInput = {
    id?: string
    applicantId: string
    processId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormUncheckedCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseUncheckedCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentUncheckedCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessCreateOrConnectWithoutProcessedApplicationsInput = {
    where: ApplicantProcessWhereUniqueInput
    create: XOR<ApplicantProcessCreateWithoutProcessedApplicationsInput, ApplicantProcessUncheckedCreateWithoutProcessedApplicationsInput>
  }

  export type UserUpsertWithoutProcessedApplicationsInput = {
    update: XOR<UserUpdateWithoutProcessedApplicationsInput, UserUncheckedUpdateWithoutProcessedApplicationsInput>
    create: XOR<UserCreateWithoutProcessedApplicationsInput, UserUncheckedCreateWithoutProcessedApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessedApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessedApplicationsInput, UserUncheckedUpdateWithoutProcessedApplicationsInput>
  }

  export type UserUpdateWithoutProcessedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProcessUpsertWithoutProcessedApplicationsInput = {
    update: XOR<ProcessUpdateWithoutProcessedApplicationsInput, ProcessUncheckedUpdateWithoutProcessedApplicationsInput>
    create: XOR<ProcessCreateWithoutProcessedApplicationsInput, ProcessUncheckedCreateWithoutProcessedApplicationsInput>
    where?: ProcessWhereInput
  }

  export type ProcessUpdateToOneWithWhereWithoutProcessedApplicationsInput = {
    where?: ProcessWhereInput
    data: XOR<ProcessUpdateWithoutProcessedApplicationsInput, ProcessUncheckedUpdateWithoutProcessedApplicationsInput>
  }

  export type ProcessUpdateWithoutProcessedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUpdateManyWithoutProcessNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProcessesNestedInput
    group?: GroupUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessUncheckedUpdateWithoutProcessedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUncheckedUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ApplicantProcessUpsertWithoutProcessedApplicationsInput = {
    update: XOR<ApplicantProcessUpdateWithoutProcessedApplicationsInput, ApplicantProcessUncheckedUpdateWithoutProcessedApplicationsInput>
    create: XOR<ApplicantProcessCreateWithoutProcessedApplicationsInput, ApplicantProcessUncheckedCreateWithoutProcessedApplicationsInput>
    where?: ApplicantProcessWhereInput
  }

  export type ApplicantProcessUpdateToOneWithWhereWithoutProcessedApplicationsInput = {
    where?: ApplicantProcessWhereInput
    data: XOR<ApplicantProcessUpdateWithoutProcessedApplicationsInput, ApplicantProcessUncheckedUpdateWithoutProcessedApplicationsInput>
  }

  export type ApplicantProcessUpdateWithoutProcessedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUpdateManyWithoutApplicantProcessNestedInput
    applicant?: UserUpdateOneRequiredWithoutApplicantProcessesNestedInput
    process?: ProcessUpdateOneRequiredWithoutApplicantProcessesNestedInput
    responses?: FormResponseUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateWithoutProcessedApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUncheckedUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUncheckedUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUncheckedUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessCreateWithoutCompletedFormsInput = {
    id?: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    applicant: UserCreateNestedOneWithoutApplicantProcessesInput
    process: ProcessCreateNestedOneWithoutApplicantProcessesInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessUncheckedCreateWithoutCompletedFormsInput = {
    id?: string
    applicantId: string
    processId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseUncheckedCreateNestedManyWithoutApplicantProcessInput
    comments?: ProcessCommentUncheckedCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessCreateOrConnectWithoutCompletedFormsInput = {
    where: ApplicantProcessWhereUniqueInput
    create: XOR<ApplicantProcessCreateWithoutCompletedFormsInput, ApplicantProcessUncheckedCreateWithoutCompletedFormsInput>
  }

  export type ApplicantProcessUpsertWithoutCompletedFormsInput = {
    update: XOR<ApplicantProcessUpdateWithoutCompletedFormsInput, ApplicantProcessUncheckedUpdateWithoutCompletedFormsInput>
    create: XOR<ApplicantProcessCreateWithoutCompletedFormsInput, ApplicantProcessUncheckedCreateWithoutCompletedFormsInput>
    where?: ApplicantProcessWhereInput
  }

  export type ApplicantProcessUpdateToOneWithWhereWithoutCompletedFormsInput = {
    where?: ApplicantProcessWhereInput
    data: XOR<ApplicantProcessUpdateWithoutCompletedFormsInput, ApplicantProcessUncheckedUpdateWithoutCompletedFormsInput>
  }

  export type ApplicantProcessUpdateWithoutCompletedFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: UserUpdateOneRequiredWithoutApplicantProcessesNestedInput
    process?: ProcessUpdateOneRequiredWithoutApplicantProcessesNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateWithoutCompletedFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUncheckedUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUncheckedUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessCreateWithoutCommentsInput = {
    id?: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormCreateNestedManyWithoutApplicantProcessInput
    applicant: UserCreateNestedOneWithoutApplicantProcessesInput
    process: ProcessCreateNestedOneWithoutApplicantProcessesInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessUncheckedCreateWithoutCommentsInput = {
    id?: string
    applicantId: string
    processId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
    completedForms?: APCompletedFormUncheckedCreateNestedManyWithoutApplicantProcessInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutApplicantProcessInput
    responses?: FormResponseUncheckedCreateNestedManyWithoutApplicantProcessInput
  }

  export type ApplicantProcessCreateOrConnectWithoutCommentsInput = {
    where: ApplicantProcessWhereUniqueInput
    create: XOR<ApplicantProcessCreateWithoutCommentsInput, ApplicantProcessUncheckedCreateWithoutCommentsInput>
  }

  export type ApplicantProcessUpsertWithoutCommentsInput = {
    update: XOR<ApplicantProcessUpdateWithoutCommentsInput, ApplicantProcessUncheckedUpdateWithoutCommentsInput>
    create: XOR<ApplicantProcessCreateWithoutCommentsInput, ApplicantProcessUncheckedCreateWithoutCommentsInput>
    where?: ApplicantProcessWhereInput
  }

  export type ApplicantProcessUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ApplicantProcessWhereInput
    data: XOR<ApplicantProcessUpdateWithoutCommentsInput, ApplicantProcessUncheckedUpdateWithoutCommentsInput>
  }

  export type ApplicantProcessUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUpdateManyWithoutApplicantProcessNestedInput
    applicant?: UserUpdateOneRequiredWithoutApplicantProcessesNestedInput
    process?: ProcessUpdateOneRequiredWithoutApplicantProcessesNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUncheckedUpdateManyWithoutApplicantProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUncheckedUpdateManyWithoutApplicantProcessNestedInput
  }

  export type OrganizationUserCreateWithoutSubordinatesInput = {
    id?: string
    title: string
    superior?: OrganizationUserCreateNestedOneWithoutSubordinatesInput
    user: UserCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUserUncheckedCreateWithoutSubordinatesInput = {
    id?: string
    userId: string
    superiorId?: string | null
    title: string
  }

  export type OrganizationUserCreateOrConnectWithoutSubordinatesInput = {
    where: OrganizationUserWhereUniqueInput
    create: XOR<OrganizationUserCreateWithoutSubordinatesInput, OrganizationUserUncheckedCreateWithoutSubordinatesInput>
  }

  export type OrganizationUserCreateWithoutSuperiorInput = {
    id?: string
    title: string
    subordinates?: OrganizationUserCreateNestedManyWithoutSuperiorInput
    user: UserCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUserUncheckedCreateWithoutSuperiorInput = {
    id?: string
    userId: string
    title: string
    subordinates?: OrganizationUserUncheckedCreateNestedManyWithoutSuperiorInput
  }

  export type OrganizationUserCreateOrConnectWithoutSuperiorInput = {
    where: OrganizationUserWhereUniqueInput
    create: XOR<OrganizationUserCreateWithoutSuperiorInput, OrganizationUserUncheckedCreateWithoutSuperiorInput>
  }

  export type OrganizationUserCreateManySuperiorInputEnvelope = {
    data: OrganizationUserCreateManySuperiorInput | OrganizationUserCreateManySuperiorInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentCreateNestedManyWithoutCreatorInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    qrCodeDocuments?: QrCodeDocumentUncheckedCreateNestedManyWithoutCreatorInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationUserUpsertWithoutSubordinatesInput = {
    update: XOR<OrganizationUserUpdateWithoutSubordinatesInput, OrganizationUserUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<OrganizationUserCreateWithoutSubordinatesInput, OrganizationUserUncheckedCreateWithoutSubordinatesInput>
    where?: OrganizationUserWhereInput
  }

  export type OrganizationUserUpdateToOneWithWhereWithoutSubordinatesInput = {
    where?: OrganizationUserWhereInput
    data: XOR<OrganizationUserUpdateWithoutSubordinatesInput, OrganizationUserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type OrganizationUserUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    superior?: OrganizationUserUpdateOneWithoutSubordinatesNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationNestedInput
  }

  export type OrganizationUserUncheckedUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    superiorId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationUserUpsertWithWhereUniqueWithoutSuperiorInput = {
    where: OrganizationUserWhereUniqueInput
    update: XOR<OrganizationUserUpdateWithoutSuperiorInput, OrganizationUserUncheckedUpdateWithoutSuperiorInput>
    create: XOR<OrganizationUserCreateWithoutSuperiorInput, OrganizationUserUncheckedCreateWithoutSuperiorInput>
  }

  export type OrganizationUserUpdateWithWhereUniqueWithoutSuperiorInput = {
    where: OrganizationUserWhereUniqueInput
    data: XOR<OrganizationUserUpdateWithoutSuperiorInput, OrganizationUserUncheckedUpdateWithoutSuperiorInput>
  }

  export type OrganizationUserUpdateManyWithWhereWithoutSuperiorInput = {
    where: OrganizationUserScalarWhereInput
    data: XOR<OrganizationUserUpdateManyMutationInput, OrganizationUserUncheckedUpdateManyWithoutSuperiorInput>
  }

  export type OrganizationUserScalarWhereInput = {
    AND?: OrganizationUserScalarWhereInput | OrganizationUserScalarWhereInput[]
    OR?: OrganizationUserScalarWhereInput[]
    NOT?: OrganizationUserScalarWhereInput | OrganizationUserScalarWhereInput[]
    id?: UuidFilter<"OrganizationUser"> | string
    userId?: UuidFilter<"OrganizationUser"> | string
    superiorId?: UuidNullableFilter<"OrganizationUser"> | string | null
    title?: StringFilter<"OrganizationUser"> | string
  }

  export type UserUpsertWithoutOrganizationInput = {
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    qrCodeDocuments?: QrCodeDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WidgetCreateWithoutDashboardInput = {
    id?: string
    title: string
    visualizationType: string
    config: JsonNullValueInput | InputJsonValue
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WidgetUncheckedCreateWithoutDashboardInput = {
    id?: string
    title: string
    visualizationType: string
    config: JsonNullValueInput | InputJsonValue
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WidgetCreateOrConnectWithoutDashboardInput = {
    where: WidgetWhereUniqueInput
    create: XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput>
  }

  export type WidgetCreateManyDashboardInputEnvelope = {
    data: WidgetCreateManyDashboardInput | WidgetCreateManyDashboardInput[]
    skipDuplicates?: boolean
  }

  export type WidgetUpsertWithWhereUniqueWithoutDashboardInput = {
    where: WidgetWhereUniqueInput
    update: XOR<WidgetUpdateWithoutDashboardInput, WidgetUncheckedUpdateWithoutDashboardInput>
    create: XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput>
  }

  export type WidgetUpdateWithWhereUniqueWithoutDashboardInput = {
    where: WidgetWhereUniqueInput
    data: XOR<WidgetUpdateWithoutDashboardInput, WidgetUncheckedUpdateWithoutDashboardInput>
  }

  export type WidgetUpdateManyWithWhereWithoutDashboardInput = {
    where: WidgetScalarWhereInput
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyWithoutDashboardInput>
  }

  export type WidgetScalarWhereInput = {
    AND?: WidgetScalarWhereInput | WidgetScalarWhereInput[]
    OR?: WidgetScalarWhereInput[]
    NOT?: WidgetScalarWhereInput | WidgetScalarWhereInput[]
    id?: UuidFilter<"Widget"> | string
    dashboardId?: UuidFilter<"Widget"> | string
    title?: StringFilter<"Widget"> | string
    visualizationType?: StringFilter<"Widget"> | string
    config?: JsonFilter<"Widget">
    order?: IntFilter<"Widget"> | number
    createdAt?: DateTimeFilter<"Widget"> | Date | string
    updatedAt?: DateTimeFilter<"Widget"> | Date | string
  }

  export type DashboardCreateWithoutWidgetsInput = {
    id?: string
    name: string
    ownerId: string
    allowedUsers?: DashboardCreateallowedUsersInput | string[]
    allowedRoles?: DashboardCreateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardUncheckedCreateWithoutWidgetsInput = {
    id?: string
    name: string
    ownerId: string
    allowedUsers?: DashboardCreateallowedUsersInput | string[]
    allowedRoles?: DashboardCreateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardCreateOrConnectWithoutWidgetsInput = {
    where: DashboardWhereUniqueInput
    create: XOR<DashboardCreateWithoutWidgetsInput, DashboardUncheckedCreateWithoutWidgetsInput>
  }

  export type DashboardUpsertWithoutWidgetsInput = {
    update: XOR<DashboardUpdateWithoutWidgetsInput, DashboardUncheckedUpdateWithoutWidgetsInput>
    create: XOR<DashboardCreateWithoutWidgetsInput, DashboardUncheckedCreateWithoutWidgetsInput>
    where?: DashboardWhereInput
  }

  export type DashboardUpdateToOneWithWhereWithoutWidgetsInput = {
    where?: DashboardWhereInput
    data: XOR<DashboardUpdateWithoutWidgetsInput, DashboardUncheckedUpdateWithoutWidgetsInput>
  }

  export type DashboardUpdateWithoutWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    allowedUsers?: DashboardUpdateallowedUsersInput | string[]
    allowedRoles?: DashboardUpdateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardUncheckedUpdateWithoutWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    allowedUsers?: DashboardUpdateallowedUsersInput | string[]
    allowedRoles?: DashboardUpdateallowedRolesInput | string[]
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutQrCodeDocumentsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    createdForms?: FormCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQrCodeDocumentsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    photo?: string | null
    googleId?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    applicantProcesses?: ApplicantProcessUncheckedCreateNestedManyWithoutApplicantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    createdForms?: FormUncheckedCreateNestedManyWithoutCreatorInput
    createdFolders?: FolderUncheckedCreateNestedManyWithoutCreatorInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatorInput
    organization?: OrganizationUserUncheckedCreateNestedOneWithoutUserInput
    createdProcesses?: ProcessUncheckedCreateNestedManyWithoutCreatorInput
    processedApplications?: ProcessedApplicationUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQrCodeDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQrCodeDocumentsInput, UserUncheckedCreateWithoutQrCodeDocumentsInput>
  }

  export type UserUpsertWithoutQrCodeDocumentsInput = {
    update: XOR<UserUpdateWithoutQrCodeDocumentsInput, UserUncheckedUpdateWithoutQrCodeDocumentsInput>
    create: XOR<UserCreateWithoutQrCodeDocumentsInput, UserUncheckedCreateWithoutQrCodeDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQrCodeDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQrCodeDocumentsInput, UserUncheckedUpdateWithoutQrCodeDocumentsInput>
  }

  export type UserUpdateWithoutQrCodeDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    createdForms?: FormUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQrCodeDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutApplicantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    createdForms?: FormUncheckedUpdateManyWithoutCreatorNestedInput
    createdFolders?: FolderUncheckedUpdateManyWithoutCreatorNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatorNestedInput
    organization?: OrganizationUserUncheckedUpdateOneWithoutUserNestedInput
    createdProcesses?: ProcessUncheckedUpdateManyWithoutCreatorNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    role: string
    parts: JsonNullValueInput | InputJsonValue
    attachments: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    votes?: VoteCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    role: string
    parts: JsonNullValueInput | InputJsonValue
    attachments: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: UuidFilter<"Message"> | string
    chatId?: UuidFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    parts?: JsonFilter<"Message">
    attachments?: JsonFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    title: string
    userId: string
    visibility?: string
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    title: string
    userId: string
    visibility?: string
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type VoteCreateWithoutMessageInput = {
    chatId: string
    isUpvoted: boolean
  }

  export type VoteUncheckedCreateWithoutMessageInput = {
    chatId: string
    isUpvoted: boolean
  }

  export type VoteCreateOrConnectWithoutMessageInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutMessageInput, VoteUncheckedCreateWithoutMessageInput>
  }

  export type VoteCreateManyMessageInputEnvelope = {
    data: VoteCreateManyMessageInput | VoteCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
  }

  export type VoteUpsertWithWhereUniqueWithoutMessageInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutMessageInput, VoteUncheckedUpdateWithoutMessageInput>
    create: XOR<VoteCreateWithoutMessageInput, VoteUncheckedCreateWithoutMessageInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutMessageInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutMessageInput, VoteUncheckedUpdateWithoutMessageInput>
  }

  export type VoteUpdateManyWithWhereWithoutMessageInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutMessageInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    chatId?: UuidFilter<"Vote"> | string
    messageId?: UuidFilter<"Vote"> | string
    isUpvoted?: BoolFilter<"Vote"> | boolean
  }

  export type MessageCreateWithoutVotesInput = {
    id?: string
    role: string
    parts: JsonNullValueInput | InputJsonValue
    attachments: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutVotesInput = {
    id?: string
    chatId: string
    role: string
    parts: JsonNullValueInput | InputJsonValue
    attachments: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutVotesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutVotesInput, MessageUncheckedCreateWithoutVotesInput>
  }

  export type MessageUpsertWithoutVotesInput = {
    update: XOR<MessageUpdateWithoutVotesInput, MessageUncheckedUpdateWithoutVotesInput>
    create: XOR<MessageCreateWithoutVotesInput, MessageUncheckedCreateWithoutVotesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutVotesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutVotesInput, MessageUncheckedUpdateWithoutVotesInput>
  }

  export type MessageUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionCreateWithoutDocumentInput = {
    id?: string
    originalText: string
    suggestedText: string
    description?: string | null
    isResolved?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type SuggestionUncheckedCreateWithoutDocumentInput = {
    id?: string
    originalText: string
    suggestedText: string
    description?: string | null
    isResolved?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type SuggestionCreateOrConnectWithoutDocumentInput = {
    where: SuggestionWhereUniqueInput
    create: XOR<SuggestionCreateWithoutDocumentInput, SuggestionUncheckedCreateWithoutDocumentInput>
  }

  export type SuggestionCreateManyDocumentInputEnvelope = {
    data: SuggestionCreateManyDocumentInput | SuggestionCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type SuggestionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: SuggestionWhereUniqueInput
    update: XOR<SuggestionUpdateWithoutDocumentInput, SuggestionUncheckedUpdateWithoutDocumentInput>
    create: XOR<SuggestionCreateWithoutDocumentInput, SuggestionUncheckedCreateWithoutDocumentInput>
  }

  export type SuggestionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: SuggestionWhereUniqueInput
    data: XOR<SuggestionUpdateWithoutDocumentInput, SuggestionUncheckedUpdateWithoutDocumentInput>
  }

  export type SuggestionUpdateManyWithWhereWithoutDocumentInput = {
    where: SuggestionScalarWhereInput
    data: XOR<SuggestionUpdateManyMutationInput, SuggestionUncheckedUpdateManyWithoutDocumentInput>
  }

  export type SuggestionScalarWhereInput = {
    AND?: SuggestionScalarWhereInput | SuggestionScalarWhereInput[]
    OR?: SuggestionScalarWhereInput[]
    NOT?: SuggestionScalarWhereInput | SuggestionScalarWhereInput[]
    id?: UuidFilter<"Suggestion"> | string
    documentId?: UuidFilter<"Suggestion"> | string
    documentCreatedAt?: DateTimeFilter<"Suggestion"> | Date | string
    originalText?: StringFilter<"Suggestion"> | string
    suggestedText?: StringFilter<"Suggestion"> | string
    description?: StringNullableFilter<"Suggestion"> | string | null
    isResolved?: BoolFilter<"Suggestion"> | boolean
    userId?: UuidFilter<"Suggestion"> | string
    createdAt?: DateTimeFilter<"Suggestion"> | Date | string
  }

  export type DocumentCreateWithoutSuggestionsInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    kind?: string
    userId: string
  }

  export type DocumentUncheckedCreateWithoutSuggestionsInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    kind?: string
    userId: string
  }

  export type DocumentCreateOrConnectWithoutSuggestionsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutSuggestionsInput, DocumentUncheckedCreateWithoutSuggestionsInput>
  }

  export type DocumentUpsertWithoutSuggestionsInput = {
    update: XOR<DocumentUpdateWithoutSuggestionsInput, DocumentUncheckedUpdateWithoutSuggestionsInput>
    create: XOR<DocumentCreateWithoutSuggestionsInput, DocumentUncheckedCreateWithoutSuggestionsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutSuggestionsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutSuggestionsInput, DocumentUncheckedUpdateWithoutSuggestionsInput>
  }

  export type DocumentUpdateWithoutSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateWithoutSuggestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicantProcessCreateManyApplicantInput = {
    id?: string
    processId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    timestamp?: Date | string
    action: string
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status: string
    errorMessage?: string | null
  }

  export type FileCreateManyUserInput = {
    id?: string
    fileUrl: string
    thumbnailUrl?: string | null
    size: number
    isPrivate?: boolean
    title: string
    fileType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormCreateManyCreatorInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    folderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FolderCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateManyCreatorInput = {
    id?: string
    name: string
    status?: $Enums.GroupStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessCreateManyCreatorInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    groupId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessedApplicationCreateManyUserInput = {
    id?: string
    processId: string
    applicantProcessId: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QrCodeDocumentCreateManyCreatorInput = {
    id?: string
    documentName: string
    fileName: string
    qrCodeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type ApplicantProcessUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUpdateManyWithoutApplicantProcessNestedInput
    process?: ProcessUpdateOneRequiredWithoutApplicantProcessesNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUncheckedUpdateManyWithoutApplicantProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUncheckedUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUncheckedUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateManyWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUpdateManyWithoutFormNestedInput
    folder?: FolderUpdateOneWithoutFormsNestedInput
    processForms?: ProcessFormUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUncheckedUpdateManyWithoutFormNestedInput
    processForms?: ProcessFormUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FolderUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forms?: FormUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forms?: FormUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: GroupRoleUpdateManyWithoutGroupNestedInput
    processes?: ProcessUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: GroupRoleUncheckedUpdateManyWithoutGroupNestedInput
    processes?: ProcessUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumGroupStatusFieldUpdateOperationsInput | $Enums.GroupStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUpdateManyWithoutProcessNestedInput
    group?: GroupUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUncheckedUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutProcessedApplicationsNestedInput
    applicantProcess?: ApplicantProcessUpdateOneRequiredWithoutProcessedApplicationsNestedInput
  }

  export type ProcessedApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeDocumentUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    qrCodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeDocumentUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    qrCodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QrCodeDocumentUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    qrCodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type GroupRoleCreateManyRoleInput = {
    groupId: string
    status?: $Enums.RoleStatus
  }

  export type ProcessRoleCreateManyRoleInput = {
    processId: string
    status?: $Enums.RoleStatus
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
    status?: $Enums.RoleStatus
  }

  export type GroupRoleUpdateWithoutRoleInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    group?: GroupUpdateOneRequiredWithoutRolesNestedInput
  }

  export type GroupRoleUncheckedUpdateWithoutRoleInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type GroupRoleUncheckedUpdateManyWithoutRoleInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type ProcessRoleUpdateWithoutRoleInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    process?: ProcessUpdateOneRequiredWithoutRolesNestedInput
  }

  export type ProcessRoleUncheckedUpdateWithoutRoleInput = {
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type ProcessRoleUncheckedUpdateManyWithoutRoleInput = {
    processId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type UserRoleUpdateWithoutRoleInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type GroupRoleCreateManyGroupInput = {
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type ProcessCreateManyGroupInput = {
    id?: string
    name: string
    type?: $Enums.ProcessType
    creatorId: string
    status?: $Enums.ProcessStatus
    archived?: boolean
    staffViewForms?: boolean
    applicantViewProcessLevel?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupRoleUpdateWithoutGroupInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    role?: RoleUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type GroupRoleUncheckedUpdateWithoutGroupInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type GroupRoleUncheckedUpdateManyWithoutGroupInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type ProcessUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUpdateManyWithoutProcessNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedProcessesNestedInput
  }

  export type ProcessUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcesses?: ApplicantProcessUncheckedUpdateManyWithoutProcessNestedInput
    formResponses?: FormResponseUncheckedUpdateManyWithoutProcessNestedInput
    forms?: ProcessFormUncheckedUpdateManyWithoutProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutProcessNestedInput
    roles?: ProcessRoleUncheckedUpdateManyWithoutProcessNestedInput
  }

  export type ProcessUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProcessTypeFieldUpdateOperationsInput | $Enums.ProcessType
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    staffViewForms?: BoolFieldUpdateOperationsInput | boolean
    applicantViewProcessLevel?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicantProcessCreateManyProcessInput = {
    id?: string
    applicantId: string
    status?: $Enums.ProcessStatus
    createdAt?: Date | string
  }

  export type FormResponseCreateManyProcessInput = {
    id?: string
    formId: string
    applicantProcessId: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProcessFormCreateManyProcessInput = {
    id?: string
    formId: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessedApplicationCreateManyProcessInput = {
    id?: string
    userId: string
    applicantProcessId: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcessRoleCreateManyProcessInput = {
    roleId: string
    status?: $Enums.RoleStatus
  }

  export type ApplicantProcessUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUpdateManyWithoutApplicantProcessNestedInput
    applicant?: UserUpdateOneRequiredWithoutApplicantProcessesNestedInput
    processedApplications?: ProcessedApplicationUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedForms?: APCompletedFormUncheckedUpdateManyWithoutApplicantProcessNestedInput
    processedApplications?: ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessNestedInput
    responses?: FormResponseUncheckedUpdateManyWithoutApplicantProcessNestedInput
    comments?: ProcessCommentUncheckedUpdateManyWithoutApplicantProcessNestedInput
  }

  export type ApplicantProcessUncheckedUpdateManyWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: StringFieldUpdateOperationsInput | string
    status?: EnumProcessStatusFieldUpdateOperationsInput | $Enums.ProcessStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcess?: ApplicantProcessUpdateOneRequiredWithoutResponsesNestedInput
    form?: FormUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type FormResponseUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUncheckedUpdateManyWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessFormUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutProcessFormsNestedInput
  }

  export type ProcessFormUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessFormUncheckedUpdateManyWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProcessedApplicationsNestedInput
    applicantProcess?: ApplicantProcessUpdateOneRequiredWithoutProcessedApplicationsNestedInput
  }

  export type ProcessedApplicationUncheckedUpdateWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationUncheckedUpdateManyWithoutProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessRoleUpdateWithoutProcessInput = {
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
    role?: RoleUpdateOneRequiredWithoutProcessesNestedInput
  }

  export type ProcessRoleUncheckedUpdateWithoutProcessInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type ProcessRoleUncheckedUpdateManyWithoutProcessInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    status?: EnumRoleStatusFieldUpdateOperationsInput | $Enums.RoleStatus
  }

  export type FormCreateManyFolderInput = {
    id?: string
    name: string
    type?: $Enums.FormType
    status?: $Enums.FormStatus
    archived?: boolean
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FormUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUpdateManyWithoutFormNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedFormsNestedInput
    processForms?: ProcessFormUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
    responses?: FormResponseUncheckedUpdateManyWithoutFormNestedInput
    processForms?: ProcessFormUncheckedUpdateManyWithoutFormNestedInput
  }

  export type FormUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFormTypeFieldUpdateOperationsInput | $Enums.FormType
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    design?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FormResponseCreateManyFormInput = {
    id?: string
    applicantProcessId: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processId: string
  }

  export type ProcessFormCreateManyFormInput = {
    id?: string
    processId: string
    order: number
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: ProcessFormCreatenextStepRolesInput | string[]
    nextStaffId?: string | null
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationRoles?: ProcessFormCreatenotificationRolesInput | string[]
    notificationToId?: string | null
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormResponseUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantProcess?: ApplicantProcessUpdateOneRequiredWithoutResponsesNestedInput
    process?: ProcessUpdateOneRequiredWithoutFormResponsesNestedInput
  }

  export type FormResponseUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processId?: StringFieldUpdateOperationsInput | string
  }

  export type FormResponseUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantProcessId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processId?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessFormUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    process?: ProcessUpdateOneRequiredWithoutFormsNestedInput
  }

  export type ProcessFormUncheckedUpdateWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessFormUncheckedUpdateManyWithoutFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: ProcessFormUpdatenextStepRolesInput | string[]
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationRoles?: ProcessFormUpdatenotificationRolesInput | string[]
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APCompletedFormCreateManyApplicantProcessInput = {
    id?: string
    formId: string
    reviewerId?: string | null
    nextStaffId?: string | null
    nextStepType?: $Enums.NextStepType
    nextStepRoles?: APCompletedFormCreatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: string | null
    notificationType?: $Enums.NextStepType
    notificationToId?: string | null
    notificationToRoles?: APCompletedFormCreatenotificationToRolesInput | string[]
    notificationComment?: string | null
    notifyApplicant?: boolean
    applicantNotificationContent?: string | null
    editApplicationStatus?: boolean
    applicantViewFormAfterCompletion?: boolean
    createdAt?: Date | string
  }

  export type ProcessedApplicationCreateManyApplicantProcessInput = {
    id?: string
    userId: string
    processId: string
    formId: string
    formRoleIds?: ProcessedApplicationCreateformRoleIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormResponseCreateManyApplicantProcessInput = {
    id?: string
    formId: string
    responses: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processId: string
  }

  export type ProcessCommentCreateManyApplicantProcessInput = {
    id?: string
    userId: string
    comment: string
    createdAt?: Date | string
  }

  export type APCompletedFormUpdateWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: APCompletedFormUpdatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToRoles?: APCompletedFormUpdatenotificationToRolesInput | string[]
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APCompletedFormUncheckedUpdateWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: APCompletedFormUpdatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToRoles?: APCompletedFormUpdatenotificationToRolesInput | string[]
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type APCompletedFormUncheckedUpdateManyWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    nextStepType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    nextStepRoles?: APCompletedFormUpdatenextStepRolesInput | string[]
    nextStepSpecifiedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNextStepTypeFieldUpdateOperationsInput | $Enums.NextStepType
    notificationToId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationToRoles?: APCompletedFormUpdatenotificationToRolesInput | string[]
    notificationComment?: NullableStringFieldUpdateOperationsInput | string | null
    notifyApplicant?: BoolFieldUpdateOperationsInput | boolean
    applicantNotificationContent?: NullableStringFieldUpdateOperationsInput | string | null
    editApplicationStatus?: BoolFieldUpdateOperationsInput | boolean
    applicantViewFormAfterCompletion?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationUpdateWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProcessedApplicationsNestedInput
    process?: ProcessUpdateOneRequiredWithoutProcessedApplicationsNestedInput
  }

  export type ProcessedApplicationUncheckedUpdateWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessedApplicationUncheckedUpdateManyWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    processId?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    formRoleIds?: ProcessedApplicationUpdateformRoleIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormResponseUpdateWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: FormUpdateOneRequiredWithoutResponsesNestedInput
    process?: ProcessUpdateOneRequiredWithoutFormResponsesNestedInput
  }

  export type FormResponseUncheckedUpdateWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processId?: StringFieldUpdateOperationsInput | string
  }

  export type FormResponseUncheckedUpdateManyWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    formId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processId?: StringFieldUpdateOperationsInput | string
  }

  export type ProcessCommentUpdateWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCommentUncheckedUpdateWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcessCommentUncheckedUpdateManyWithoutApplicantProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUserCreateManySuperiorInput = {
    id?: string
    userId: string
    title: string
  }

  export type OrganizationUserUpdateWithoutSuperiorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subordinates?: OrganizationUserUpdateManyWithoutSuperiorNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationNestedInput
  }

  export type OrganizationUserUncheckedUpdateWithoutSuperiorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subordinates?: OrganizationUserUncheckedUpdateManyWithoutSuperiorNestedInput
  }

  export type OrganizationUserUncheckedUpdateManyWithoutSuperiorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type WidgetCreateManyDashboardInput = {
    id?: string
    title: string
    visualizationType: string
    config: JsonNullValueInput | InputJsonValue
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WidgetUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    visualizationType?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetUncheckedUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    visualizationType?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WidgetUncheckedUpdateManyWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    visualizationType?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyChatInput = {
    id?: string
    role: string
    parts: JsonNullValueInput | InputJsonValue
    attachments: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    parts?: JsonNullValueInput | InputJsonValue
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateManyMessageInput = {
    chatId: string
    isUpvoted: boolean
  }

  export type VoteUpdateWithoutMessageInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    isUpvoted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoteUncheckedUpdateWithoutMessageInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    isUpvoted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoteUncheckedUpdateManyWithoutMessageInput = {
    chatId?: StringFieldUpdateOperationsInput | string
    isUpvoted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SuggestionCreateManyDocumentInput = {
    id?: string
    originalText: string
    suggestedText: string
    description?: string | null
    isResolved?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type SuggestionUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    suggestedText?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    suggestedText?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuggestionUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    suggestedText?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isResolved?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}